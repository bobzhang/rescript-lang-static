(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[22456],{22122:function(e,t,n){"use strict";function a(){return(a=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e}).apply(this,arguments)}n.d(t,{Z:function(){return a}})},17375:function(e,t,n){"use strict";function a(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}n.d(t,{Z:function(){return a}})},3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return c},kt:function(){return u}});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"===typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),m=p(n),u=r,h=m["".concat(s,".").concat(u)]||m[u]||d[u]||l;return n?a.createElement(h,o(o({ref:t},c),{},{components:n})):a.createElement(h,o({ref:t},c))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"===typeof e||r){var l=n.length,o=new Array(l);o[0]=m;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"===typeof e?e:r,o[1]=i;for(var p=2;p<l;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},96086:function(e){"use strict";var t=Object.assign.bind(Object);e.exports=t,e.exports.default=e.exports},86806:function(e,t,n){"use strict";n.r(t),n.d(t,{default:function(){return c}});var a,r=n(22122),l=n(17375),o=n(67294),i=n(3905),s=(o.createElement,a="CodeTab",function(e){return console.warn("Component "+a+" was not imported, exported, or provided by MDXProvider as global scope"),(0,i.kt)("div",e)}),p={};function c(e){var t=e.components,n=(0,l.Z)(e,["components"]);return(0,i.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"jsx"},"JSX"),(0,i.kt)("p",null,"Would you like some HTML syntax in your ReScript? If not, quickly skip over this section and pretend you didn't see anything!"),(0,i.kt)("p",null,"ReScript supports the JSX syntax, with some slight differences compared to the one in ",(0,i.kt)("a",(0,r.Z)({parentName:"p"},{href:"https://facebook.github.io/react/docs/introducing-jsx.html"}),"ReactJS"),". ReScript JSX isn't tied to ReactJS; they translate to normal function calls:"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note")," for ",(0,i.kt)("a",(0,r.Z)({parentName:"p"},{href:"https://reasonml.github.io/reason-react/en/"}),"ReasonReact")," readers: this isn't what ReasonReact turns JSX into, in the end. See Usage section for more info."),(0,i.kt)("h2",{id:"capitalized-tag"},"Capitalized Tag"),(0,i.kt)(s,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-re"}),'<MyComponent name={"ReScript"} />;\n')),(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-ml"}),"(* doesn't exist in old ML syntax *)\n")),(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-js"}),'React.createElement(\n  MyComponent.make,\n  MyComponent.makeProps("ReScript", undefined)\n);\n'))),(0,i.kt)("p",null,"becomes"),(0,i.kt)(s,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-re"}),'[@JSX] MyComponent.createElement(~name="ReScript", ~children=[], ());\n')),(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-ml"}),'MyComponent.createElement ~name:"ReScript" ~children:[] [@JSX]\n')),(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-js"}),'React.createElement(\n  MyComponent.make,\n  MyComponent.makeProps("ReScript", undefined)\n);\n'))),(0,i.kt)("h2",{id:"uncapitalized-tag"},"Uncapitalized Tag"),(0,i.kt)(s,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-re"}),"<div onClick={handler}> child1 child2 </div>;\n")),(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-ml"}),"(* doesn't exist in old ML syntax *)\n")),(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-js"}),'React.createElement("div", {\n  onClick: handler\n}, child1, child2);\n'))),(0,i.kt)("p",null,"becomes"),(0,i.kt)(s,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-re"}),"[@JSX] div(~onClick=handler, ~children=[child1, child2], ());\n")),(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-ml"}),"div ~onClick:handler ~children:[child1; child2] () [@@JSX]\n")),(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-js"}),'React.createElement("div", {\n  onClick: handler\n}, child1, child2);\n'))),(0,i.kt)("h2",{id:"fragment"},"Fragment"),(0,i.kt)(s,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-re"}),"<> child1 child2 </>;\n")),(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-ml"}),"(* doesn't exist in old ML syntax *)\n")),(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-js"}),"React.createElement(React.Fragment, undefined, child1, child2);\n"))),(0,i.kt)("p",null,"becomes"),(0,i.kt)(s,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-re"}),"[@JSX] [child1, child2];\n")),(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-ml"}),"[child1; child2] [@@JSX]\n")),(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-js"}),"React.createElement(React.Fragment, undefined, child1, child2);\n"))),(0,i.kt)("h3",{id:"children"},"Children"),(0,i.kt)(s,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-re"}),"<MyComponent> child1 child2 </MyComponent>;\n")),(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-ml"}),"(* doesn't exist in old ML syntax *)\n")),(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-js"}),"React.createElement(MyComponent.make, MyComponent.makeProps(null, undefined), child1, child2);\n"))),(0,i.kt)("p",null,"This is the syntax for passing a list of two items, ",(0,i.kt)("inlineCode",{parentName:"p"},"child1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"child2"),", to the children position. It desugars to a list containing ",(0,i.kt)("inlineCode",{parentName:"p"},"child1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"child2"),":"),(0,i.kt)(s,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-re"}),"[@JSX] MyComponent.createElement(~children=[child1, child2], ());\n")),(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-ml"}),"MyComponent.createElement ~children:[child1; child2] () [@@JSX]\n")),(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-js"}),"React.createElement(MyComponent.make, MyComponent.makeProps(null, undefined), child1, child2);\n"))),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note")," again that this isn't the transform for ReasonReact; ReasonReact turns the final list into an array. But the idea still applies."),(0,i.kt)("p",null,"So naturally, ",(0,i.kt)("inlineCode",{parentName:"p"},"<MyComponent> myChild </MyComponent>")," desugars to ",(0,i.kt)("inlineCode",{parentName:"p"},"@JSX MyComponent.createElement(~children=[myChild], ())"),". I.e. whatever you do, the arguments passed to the children position will be wrapped in a list. What if you don't want that? ",(0,i.kt)("strong",{parentName:"p"},"What if you want to directly pass ",(0,i.kt)("inlineCode",{parentName:"strong"},"myChild")," without an extra wrapping"),"?"),(0,i.kt)("h4",{id:"children-spread"},"Children Spread"),(0,i.kt)("p",null,"To solve the above problem, we've introduced"),(0,i.kt)(s,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-re"}),"<MyComponent> ...myChild </MyComponent>;\n")),(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-ml"}),"(* doesn't exist in old ML syntax *)\n")),(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-js"}),"React.createElement(MyComponent.make, MyComponent.makeProps(myChild, undefined));\n"))),(0,i.kt)("p",null,"This passes the value ",(0,i.kt)("inlineCode",{parentName:"p"},"myChild")," ",(0,i.kt)("em",{parentName:"p"},"without")," wrapping it in a list (or array, in the case of ReasonReact). Aka, this desugars to:"),(0,i.kt)(s,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-re"}),"[@JSX] MyComponent.createElement(~children=myChild, ());\n")),(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-ml"}),"MyComponent.createElement ~children:myChild () [@@JSX]\n")),(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-js"}),"React.createElement(MyComponent.make, MyComponent.makeProps(myChild, undefined));\n"))),(0,i.kt)("p",null,"This is extra useful in the cases where you are handled ",(0,i.kt)("inlineCode",{parentName:"p"},"myChild")," that is already a list of things, and want to forward that without wrapping it an extra time (which would be a type error) ","*",". It also allows you to pass arbitrary data structures at ",(0,i.kt)("inlineCode",{parentName:"p"},"children")," position (remember, JSX ",(0,i.kt)("inlineCode",{parentName:"p"},"children")," is really just a totally normal prop):"),(0,i.kt)(s,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-re"}),'<MyComponent> ...((theClassName) => <div className=theClassName />) </MyComponent>;\n\n<MyForm> ...("Hello", "Submit") </MyForm>;\n')),(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-ml"}),"(* doesn't exist in old ML syntax *)\n")),(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-js"}),'React.createElement(\n  make,\n  makeProps(function (theClassName) {\n    return React.createElement("div", {\n      className: theClassName,\n    });\n  }, undefined)\n);\n\nReact.createElement(MyForm.make, MyForm.makeProps(["Hello", "Submit"], undefined));\n'))),(0,i.kt)("h2",{id:"usage"},"Usage"),(0,i.kt)("p",null,"See ",(0,i.kt)("a",(0,r.Z)({parentName:"p"},{href:"https://reasonml.github.io/reason-react/docs/en/jsx"}),"ReasonReact JSX")," for an example application of JSX, which transforms the above calls into a ReasonReact-specific call."),(0,i.kt)("p",null,"Here's a JSX tag that shows most of the features."),(0,i.kt)(s,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-re"}),'<MyComponent\n  booleanAttribute={true}\n  stringAttribute="string"\n  intAttribute=1\n  forcedOptional=?{Some("hello")}\n  onClick={handleClick}>\n  <div> {React.string("hello")} </div>\n</MyComponent>;\n')),(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-ml"}),"(* doesn't exist in old ML syntax *)\n")),(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-js"}),'React.createElement(\n  MyComponent.make,\n  MyComponent.makeProps(\n    true,\n    "string",\n    1,\n    "hello",\n    handleClick,\n    React.createElement("div", undefined, "hello"),\n    undefined\n  )\n);\n'))),(0,i.kt)("h2",{id:"departures-from-js-jsx"},"Departures From JS JSX"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Attributes and children don't mandate ",(0,i.kt)("inlineCode",{parentName:"li"},"{}"),", but we show them anyway for ease of learning. Once you format your file, some of them go away and some turn into parentheses."),(0,i.kt)("li",{parentName:"ul"},"There is no support for JSX prop spread: ",(0,i.kt)("inlineCode",{parentName:"li"},"<Comp {...props} />"),". Though somewhat related,  we do have children spread, described above: ",(0,i.kt)("inlineCode",{parentName:"li"},"<Comp> ...children </Comp>"),"."),(0,i.kt)("li",{parentName:"ul"},"Punning!")),(0,i.kt)("h3",{id:"punning"},"Punning"),(0,i.kt)("p",null,'"Punning" refers to the syntax shorthand for when a label and a value are the same. For example, in JavaScript, instead of doing ',(0,i.kt)("inlineCode",{parentName:"p"},"return {name: name}"),", you can do ",(0,i.kt)("inlineCode",{parentName:"p"},"return {name}"),"."),(0,i.kt)("p",null,"Reason JSX supports punning. ",(0,i.kt)("inlineCode",{parentName:"p"},"<input checked />")," is just a shorthand for ",(0,i.kt)("inlineCode",{parentName:"p"},"<input checked=checked />"),". The formatter will help you format to the punned syntax whenever possible. This is convenient in the cases where there are lots of props to pass down:"),(0,i.kt)(s,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-re"}),"<MyComponent isLoading text onClick />;\n")),(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-ml"}),"(* doesn't exist in old ML syntax *)\n")),(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-js"}),"React.createElement(\n  MyComponent.make,\n  MyComponent.makeProps(isLoading, text, onClick, undefined)\n);\n"))),(0,i.kt)("p",null,"Consequently, a Reason JSX component can cram in a few more props before reaching for extra libraries solutions that avoids props passing."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note")," that this is a departure from ReactJS JSX, which does ",(0,i.kt)("strong",{parentName:"p"},"not")," have punning. ReactJS' ",(0,i.kt)("inlineCode",{parentName:"p"},"<input checked />")," desugars to ",(0,i.kt)("inlineCode",{parentName:"p"},"<input checked=true />"),", in order to conform to DOM's idioms and for backward compatibility."),(0,i.kt)("h2",{id:"tip--tricks"},"Tip & Tricks"),(0,i.kt)("p",null,"For library authors wanting to take advantage of the JSX: the ",(0,i.kt)("inlineCode",{parentName:"p"},"@JSX")," attribute above is a hook for potential ppx macros to spot a function wanting to format as JSX. Once you spot the function, you can turn it into any other expression."),(0,i.kt)("p",null,"This way, everyone gets to benefit the JSX syntax without needing to opt into a specific library using it, e.g. ReasonReact."),(0,i.kt)("p",null,"JSX calls supports the features of ",(0,i.kt)("a",(0,r.Z)({parentName:"p"},{href:"function.md#labeled-arguments"}),"labeled functions"),": optional, explicitly passed optional and optional with default."),(0,i.kt)("h2",{id:"design-decisions"},"Design Decisions"),(0,i.kt)("p",null,"*"," You might wonder why you never needed such children spread in ReactJS; ReactJS uses some special runtime logic + special syntax transforms + variadic argument detection & marking to avoid most of these cases (",(0,i.kt)("a",(0,r.Z)({parentName:"p"},{href:"https://github.com/facebook/react/blob/9b36df86c6ccecb73ca44899386e6a72a83ad445/packages/react/src/ReactElement.js#L207"}),"see here"),"). Such dynamic usage complexifies the type system detection ",(0,i.kt)("em",{parentName:"p"},"quite a bit"),". Since we control the whole syntax and ReasonReact, we decided to introduce children spread to disambiguate between the case of wrapping vs not wrapping, without compile-time & runtime cost!"))}c.isMDXComponent=!0,c.frontmatter={title:"JSX",description:"JSX syntax in ReScript and React",canonical:"/docs/manual/latest/jsx",__ghEditHref:"https://github.com/reason-association/rescript-lang.org/blob/master/pages/docs/manual/v8.0.0/jsx.mdx"}},45679:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/docs/manual/v8.0.0/jsx",function(){return n(86806)}])}},function(e){e.O(0,[49774],(function(){return t=45679,e(e.s=t);var t}));var t=e.O();_N_E=t}]);