(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[94137],{22122:function(e,t,n){"use strict";function a(){return(a=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e}).apply(this,arguments)}n.d(t,{Z:function(){return a}})},17375:function(e,t,n){"use strict";function a(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}n.d(t,{Z:function(){return a}})},3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return u},kt:function(){return c}});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=a.createContext({}),s=function(e){var t=a.useContext(p),n=t;return e&&(n="function"===typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=s(e.components);return a.createElement(p.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,p=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),m=s(n),c=r,k=m["".concat(p,".").concat(c)]||m[c]||d[c]||o;return n?a.createElement(k,l(l({ref:t},u),{},{components:n})):a.createElement(k,l({ref:t},u))}));function c(e,t){var n=arguments,r=t&&t.mdxType;if("string"===typeof e||r){var o=n.length,l=new Array(o);l[0]=m;var i={};for(var p in t)hasOwnProperty.call(t,p)&&(i[p]=t[p]);i.originalType=e,i.mdxType="string"===typeof e?e:r,l[1]=i;for(var s=2;s<o;s++)l[s]=n[s];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},96086:function(e){"use strict";var t=Object.assign.bind(Object);e.exports=t,e.exports.default=e.exports},1970:function(e,t,n){"use strict";n.r(t),n.d(t,{default:function(){return u}});var a,r=n(22122),o=n(17375),l=n(67294),i=n(3905),p=(l.createElement,a="CodeTab",function(e){return console.warn("Component "+a+" was not imported, exported, or provided by MDXProvider as global scope"),(0,i.kt)("div",e)}),s={};function u(e){var t=e.components,n=(0,o.Z)(e,["components"]);return(0,i.kt)("wrapper",(0,r.Z)({},s,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"null-undefined-and-option"},"Null, Undefined and Option"),(0,i.kt)("p",null,"ReScript itself doesn't have the notion of ",(0,i.kt)("inlineCode",{parentName:"p"},"null")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"undefined"),". This is a ",(0,i.kt)("em",{parentName:"p"},"great")," thing, as it wipes out an entire category of bugs. No more ",(0,i.kt)("inlineCode",{parentName:"p"},"undefined is not a function"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"cannot access someAttribute of undefined"),"!"),(0,i.kt)("p",null,"However, the ",(0,i.kt)("strong",{parentName:"p"},"concept")," of a potentially nonexistent value is still useful, and safely exists in our language."),(0,i.kt)("p",null,"We represent the existence and nonexistence of a value by wrapping it with the ",(0,i.kt)("inlineCode",{parentName:"p"},"option")," type. Here's its definition from the standard library:"),(0,i.kt)(p,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"type option<'a> = None | Some('a)\n")),(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-js"}),"// Empty output\n"))),(0,i.kt)("p",null,'It means "a value of type option is either None (representing nothing) or that actual value wrapped in a Some".'),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note")," how the ",(0,i.kt)("inlineCode",{parentName:"p"},"option")," type is just a regular ",(0,i.kt)("a",(0,r.Z)({parentName:"p"},{href:"variant.md"}),"variant"),"."),(0,i.kt)("h2",{id:"example"},"Example"),(0,i.kt)("p",null,"Here's a normal value:"),(0,i.kt)(p,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"let licenseNumber = 5\n")),(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-js"}),"var licenseNumber = 5;\n"))),(0,i.kt)("p",null,'To represent the concept of "maybe null", you\'d turn this into an ',(0,i.kt)("inlineCode",{parentName:"p"},"option")," type by wrapping it. For the sake of a more illustrative example, we'll put a condition around it:"),(0,i.kt)(p,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-res"}),"let licenseNumber =\n  if personHasACar {\n    Some(5)\n  } else {\n    None\n  }\n")),(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-js"}),"var licenseNumber = personHasACar ? 5 : undefined;\n"))),(0,i.kt)("p",null,"Later on, when another piece of code receives such value, it'd be forced to handle both cases through ",(0,i.kt)("a",(0,r.Z)({parentName:"p"},{href:"pattern-matching-destructuring.md"}),"pattern matching"),":"),(0,i.kt)(p,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-res"}),'switch licenseNumber {\n| None =>\n  Js.log("The person doesn\'t have a car")\n| Some(number) =>\n  Js.log("The person\'s license number is " ++ Js.Int.toString(number))\n}\n')),(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-js"}),'var number = licenseNumber;\n\nif (number !== undefined) {\n  console.log("The person\'s license number is " + number.toString());\n} else {\n  console.log("The person doesn\'t have a car");\n}\n'))),(0,i.kt)("p",null,"By turning your ordinary number into an ",(0,i.kt)("inlineCode",{parentName:"p"},"option")," type, and by forcing you to handle the ",(0,i.kt)("inlineCode",{parentName:"p"},"None")," case, the language effectively removed the possibility for you to mishandle, or forget to handle, a conceptual ",(0,i.kt)("inlineCode",{parentName:"p"},"null")," value! ",(0,i.kt)("strong",{parentName:"p"},"A pure ReScript program doesn't have null errors"),"."),(0,i.kt)("h2",{id:"interoperate-with-javascript-undefined-and-null"},"Interoperate with JavaScript ",(0,i.kt)("inlineCode",{parentName:"h2"},"undefined")," and ",(0,i.kt)("inlineCode",{parentName:"h2"},"null")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"option")," type is common enough that we special-case it when compiling to JavaScript:"),(0,i.kt)(p,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"let x = Some(5)\n")),(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-js"}),"var x = 5;\n"))),(0,i.kt)("p",null,"simply compiles down to ",(0,i.kt)("inlineCode",{parentName:"p"},"5"),", and"),(0,i.kt)(p,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"let x = None\n")),(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-js"}),"var x;\n"))),(0,i.kt)("p",null,"compiles to ",(0,i.kt)("inlineCode",{parentName:"p"},"undefined"),"! If you've got e.g. a string in JavaScript that you know might be ",(0,i.kt)("inlineCode",{parentName:"p"},"undefined"),", type it as ",(0,i.kt)("inlineCode",{parentName:"p"},"option<string>")," and you're done! Likewise, you can send a ",(0,i.kt)("inlineCode",{parentName:"p"},"Some(5)")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"None")," to the JS side and expect it to be interpreted correctly =)"),(0,i.kt)("h3",{id:"caveat-1"},"Caveat 1"),(0,i.kt)("p",null,"The option-to-undefined translation isn't perfect, because on our side, ",(0,i.kt)("inlineCode",{parentName:"p"},"option")," values can be composed:"),(0,i.kt)(p,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"let x = Some(Some(Some(5)))\n")),(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-js"}),"var x = 5;\n"))),(0,i.kt)("p",null,"This still compiles to ",(0,i.kt)("inlineCode",{parentName:"p"},"5"),", but this gets troublesome:"),(0,i.kt)(p,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"let x = Some(None)\n")),(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-js"}),'var Caml_option = require("./stdlib/caml_option.js");\n\nvar x = Caml_option.some(undefined);\n')),(0,i.kt)("p",null,"(See output tab).")),(0,i.kt)("p",null,"What's this ",(0,i.kt)("inlineCode",{parentName:"p"},"Caml_option.some")," thing? Why can't this compile to ",(0,i.kt)("inlineCode",{parentName:"p"},"undefined"),"? Long story short, when dealing with a polymorphic ",(0,i.kt)("inlineCode",{parentName:"p"},"option")," type (aka ",(0,i.kt)("inlineCode",{parentName:"p"},"option<'a>"),", for any ",(0,i.kt)("inlineCode",{parentName:"p"},"'a"),"), many operations become tricky if we don't mark the value with some special annotation. If this doesn't make sense, don't worry; just remember the following rule:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Never, EVER, pass a nested ",(0,i.kt)("inlineCode",{parentName:"strong"},"option")," value (e.g. ",(0,i.kt)("inlineCode",{parentName:"strong"},"Some(Some(Some(5)))"),") into the JS side.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Never, EVER, annotate a value coming from JS as ",(0,i.kt)("inlineCode",{parentName:"strong"},"option<'a>"),". Always give the concrete, non-polymorphic type."))),(0,i.kt)("h3",{id:"caveat-2"},"Caveat 2"),(0,i.kt)("p",null,"Unfortunately, lots of times, your JavaScript value might be ",(0,i.kt)("em",{parentName:"p"},"both")," ",(0,i.kt)("inlineCode",{parentName:"p"},"null")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"undefined"),". In that case, you unfortunately can't type such value as e.g. ",(0,i.kt)("inlineCode",{parentName:"p"},"option<int>"),", since our ",(0,i.kt)("inlineCode",{parentName:"p"},"option")," type only checks for ",(0,i.kt)("inlineCode",{parentName:"p"},"undefined")," and not ",(0,i.kt)("inlineCode",{parentName:"p"},"null")," when dealing with a ",(0,i.kt)("inlineCode",{parentName:"p"},"None"),"."),(0,i.kt)("h4",{id:"solution-more-sophisticated-undefined--null-interop"},"Solution: More Sophisticated ",(0,i.kt)("inlineCode",{parentName:"h4"},"undefined")," & ",(0,i.kt)("inlineCode",{parentName:"h4"},"null")," Interop"),(0,i.kt)("p",null,"To solve this, we provide access to more elaborate ",(0,i.kt)("inlineCode",{parentName:"p"},"null")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"undefined")," helpers through the ",(0,i.kt)("a",(0,r.Z)({parentName:"p"},{href:"api/js/nullable"}),(0,i.kt)("inlineCode",{parentName:"a"},"Js.Nullable"))," module. This somewhat works like an ",(0,i.kt)("inlineCode",{parentName:"p"},"option")," type, but is different from it."),(0,i.kt)("h4",{id:"examples"},"Examples"),(0,i.kt)("p",null,"To create a JS ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", use the value ",(0,i.kt)("inlineCode",{parentName:"p"},"Js.Nullable.null"),". To create a JS ",(0,i.kt)("inlineCode",{parentName:"p"},"undefined"),", use ",(0,i.kt)("inlineCode",{parentName:"p"},"Js.Nullable.undefined")," (you can naturally use ",(0,i.kt)("inlineCode",{parentName:"p"},"None")," too, but that's not the point here; the ",(0,i.kt)("inlineCode",{parentName:"p"},"Js.Nullable.*")," helpers wouldn't work with it)."),(0,i.kt)("p",null,"If you're receiving, for example, a JS string that can be ",(0,i.kt)("inlineCode",{parentName:"p"},"null")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"undefined"),", type it as:"),(0,i.kt)(p,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'@module("MyConstant") external myId: Js.Nullable.t<string> = "myId"\n')),(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-js"}),"// Empty output\n"))),(0,i.kt)("p",null,"To create such a nullable string from our side (presumably to pass it to the JS side, for interop purpose), do:"),(0,i.kt)(p,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'@module("MyIdValidator") external validate: Js.Nullable.t<string> => bool = "validate"\nlet personId: Js.Nullable.t<string> = Js.Nullable.return("abc123")\n\nlet result = validate(personId)\n')),(0,i.kt)("pre",null,(0,i.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-js"}),'var MyIdValidator = require("MyIdValidator");\nvar personId = "abc123";\nvar result = MyIdValidator.validate(personId);\n'))),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"return"),' part "wraps" a string into a nullable string, to make the type system understand and track the fact that, as you pass this value around, it\'s not just a string, but a string that can be ',(0,i.kt)("inlineCode",{parentName:"p"},"null")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"undefined"),"."),(0,i.kt)("h4",{id:"convert-tofrom-option"},"Convert to/from ",(0,i.kt)("inlineCode",{parentName:"h4"},"option")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Js.Nullable.fromOption")," converts from a ",(0,i.kt)("inlineCode",{parentName:"p"},"option")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"Js.Nullable.t"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"Js.Nullable.toOption")," does the opposite."))}u.isMDXComponent=!0,u.frontmatter={title:"Null, Undefined and Option",description:"JS interop with nullable and optional values in ReScript",canonical:"/docs/manual/latest/null-undefined-option",__ghEditHref:"https://github.com/reason-association/rescript-lang.org/blob/master/pages/docs/manual/latest/null-undefined-option.mdx"}},96398:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/docs/manual/latest/null-undefined-option",function(){return n(1970)}])}},function(e){e.O(0,[49774],(function(){return t=96398,e(e.s=t);var t}));var t=e.O();_N_E=t}]);