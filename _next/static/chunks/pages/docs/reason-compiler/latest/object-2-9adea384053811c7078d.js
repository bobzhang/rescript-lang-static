(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[35859],{22122:function(e,t,n){"use strict";function a(){return(a=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e}).apply(this,arguments)}n.d(t,{Z:function(){return a}})},17375:function(e,t,n){"use strict";function a(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}n.d(t,{Z:function(){return a}})},3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return c},kt:function(){return m}});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"===typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=p(n),m=o,h=d["".concat(s,".").concat(m)]||d[m]||u[m]||r;return n?a.createElement(h,i(i({ref:t},c),{},{components:n})):a.createElement(h,i({ref:t},c))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"===typeof e||o){var r=n.length,i=new Array(r);i[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"===typeof e?e:o,i[1]=l;for(var p=2;p<r;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},96086:function(e){"use strict";var t=Object.assign.bind(Object);e.exports=t,e.exports.default=e.exports},43258:function(e,t,n){"use strict";n.r(t),n.d(t,{default:function(){return s}});var a=n(22122),o=n(17375),r=n(67294),i=n(3905),l=(r.createElement,{});function s(e){var t=e.components,n=(0,o.Z)(e,["components"]);return(0,i.kt)("wrapper",(0,a.Z)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"object-2"},"Object 2"),(0,i.kt)("p",null,"There's an alternative of binding to JavaScript objects, if the previous section's ",(0,i.kt)("inlineCode",{parentName:"p"},"bs.deriving abstract")," doesn't suit your needs:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"You don't want to declare a type beforehand"),(0,i.kt)("li",{parentName:"ul"},'You want your object to be "structural", e.g. your function wants to accept "any object with the field ',(0,i.kt)("inlineCode",{parentName:"li"},"age"),', not just a particular object whose type definition is declared above".')),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Reminder of the above distinction of record vs object ",(0,i.kt)("a",(0,a.Z)({parentName:"p"},{href:"/docs/manual/latest/record#record-types-are-found-by-field-name"}),"here"),".")),(0,i.kt)("p",null,"This section describes how BuckleScript uses OCaml's object facility to achieve this other way of binding and compiling to JavaScript objects."),(0,i.kt)("h2",{id:"pitfall"},"Pitfall"),(0,i.kt)("p",null,"First, note that we ",(0,i.kt)("strong",{parentName:"p"},"cannot")," use the ordinary OCaml/Reason object type, like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",(0,a.Z)({parentName:"pre"},{className:"language-reason"}),"type person = {\n  .\n  name: string,\n  age: int,\n  job: string\n};\n")),(0,i.kt)("p",null,"You can still use this feature, but this OCaml/Reason object type does ",(0,i.kt)("strong",{parentName:"p"},"not")," compile to a clean JavaScript object! Unfortunately, this is because OCaml/Reason objects work a bit too differently from JS objects."),(0,i.kt)("h2",{id:"actual-solution"},"Actual Solution"),(0,i.kt)("p",null,"BuckleScript wraps the regular OCaml/Reason object type with ",(0,i.kt)("inlineCode",{parentName:"p"},"Js.t"),", in order to control and track a ",(0,i.kt)("strong",{parentName:"p"},"subset")," of operations and types that we know would compile cleanly to JavaScript. This is how it looks like:"),(0,i.kt)("pre",null,(0,i.kt)("code",(0,a.Z)({parentName:"pre"},{className:"language-reason"}),'type person = Js.t({\n  .\n  name: string,\n  age: int,\n  job: string\n});\n\n[@bs.val] external john : person = "john";\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"From now on"),", we'll call the BuckleScript interop object \"",(0,i.kt)("inlineCode",{parentName:"p"},"Js.t"),' object", to disambiguate it with normal object and JS object.'),(0,i.kt)("p",null,"Because object types are used often, Reason gives it a nicer sugar.\nWriting ",(0,i.kt)("inlineCode",{parentName:"p"},'{. "name": string}')," is syntactic sugar for ",(0,i.kt)("inlineCode",{parentName:"p"},"Js.t({. name: string})"),".\nNote that the double quotes around the field name ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," are necessary.\nWithout it, this expression becomes an OCaml object, which you probably don't want to if you're targeting JavaScript."),(0,i.kt)("h3",{id:"accessors"},"Accessors"),(0,i.kt)("h4",{id:"read"},"Read"),(0,i.kt)("p",null,"To access a field, use ",(0,i.kt)("inlineCode",{parentName:"p"},"##"),": ",(0,i.kt)("inlineCode",{parentName:"p"},"let johnName = john##name"),"."),(0,i.kt)("h4",{id:"write"},"Write"),(0,i.kt)("p",null,"To modify a field, you need to first mark a field as mutable. By default, the ",(0,i.kt)("inlineCode",{parentName:"p"},"Js.t")," object type is immutable."),(0,i.kt)("pre",null,(0,i.kt)("code",(0,a.Z)({parentName:"pre"},{className:"language-reason"}),'type person = {. [@bs.set] "age": int};\n[@bs.val] external john : person = "john";\n\njohn##age #= 99;\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note"),": you can't use dynamic/computed keys in this paradigm."),(0,i.kt)("h4",{id:"call"},"Call"),(0,i.kt)("p",null,"To call a method of a field, mark the function signature as ",(0,i.kt)("inlineCode",{parentName:"p"},"[@bs.meth]"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",(0,a.Z)({parentName:"pre"},{className:"language-reason"}),'type person = {. [@bs.meth] "say": (string, string) => unit};\n[@bs.val] external john : person = "john";\n\njohn##say("hey", "jude");\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Why ",(0,i.kt)("inlineCode",{parentName:"strong"},"[bs.meth]")),"? Why not just call it directly? A JS object might carry around a reference to ",(0,i.kt)("inlineCode",{parentName:"p"},"this"),", and infamously, what ",(0,i.kt)("inlineCode",{parentName:"p"},"this")," points to can change. OCaml/BuckleScript functions are curried by default; this means that if you intentionally curry ",(0,i.kt)("inlineCode",{parentName:"p"},"say"),", by the time you fully apply it, the ",(0,i.kt)("inlineCode",{parentName:"p"},"this")," context could be wrong:"),(0,i.kt)("pre",null,(0,i.kt)("code",(0,a.Z)({parentName:"pre"},{className:"language-reason"}),'/* wrong */\nlet talkTo = john##say("hey");\n\nlet jude = talkTo("jude");\nlet paul = talkTo("paul");\n')),(0,i.kt)("p",null,"To ensure that folks don't accidentally curry a JavaScript method, we track every method call using ",(0,i.kt)("inlineCode",{parentName:"p"},"##")," to make sure it's fully applied ",(0,i.kt)("em",{parentName:"p"},"immediately"),". Under the hood, we effectively turn a function-looking call into a special ",(0,i.kt)("inlineCode",{parentName:"p"},"bs.meth")," call (it only ",(0,i.kt)("em",{parentName:"p"},"looks")," like a function). Annotating the type definition of ",(0,i.kt)("inlineCode",{parentName:"p"},"say")," with ",(0,i.kt)("inlineCode",{parentName:"p"},"bs.meth")," completes this check."),(0,i.kt)("h3",{id:"creation"},"Creation"),(0,i.kt)("h4",{id:"literal"},"Literal"),(0,i.kt)("p",null,"You can use ",(0,i.kt)("inlineCode",{parentName:"p"},"[%bs.obj putAnOCamlRecordHere]")," DSL to create a ",(0,i.kt)("inlineCode",{parentName:"p"},"Js.t")," object:"),(0,i.kt)("pre",null,(0,i.kt)("code",(0,a.Z)({parentName:"pre"},{className:"language-reason"}),'let bucklescript = [%bs.obj {\n  info: {author: "Bob"}\n}];\n\nlet name = bucklescript##info##author;\n')),(0,i.kt)("p",null,"Because object values are used often, Reason gives it a nicer sugar: ",(0,i.kt)("inlineCode",{parentName:"p"},'{"foo": 1}'),", which desugars to: ",(0,i.kt)("inlineCode",{parentName:"p"},"[%bs.obj {foo: 1}]"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note"),": there's no syntax sugar for creating an empty object in OCaml nor Reason (aka this doesn't work: ",(0,i.kt)("inlineCode",{parentName:"p"},"[%bs.obj {}]"),". Please use ",(0,i.kt)("inlineCode",{parentName:"p"},"Js.Obj.empty()")," for that purpose."),(0,i.kt)("p",null,"The created object will have an inferred type, no type declaration needed! The above example will infer as:"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note"),": since the value has its type inferred, ",(0,i.kt)("strong",{parentName:"p"},"don't")," accidentally do this:"),(0,i.kt)("pre",null,(0,i.kt)("code",(0,a.Z)({parentName:"pre"},{className:"language-reason"}),'type person = {. "age": int};\nlet jane = {"age": "hi"};\n')),(0,i.kt)("p",null,"See what went wrong here? We've declared a ",(0,i.kt)("inlineCode",{parentName:"p"},"person")," type, but ",(0,i.kt)("inlineCode",{parentName:"p"},"jane")," is inferred as its own type, so ",(0,i.kt)("inlineCode",{parentName:"p"},"person")," is ignored and no error happens! To give ",(0,i.kt)("inlineCode",{parentName:"p"},"jane")," an explicit type, simply annotate it: ",(0,i.kt)("inlineCode",{parentName:"p"},"let jane: person = ..."),". This will then error correctly."),(0,i.kt)("h4",{id:"function"},"Function"),(0,i.kt)("p",null,"You can declare an external function that, when called, will evaluate to a ",(0,i.kt)("inlineCode",{parentName:"p"},"Js.t")," object with fields corresponding to the function's parameter labels. This is very handy because you can make some of those labelled parameters ",(0,i.kt)("em",{parentName:"p"},"optional")," and if you don't pass them in, the output object ",(0,i.kt)("em",{parentName:"p"},"won't include")," the corresponding fields. Thus you can use it to dynamically create objects with the subset of fields you need at runtime."),(0,i.kt)("p",null,"For example, suppose you need a JavaScript object like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",(0,a.Z)({parentName:"pre"},{className:"language-js"}),'var homeRoute = {\n  method: "GET",\n  path: "/",\n  action: () => console.log("Home"),\n  // options: ...\n};\n')),(0,i.kt)("p",null,"But only the first three fields are required; the ",(0,i.kt)("inlineCode",{parentName:"p"},"options")," field is optional. You can declare the binding function like so:"),(0,i.kt)("pre",null,(0,i.kt)("code",(0,a.Z)({parentName:"pre"},{className:"language-reason"}),'[@bs.obj] external route: (\n  ~_method:string,\n  ~path:string,\n  ~action:(list(string) => unit),\n  ~options:Js.t({..})=?,\n  unit\n) => _ = "";\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note"),": the ",(0,i.kt)("inlineCode",{parentName:"p"},' = ""')," part at the end is just a dummy placeholder, due to syntactic limitations. It serves no purpose currently."),(0,i.kt)("p",null,"This function has four labelled parameters (the fourth one optional), one unlabelled parameter at the end (which we mandate for functions with ",(0,i.kt)("a",(0,a.Z)({parentName:"p"},{href:"/docs/manual/latest/function.html#optional-labeled-arguments"}),"optional parameters"),"), and one parameter (",(0,i.kt)("inlineCode",{parentName:"p"},"_method"),") that requires an underscore prefix to avoid confusion with the OCaml/Reason keyword ",(0,i.kt)("inlineCode",{parentName:"p"},"method"),"."),(0,i.kt)("p",null,"Also of interest is the return type: ",(0,i.kt)("inlineCode",{parentName:"p"},"_"),", which tells BuckleScript to automatically infer the full type of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Js.t")," object, sparing you the hassle of writing down the type manually!"),(0,i.kt)("p",null,"The function is called like so:"),(0,i.kt)("pre",null,(0,i.kt)("code",(0,a.Z)({parentName:"pre"},{className:"language-reason"}),'let homeRoute = route(~_method="GET", ~path="/", ~action=(_ => Js.log("Home")), ());\n')),(0,i.kt)("p",null,"This generates the desired JavaScript object\u2013but you'll notice that the ",(0,i.kt)("inlineCode",{parentName:"p"},"options")," parameter was left out. As expected, the generated object won't include the ",(0,i.kt)("inlineCode",{parentName:"p"},"options")," field."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note")," that for more type-safety you'll probably want to ",(0,i.kt)("a",(0,a.Z)({parentName:"p"},{href:"/docs/manual/latest/bind-to-js-function#constrain-arguments-better"}),"constrain")," the ",(0,i.kt)("inlineCode",{parentName:"p"},"_method")," parameter type to only the acceptable values."))}s.isMDXComponent=!0,s.frontmatter={__ghEditHref:"https://github.com/reason-association/rescript-lang.org/blob/master/pages/docs/reason-compiler/latest/object-2.mdx"}},60538:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/docs/reason-compiler/latest/object-2",function(){return n(43258)}])}},function(e){e.O(0,[49774],(function(){return t=60538,e(e.s=t);var t}));var t=e.O();_N_E=t}]);