(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[73237],{22122:function(e,n,t){"use strict";function r(){return(r=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r])}return e}).apply(this,arguments)}t.d(n,{Z:function(){return r}})},17375:function(e,n,t){"use strict";function r(e,n){if(null==e)return{};var t,r,i=function(e,n){if(null==e)return{};var t,r,i={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}t.d(n,{Z:function(){return r}})},3905:function(e,n,t){"use strict";t.d(n,{Zo:function(){return c},kt:function(){return d}});var r=t(67294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,r,i=function(e,n){if(null==e)return{};var t,r,i={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=r.createContext({}),p=function(e){var n=r.useContext(s),t=n;return e&&(t="function"===typeof e?e(n):a(a({},n),e)),t},c=function(e){var n=p(e.components);return r.createElement(s.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},m=r.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),m=p(t),d=i,f=m["".concat(s,".").concat(d)]||m[d]||u[d]||o;return t?r.createElement(f,a(a({ref:n},c),{},{components:t})):r.createElement(f,a({ref:n},c))}));function d(e,n){var t=arguments,i=n&&n.mdxType;if("string"===typeof e||i){var o=t.length,a=new Array(o);a[0]=m;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"===typeof e?e:i,a[1]=l;for(var p=2;p<o;p++)a[p]=t[p];return r.createElement.apply(null,a)}return r.createElement.apply(null,t)}m.displayName="MDXCreateElement"},96086:function(e){"use strict";var n=Object.assign.bind(Object);e.exports=n,e.exports.default=e.exports},12746:function(e,n,t){"use strict";t.r(n),t.d(n,{default:function(){return s}});var r=t(22122),i=t(17375),o=t(67294),a=t(3905),l=(o.createElement,{});function s(e){var n=e.components,t=(0,i.Z)(e,["components"]);return(0,a.kt)("wrapper",(0,r.Z)({},l,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"conditional-compilation"},"Conditional Compilation"),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"This only works with the old OCaml syntax.")),(0,a.kt)("p",null,"Sometimes you want to write code that works with different versions of compilers and libraries."),(0,a.kt)("p",null,"People used to use preprocessors like ",(0,a.kt)("a",(0,r.Z)({parentName:"p"},{href:"http://tigcc.ticalc.org/doc/cpp.html"}),"C preprocessor")," for the C family languages. The OCaml community uses several preprocessors: ",(0,a.kt)("a",(0,r.Z)({parentName:"p"},{href:"https://github.com/mjambon/cppo"}),"cppo"),", ",(0,a.kt)("a",(0,r.Z)({parentName:"p"},{href:"https://github.com/OCamlPro/typerex-build/tree/master/tools/ocp-pp"}),"ocp-pp"),", camlp4 IFDEF macros, ",(0,a.kt)("a",(0,r.Z)({parentName:"p"},{href:"https://github.com/diml/optcomp"}),"optcomp")," and ",(0,a.kt)("a",(0,r.Z)({parentName:"p"},{href:"https://github.com/janestreet/ppx_optcomp"}),"ppx optcomp"),"."),(0,a.kt)("p",null,"Instead of a preprocessor, ReScript adds language-level static ",(0,a.kt)("inlineCode",{parentName:"p"},"if")," compilation. It's less powerful than other preprocessors since it only supports static ",(0,a.kt)("inlineCode",{parentName:"p"},"if")," (no ",(0,a.kt)("inlineCode",{parentName:"p"},"#define"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"#undefine"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"#include"),"), but there are several advantages."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"It\u2019s tiny (only ~500 lines) and highly efficient. Everything can be done in a ",(0,a.kt)("strong",{parentName:"li"},"single pass"),". It's easy to rebuild the pre-processor into a standalone file, with no dependencies on compiler libs, to back-port it to old OCaml compilers."),(0,a.kt)("li",{parentName:"ul"},"It\u2019s purely functional and type-safe, and cooperates with editor tooling like Merlin.")),(0,a.kt)("h2",{id:"usage"},"Usage"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"lwt_unix.mli")),(0,a.kt)("pre",null,(0,a.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-ocaml"}),'type open_flag =\n    Unix.open_flag =\n  | O_RDONLY\n  | O_WRONLY\n  | O_RDWR\n  | O_NONBLOCK\n  | O_APPEND\n  | O_CREAT\n  | O_TRUNC\n  | O_EXCL\n  | O_NOCTTY\n  | O_DSYNC\n  | O_SYNC\n  | O_RSYNC\n#if OCAML_VERSION =~ ">=3.13" then\n  | O_SHARE_DELETE\n#end\n#if OCAML_VERSION =~ ">=4.01" then\n  | O_CLOEXEC\n#end\n')),(0,a.kt)("p",null,"You don't have to add anything to the build to have these work. The compiler ",(0,a.kt)("inlineCode",{parentName:"p"},"bsc")," understands these already."),(0,a.kt)("h2",{id:"built-in--custom-variables"},"Built-in & Custom Variables"),(0,a.kt)("p",null,"See the output of ",(0,a.kt)("inlineCode",{parentName:"p"},"bsc.exe -bs-list-conditionals"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-sh"}),'> bsc.exe -bs-D CUSTOM_A="ghsigh" -bs-list-conditionals\nOCAML_PATCH "BS"\nBS_VERSION "1.2.1"\nOS_TYPE "Unix"\nBS true\nCUSTOM_A "ghsigh"\nWORD_SIZE 64\nOCAML_VERSION "4.02.3+BS"\nBIG_ENDIAN false\n')),(0,a.kt)("p",null,"Add your custom variable to the mix with ",(0,a.kt)("inlineCode",{parentName:"p"},'-bs-D MY_VAR="bla"'),":"),(0,a.kt)("pre",null,(0,a.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-sh"}),'> bsc.exe -bs-D MY_VAR="bla" -bs-list-conditionals\nOCAML_PATCH "BS"\nBS_VERSION "1.2.1"\nOS_TYPE "Unix"\nBS true\nMY_VAR="bla"\n...\n')),(0,a.kt)("h2",{id:"concrete-syntax"},"Concrete Syntax"),(0,a.kt)("pre",null,(0,a.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-ocaml"}),"static-if\n| HASH-IF-BOL conditional-expression THEN //\n   tokens\n(HASH-ELIF-BOL conditional-expression THEN) *\n(ELSE-BOL tokens)?\nHASH-END-BOL\n\nconditional-expression\n| conditional-expression && conditional-expression\n| conditional-expression || conditional-expression\n| atom-predicate\n\natom-predicate\n| atom operator atom\n| defined UIDENT\n| undefined UIDENT\n\noperator\n| (= | < | > | <= | >= | =~ )\n\natom\n| UIDENT | INT | STRING | FLOAT\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"IF-BOL means ",(0,a.kt)("inlineCode",{parentName:"li"},"#IF")," should be in the beginning of a line.")),(0,a.kt)("h2",{id:"typing-rules"},"Typing Rules"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"type of INT is ",(0,a.kt)("inlineCode",{parentName:"li"},"int")),(0,a.kt)("li",{parentName:"ul"},"type of STRING is ",(0,a.kt)("inlineCode",{parentName:"li"},"string")),(0,a.kt)("li",{parentName:"ul"},"type of FLOAT is ",(0,a.kt)("inlineCode",{parentName:"li"},"float")),(0,a.kt)("li",{parentName:"ul"},"value of UIDENT comes from either built-in values (with documented types) or an environment variable, if it is literally ",(0,a.kt)("inlineCode",{parentName:"li"},"true"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"false")," then it is ",(0,a.kt)("inlineCode",{parentName:"li"},"bool"),", else if it is parsable by ",(0,a.kt)("inlineCode",{parentName:"li"},"Belt.Int.fromString")," then it is of type int, else if it is parsable by ",(0,a.kt)("inlineCode",{parentName:"li"},"Belt.Float.fromString")," then it is float, otherwise it would be string"),(0,a.kt)("li",{parentName:"ul"},"In ",(0,a.kt)("inlineCode",{parentName:"li"},"lhs operator rhs"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"lhs")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"rhs")," are always the same type and return boolean. ",(0,a.kt)("inlineCode",{parentName:"li"},"=~")," is a semantic version operator which requires both sides to be string.")),(0,a.kt)("p",null,"Evaluation rules are obvious. ",(0,a.kt)("inlineCode",{parentName:"p"},"=~")," respect semantic version, for example, the underlying engine"),(0,a.kt)("pre",null,(0,a.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-ocaml"}),'semver Location.none "1.2.3" "~1.3.0" = false;;\nsemver Location.none "1.2.3" "^1.3.0" = true ;;\nsemver Location.none "1.2.3" ">1.3.0" = false ;;\nsemver Location.none "1.2.3" ">=1.3.0" = false ;;\nsemver Location.none "1.2.3" "<1.3.0" = true ;;\nsemver Location.none "1.2.3" "<=1.3.0" = true ;;\nsemver Location.none "1.2.3" "1.2.3" = true;;\n')),(0,a.kt)("h2",{id:"tips--tricks"},"Tips & Tricks"),(0,a.kt)("p",null,"This is a very small extension to OCaml. It's backward compatible with OCaml except in the following case:"),(0,a.kt)("pre",null,(0,a.kt)("code",(0,r.Z)({parentName:"pre"},{className:"language-ocaml"}),"let f x =\n  x\n#elif //\n")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"#elif")," at the beginning of a line is interpreted as static ",(0,a.kt)("inlineCode",{parentName:"p"},"if"),". there is no issue with ",(0,a.kt)("inlineCode",{parentName:"p"},"#if")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"#end"),", since they are already keywords."))}s.isMDXComponent=!0,s.frontmatter={__ghEditHref:"https://github.com/reason-association/rescript-lang.org/blob/master/pages/docs/reason-compiler/latest/conditional-compilation.mdx"}},61246:function(e,n,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/docs/reason-compiler/latest/conditional-compilation",function(){return t(12746)}])}},function(e){e.O(0,[49774],(function(){return n=61246,e(e.s=n);var n}));var n=e.O();_N_E=n}]);