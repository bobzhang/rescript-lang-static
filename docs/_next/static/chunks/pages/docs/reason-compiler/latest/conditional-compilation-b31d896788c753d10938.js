(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[73237],{17375:function(e,n,t){"use strict";function i(e,n){if(null==e)return{};var t,i,o=function(e,n){if(null==e)return{};var t,i,o={},a=Object.keys(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}t.d(n,{Z:function(){return i}})},12746:function(e,n,t){"use strict";t.r(n),t.d(n,{default:function(){return p}});var i=t(96156),o=t(17375),a=(t(67294),t(3905));function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){(0,i.Z)(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}var s={};function p(e){var n=e.components,t=(0,o.Z)(e,["components"]);return(0,a.kt)("wrapper",l(l(l({},s),t),{},{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",l({},{id:"conditional-compilation"}),"Conditional Compilation"),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"This only works with the old OCaml syntax.")),(0,a.kt)("p",null,"Sometimes you want to write code that works with different versions of compilers and libraries."),(0,a.kt)("p",null,"People used to use preprocessors like ",(0,a.kt)("a",l({parentName:"p"},{href:"http://tigcc.ticalc.org/doc/cpp.html"}),"C preprocessor")," for the C family languages. The OCaml community uses several preprocessors: ",(0,a.kt)("a",l({parentName:"p"},{href:"https://github.com/mjambon/cppo"}),"cppo"),", ",(0,a.kt)("a",l({parentName:"p"},{href:"https://github.com/OCamlPro/typerex-build/tree/master/tools/ocp-pp"}),"ocp-pp"),", camlp4 IFDEF macros, ",(0,a.kt)("a",l({parentName:"p"},{href:"https://github.com/diml/optcomp"}),"optcomp")," and ",(0,a.kt)("a",l({parentName:"p"},{href:"https://github.com/janestreet/ppx_optcomp"}),"ppx optcomp"),"."),(0,a.kt)("p",null,"Instead of a preprocessor, ReScript adds language-level static ",(0,a.kt)("inlineCode",{parentName:"p"},"if")," compilation. It's less powerful than other preprocessors since it only supports static ",(0,a.kt)("inlineCode",{parentName:"p"},"if")," (no ",(0,a.kt)("inlineCode",{parentName:"p"},"#define"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"#undefine"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"#include"),"), but there are several advantages."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"It\u2019s tiny (only ~500 lines) and highly efficient. Everything can be done in a ",(0,a.kt)("strong",{parentName:"li"},"single pass"),". It's easy to rebuild the pre-processor into a standalone file, with no dependencies on compiler libs, to back-port it to old OCaml compilers."),(0,a.kt)("li",{parentName:"ul"},"It\u2019s purely functional and type-safe, and cooperates with editor tooling like Merlin.")),(0,a.kt)("h2",l({},{id:"usage"}),"Usage"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"lwt_unix.mli")),(0,a.kt)("pre",null,(0,a.kt)("code",l({parentName:"pre"},{className:"language-ocaml"}),'type open_flag =\n    Unix.open_flag =\n  | O_RDONLY\n  | O_WRONLY\n  | O_RDWR\n  | O_NONBLOCK\n  | O_APPEND\n  | O_CREAT\n  | O_TRUNC\n  | O_EXCL\n  | O_NOCTTY\n  | O_DSYNC\n  | O_SYNC\n  | O_RSYNC\n#if OCAML_VERSION =~ ">=3.13" then\n  | O_SHARE_DELETE\n#end\n#if OCAML_VERSION =~ ">=4.01" then\n  | O_CLOEXEC\n#end\n')),(0,a.kt)("p",null,"You don't have to add anything to the build to have these work. The compiler ",(0,a.kt)("inlineCode",{parentName:"p"},"bsc")," understands these already."),(0,a.kt)("h2",l({},{id:"built-in--custom-variables"}),"Built-in & Custom Variables"),(0,a.kt)("p",null,"See the output of ",(0,a.kt)("inlineCode",{parentName:"p"},"bsc.exe -bs-list-conditionals"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",l({parentName:"pre"},{className:"language-sh"}),'> bsc.exe -bs-D CUSTOM_A="ghsigh" -bs-list-conditionals\nOCAML_PATCH "BS"\nBS_VERSION "1.2.1"\nOS_TYPE "Unix"\nBS true\nCUSTOM_A "ghsigh"\nWORD_SIZE 64\nOCAML_VERSION "4.02.3+BS"\nBIG_ENDIAN false\n')),(0,a.kt)("p",null,"Add your custom variable to the mix with ",(0,a.kt)("inlineCode",{parentName:"p"},'-bs-D MY_VAR="bla"'),":"),(0,a.kt)("pre",null,(0,a.kt)("code",l({parentName:"pre"},{className:"language-sh"}),'> bsc.exe -bs-D MY_VAR="bla" -bs-list-conditionals\nOCAML_PATCH "BS"\nBS_VERSION "1.2.1"\nOS_TYPE "Unix"\nBS true\nMY_VAR="bla"\n...\n')),(0,a.kt)("h2",l({},{id:"concrete-syntax"}),"Concrete Syntax"),(0,a.kt)("pre",null,(0,a.kt)("code",l({parentName:"pre"},{className:"language-ocaml"}),"static-if\n| HASH-IF-BOL conditional-expression THEN //\n   tokens\n(HASH-ELIF-BOL conditional-expression THEN) *\n(ELSE-BOL tokens)?\nHASH-END-BOL\n\nconditional-expression\n| conditional-expression && conditional-expression\n| conditional-expression || conditional-expression\n| atom-predicate\n\natom-predicate\n| atom operator atom\n| defined UIDENT\n| undefined UIDENT\n\noperator\n| (= | < | > | <= | >= | =~ )\n\natom\n| UIDENT | INT | STRING | FLOAT\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"IF-BOL means ",(0,a.kt)("inlineCode",{parentName:"li"},"#IF")," should be in the beginning of a line.")),(0,a.kt)("h2",l({},{id:"typing-rules"}),"Typing Rules"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"type of INT is ",(0,a.kt)("inlineCode",{parentName:"li"},"int")),(0,a.kt)("li",{parentName:"ul"},"type of STRING is ",(0,a.kt)("inlineCode",{parentName:"li"},"string")),(0,a.kt)("li",{parentName:"ul"},"type of FLOAT is ",(0,a.kt)("inlineCode",{parentName:"li"},"float")),(0,a.kt)("li",{parentName:"ul"},"value of UIDENT comes from either built-in values (with documented types) or an environment variable, if it is literally ",(0,a.kt)("inlineCode",{parentName:"li"},"true"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"false")," then it is ",(0,a.kt)("inlineCode",{parentName:"li"},"bool"),", else if it is parsable by ",(0,a.kt)("inlineCode",{parentName:"li"},"Belt.Int.fromString")," then it is of type int, else if it is parsable by ",(0,a.kt)("inlineCode",{parentName:"li"},"Belt.Float.fromString")," then it is float, otherwise it would be string"),(0,a.kt)("li",{parentName:"ul"},"In ",(0,a.kt)("inlineCode",{parentName:"li"},"lhs operator rhs"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"lhs")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"rhs")," are always the same type and return boolean. ",(0,a.kt)("inlineCode",{parentName:"li"},"=~")," is a semantic version operator which requires both sides to be string.")),(0,a.kt)("p",null,"Evaluation rules are obvious. ",(0,a.kt)("inlineCode",{parentName:"p"},"=~")," respect semantic version, for example, the underlying engine"),(0,a.kt)("pre",null,(0,a.kt)("code",l({parentName:"pre"},{className:"language-ocaml"}),'semver Location.none "1.2.3" "~1.3.0" = false;;\nsemver Location.none "1.2.3" "^1.3.0" = true ;;\nsemver Location.none "1.2.3" ">1.3.0" = false ;;\nsemver Location.none "1.2.3" ">=1.3.0" = false ;;\nsemver Location.none "1.2.3" "<1.3.0" = true ;;\nsemver Location.none "1.2.3" "<=1.3.0" = true ;;\nsemver Location.none "1.2.3" "1.2.3" = true;;\n')),(0,a.kt)("h2",l({},{id:"tips--tricks"}),"Tips & Tricks"),(0,a.kt)("p",null,"This is a very small extension to OCaml. It's backward compatible with OCaml except in the following case:"),(0,a.kt)("pre",null,(0,a.kt)("code",l({parentName:"pre"},{className:"language-ocaml"}),"let f x =\n  x\n#elif //\n")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"#elif")," at the beginning of a line is interpreted as static ",(0,a.kt)("inlineCode",{parentName:"p"},"if"),". there is no issue with ",(0,a.kt)("inlineCode",{parentName:"p"},"#if")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"#end"),", since they are already keywords."))}p.isMDXComponent=!0,p.frontmatter={__ghEditHref:"https://github.com/reason-association/rescript-lang.org/blob/master/pages/docs/reason-compiler/latest/conditional-compilation.mdx"}},61246:function(e,n,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/docs/reason-compiler/latest/conditional-compilation",function(){return t(12746)}])}},function(e){e.O(0,[92888,49774,40179],(function(){return n=61246,e(e.s=n);var n}));var n=e.O();_N_E=n}]);