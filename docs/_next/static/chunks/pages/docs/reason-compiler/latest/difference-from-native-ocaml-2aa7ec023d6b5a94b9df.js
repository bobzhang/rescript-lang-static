(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[82329],{17375:function(e,t,n){"use strict";function i(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}n.d(t,{Z:function(){return i}})},52924:function(e,t,n){"use strict";n.r(t),n.d(t,{default:function(){return p}});var i=n(96156),a=n(17375),r=(n(67294),n(3905));function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){(0,i.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var s={};function p(e){var t=e.components,n=(0,a.Z)(e,["components"]);return(0,r.kt)("wrapper",o(o(o({},s),n),{},{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",o({},{id:"difference-from-native-ocaml"}),"Difference from Native OCaml"),(0,r.kt)("p",null,"This is particularly important when porting an existing OCaml application to JavaScript."),(0,r.kt)("h2",o({},{id:"custom-data-type"}),"Custom Data Type"),(0,r.kt)("p",null,"In OCaml, the C FFI allows the user to define a custom data type and customize ",(0,r.kt)("inlineCode",{parentName:"p"},"caml_compare"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"caml_hash")," behavior, etc. This is not available in our backend (since we have no C FFI)."),(0,r.kt)("h2",o({},{id:"physical-inequality"}),"Physical (in)equality"),(0,r.kt)("p",null,"In general, only use physical equality as an optimization technique; don't rely on its correctness, since it is tightly coupled with the runtime."),(0,r.kt)("h2",o({},{id:"string-char-range"}),"String Char Range"),(0,r.kt)("p",null,"Currently, BuckleScript assumes that the char range is 0-255. The user should be careful when they pass a JavaScript string to the OCaml side. We are working on a solution for this problem."),(0,r.kt)("h2",o({},{id:"weak-map"}),"Weak Map"),(0,r.kt)("p",null,"OCaml\u2019s weak map is not available in BuckleScript. The weak pointer is replaced by a strict pointer."),(0,r.kt)("h2",o({},{id:"integers"}),"Integers"),(0,r.kt)("p",null,"OCaml has ",(0,r.kt)("inlineCode",{parentName:"p"},"int"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"int32"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"nativeint")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"int64")," types."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Both ",(0,r.kt)("inlineCode",{parentName:"li"},"int32")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"int64")," in BuckleScript have the exact same semantics as OCaml."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"int")," in BuckleScript is the same as ",(0,r.kt)("inlineCode",{parentName:"li"},"int32")," while in OCaml it\u2019s platform dependent."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"nativeint")," is treated as JavaScript float, except for division. For example, ",(0,r.kt)("inlineCode",{parentName:"li"},"Nativeint.div a b")," will be translated into ",(0,r.kt)("inlineCode",{parentName:"li"},"a / b | 0"),".")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Note"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"Nativeint.shift_right_logical x 0")," is different from ",(0,r.kt)("inlineCode",{parentName:"p"},"Int32.shift_right_local x 0"),". The former is literally translated into ",(0,r.kt)("inlineCode",{parentName:"p"},"x >>> 0")," (translated into an unsigned int), while the latter is ",(0,r.kt)("inlineCode",{parentName:"p"},"x | 0"),"."),(0,r.kt)("h2",o({},{id:"printfprintf"}),"Printf.printf"),(0,r.kt)("p",null,"The Printf.print implementation in BuckleScript requires a newline (",(0,r.kt)("inlineCode",{parentName:"p"},"\\n"),") to trigger the printing. This behavior is not consistent with the buffered behavior of native OCaml. The only potential problem we foresee is that if the program terminates with no newline character, the text will never be printed."),(0,r.kt)("h2",o({},{id:"obj-module"}),"Obj Module"),(0,r.kt)("p",null,"We do our best to mimic the native compiler, but we have no guarantee and there are differences."),(0,r.kt)("h2",o({},{id:"hashtbl-hash-algorithm"}),"Hashtbl Hash Algorithm"),(0,r.kt)("p",null,"BuckleScript uses the same algorithm as native OCaml, but the output is different due to the runtime representation of int/int64/int32 and float."),(0,r.kt)("h2",o({},{id:"marshall-module"}),"Marshall Module"),(0,r.kt)("p",null,"Not supported yet."),(0,r.kt)("h2",o({},{id:"str-module"}),"Str Module"),(0,r.kt)("p",null,(0,r.kt)("a",o({parentName:"p"},{href:"https://github.com/BuckleScript/bucklescript/issues/879"}),"Not supported")," as it is implemented in C, which is not portable to BuckleScript. Use the ",(0,r.kt)("a",o({parentName:"p"},{href:"/docs/manual/latest/api/js/string"}),(0,r.kt)("inlineCode",{parentName:"a"},"Js.String"))," module instead which has bindings to the JavaScript ",(0,r.kt)("a",o({parentName:"p"},{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"}),(0,r.kt)("inlineCode",{parentName:"a"},"String"))," class."),(0,r.kt)("h2",o({},{id:"sysargv-sysmax_array_length-sysmax_string_length"}),"Sys.argv, Sys.max_array_length, Sys.max_string_length"),(0,r.kt)("p",null,"Command line arguments are always empty. This might be fixed in the future. ",(0,r.kt)("inlineCode",{parentName:"p"},"Sys.max_array_length")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Sys.max_string_length")," will be the same as ",(0,r.kt)("inlineCode",{parentName:"p"},"max_int"),", but it might be respected."),(0,r.kt)("h2",o({},{id:"unsupported-io-primitives"}),"Unsupported IO Primitives"),(0,r.kt)("p",null,"Because of the JS environment limitation, ",(0,r.kt)("inlineCode",{parentName:"p"},"Pervasives.stdin")," is not supported but both ",(0,r.kt)("inlineCode",{parentName:"p"},"Pervasives.stdout")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Pervasives.stderr")," are."))}p.isMDXComponent=!0,p.frontmatter={__ghEditHref:"https://github.com/reason-association/rescript-lang.org/blob/master/pages/docs/reason-compiler/latest/difference-from-native-ocaml.mdx"}},60873:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/docs/reason-compiler/latest/difference-from-native-ocaml",function(){return n(52924)}])}},function(e){e.O(0,[92888,49774,40179],(function(){return t=60873,e(e.s=t);var t}));var t=e.O();_N_E=t}]);