(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[80681],{17375:function(e,t,n){"use strict";function r(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}n.d(t,{Z:function(){return r}})},87144:function(e,t,n){"use strict";n.r(t),n.d(t,{default:function(){return s}});var r=n(96156),i=n(17375),o=(n(67294),n(3905));function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){(0,r.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var p={};function s(e){var t=e.components,n=(0,i.Z)(e,["components"]);return(0,o.kt)("wrapper",l(l(l({},p),n),{},{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",l({},{id:"automatic-interface-generation"}),"Automatic Interface Generation"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Note: this feature currently does not work for new projects!")),(0,o.kt)("p",null,'"Interface files" (',(0,o.kt)("inlineCode",{parentName:"p"},".resi"),' files) are the "public description" of their corresponding "implementation files" (',(0,o.kt)("inlineCode",{parentName:"p"},".ml"),", ",(0,o.kt)("inlineCode",{parentName:"p"},".re"),"), exposed as documentation, and containing nothing but type declarations. Since a file is a module, an interface file is essentially a ",(0,o.kt)("a",l({parentName:"p"},{href:"https://reasonml.github.io/docs/en/module.html#signatures"}),"module signature"),"."),(0,o.kt)("h2",l({},{id:"tips--tricks"}),"Tips & Tricks"),(0,o.kt)("p",null,"You don't have to explicitly write an interface file; by default, one will be inferred from the implementation file (just like how a module's type can be inferred when you hover over it) and ",(0,o.kt)("strong",{parentName:"p"},"every binding from the file will be exported"),". We do encourage that, after you finish iterating on your project:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Explicitly add interface files to the files meant to be public"),(0,o.kt)("li",{parentName:"ul"},"Add docblock comments on top of each binding to serve as documentation"),(0,o.kt)("li",{parentName:"ul"},"Make some types abstract, and simply don't expose every binding from the interface file")),(0,o.kt)("p",null,"Some types will have to be copy pasted from the implementation file, which gets tedious. This is why we let you ",(0,o.kt)("strong",{parentName:"p"},"automatically generate interface files"),", after which you can tweak whatever you want."),(0,o.kt)("p",null,"For a file ",(0,o.kt)("inlineCode",{parentName:"p"},"src/MyUtils.ml"),", run:"),(0,o.kt)("pre",null,(0,o.kt)("code",l({parentName:"pre"},{className:"language-sh"}),"bsc lib/bs/src/MyUtils-MyProject.cmi\n")),(0,o.kt)("p",null,"Where ",(0,o.kt)("inlineCode",{parentName:"p"},"MyProject")," is your project's namespace. If it's not enabled, it'll be just ",(0,o.kt)("inlineCode",{parentName:"p"},"MyUtils.cmi"),"). ",(0,o.kt)("inlineCode",{parentName:"p"},".cmi")," is the ReScript file that contains some ",(0,o.kt)("a",l({parentName:"p"},{href:"https://reasonml.github.io/community/faq#compiled-files"}),"compiled type info"),"."),(0,o.kt)("p",null,"The above command outputs a boilerplate ",(0,o.kt)("inlineCode",{parentName:"p"},".mli")," interface to stdout (old ml syntax)."),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"If you don't have ",(0,o.kt)("inlineCode",{parentName:"em"},"bsc")," globally available, use the ones provided locally in ",(0,o.kt)("inlineCode",{parentName:"em"},"node_modules/bs-platform/lib/bsc.exe")),"."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Note"),": the generated boilerplate might contain the strings ",(0,o.kt)("inlineCode",{parentName:"p"},'"BS-EXTERNAL"')," or ",(0,o.kt)("inlineCode",{parentName:"p"},'"ReScript External"'),". This happens when you've used ",(0,o.kt)("inlineCode",{parentName:"p"},"@bs")," externals in your implementation file. It's a temporary flaw; you need to manually turn these ",(0,o.kt)("inlineCode",{parentName:"p"},'"BS-EXTERNAL"')," back into the right ",(0,o.kt)("inlineCode",{parentName:"p"},"@bs")," externals for now. We'll correct this in the future."))}s.isMDXComponent=!0,s.frontmatter={__ghEditHref:"https://github.com/reason-association/rescript-lang.org/blob/master/pages/docs/reason-compiler/latest/automatic-interface-generation.mdx"}},61762:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/docs/reason-compiler/latest/automatic-interface-generation",function(){return n(87144)}])}},function(e){e.O(0,[92888,49774,40179],(function(){return t=61762,e(e.s=t);var t}));var t=e.O();_N_E=t}]);