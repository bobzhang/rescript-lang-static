(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[18561],{17375:function(e,t,n){"use strict";function r(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}n.d(t,{Z:function(){return r}})},37935:function(e,t,n){"use strict";n.r(t),n.d(t,{default:function(){return p}});var r=n(96156),a=n(17375),o=(n(67294),n(3905));function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){(0,r.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var l={};function p(e){var t=e.components,n=(0,a.Z)(e,["components"]);return(0,o.kt)("wrapper",i(i(i({},l),n),{},{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",i({},{id:"interop-miscellaneous"}),"Interop Miscellaneous"),(0,o.kt)("h2",i({},{id:"composing-bs-attributes"}),"Composing ",(0,o.kt)("inlineCode",{parentName:"h2"},"bs")," Attributes"),(0,o.kt)("p",null,"As you might have guessed, most ",(0,o.kt)("inlineCode",{parentName:"p"},"bs.*")," attributes can be used together. Here's an extreme example:"),(0,o.kt)("p",null,"Note that ",(0,o.kt)("inlineCode",{parentName:"p"},"bs.splice")," was renamed to ",(0,o.kt)("inlineCode",{parentName:"p"},"bs.variadic")," after version 4.08"),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-reason"}),'[@bs.val] [@bs.scope "global"] [@bs.variadic]\nexternal draw : ([@bs.as "dog"] _, array(int)) => unit = "draw";\n\ndraw([|1, 2|]);\n')),(0,o.kt)("p",null,"Output:"),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-js"}),'global.draw("dog", 1, 2);\n')),(0,o.kt)("h2",i({},{id:"safe-external-data-handling"}),"Safe External Data Handling"),(0,o.kt)("p",null,"In some cases, the data could either come from JS or BS; it's very hard to give precise type information because of this. For example, for an external promise whose creation could come from the JS API, its failed value caused by ",(0,o.kt)("inlineCode",{parentName:"p"},"Promise.reject")," could be of any shape."),(0,o.kt)("p",null,"BuckleScript provides a solution, ",(0,o.kt)("inlineCode",{parentName:"p"},"bs.open"),", to filter out OCaml structured exception data from the mixed data source. It preserves type safety while allowing you to deal with mixed source. It makes use of OCaml\u2019s extensible variant, so that users can mix values of type ",(0,o.kt)("inlineCode",{parentName:"p"},"exn")," with JS data."),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-reason"}),"let handleData = [@bs.open] (\n  fun\n  | Invalid_argument(_) => 0\n  | Not_found => 1\n  | Sys_error(_) => 2\n);\n\n/* handleData is 'a => option(int) */\n")),(0,o.kt)("p",null,"For any input source, as long as it matches the exception pattern (nested pattern match supported), the matched value is returned, otherwise return ",(0,o.kt)("inlineCode",{parentName:"p"},"None"),"."))}p.isMDXComponent=!0,p.frontmatter={__ghEditHref:"https://github.com/reason-association/rescript-lang.org/blob/master/pages/docs/reason-compiler/latest/interop-misc.mdx"}},76307:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/docs/reason-compiler/latest/interop-misc",function(){return n(37935)}])}},function(e){e.O(0,[92888,49774,40179],(function(){return t=76307,e(e.s=t);var t}));var t=e.O();_N_E=t}]);