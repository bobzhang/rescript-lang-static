(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[94744],{17375:function(e,t,n){"use strict";function r(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}n.d(t,{Z:function(){return r}})},90927:function(e,t,n){"use strict";n.d(t,{Z:function(){return i}});var r=n(67294);var i=function(e){var t=e.src,n=e.withShadow,i=e.caption,a=void 0!==n&&n?"shadow-md":"";return r.createElement("div",{className:"mt-8 mb-12 md:-mx-16"},r.createElement("a",{href:t,rel:"noopener noreferrer",target:"_blank"},r.createElement("img",{className:"w-full "+a,src:t})),void 0!==i?r.createElement("div",{className:"mt-4 text-14 text-gray-60 md:ml-16"},i):null)}},55817:function(e,t,n){"use strict";n.r(t),n.d(t,{default:function(){return d}});var r=n(96156),i=n(17375),a=(n(67294),n(3905)),o=n(90927);function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){(0,r.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var u={};function d(e){var t=e.components,n=(0,i.Z)(e,["components"]);return(0,a.kt)("wrapper",s(s(s({},u),n),{},{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",s({},{id:"build-performance"}),"Build Performance"),(0,a.kt)("p",null,"ReScript considers performance at install time, build time and run time as a serious feature. Here are some more info, and tips on keeping the build fast. ",(0,a.kt)("strong",{parentName:"p"},"Feel free to skip this section")," if you're just starting out."),(0,a.kt)("h2",s({},{id:"profile-your-build"}),"Profile Your Build"),(0,a.kt)("p",null,"Sometime your build can be slow due to some confused infra setups. We provide an interactive visualization of your build's performance via ",(0,a.kt)("inlineCode",{parentName:"p"},"bstracing"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",s({parentName:"pre"},{className:"language-sh"}),"./node_modules/.bin/bstracing\n")),(0,a.kt)("p",null,"Run the above command at your ReScript project's root; it'll spit out a JSON file you can drag and drop into ",(0,a.kt)("inlineCode",{parentName:"p"},"chrome://tracing"),"."),(0,a.kt)(o.Z,{withShadow:!0,src:"/static/img/bstracing.png",caption:"Screenshot of bstracing result",mdxType:"Image"}),(0,a.kt)("h2",s({},{id:"under-the-hood"}),"Under the Hood"),(0,a.kt)("p",null,"Bsb itself uses a build system under the hood, called ",(0,a.kt)("a",s({parentName:"p"},{href:"https://ninja-build.org"}),"Ninja"),". Ninja is like Make, but cross-platform, minimal, focuses in perf and destined to be more of a low-level building block than a full-blown build system. In this regard, Ninja's a great implementation detail for bsb."),(0,a.kt)("p",null,"Bsb reads into ",(0,a.kt)("inlineCode",{parentName:"p"},"bsconfig.json")," and generates the Ninja build file in ",(0,a.kt)("inlineCode",{parentName:"p"},"lib/bs"),". The file contains the low-level ",(0,a.kt)("inlineCode",{parentName:"p"},"bsc"),"-related commands, namespacing rules, intermediate artifacts generation & others. It then runs ",(0,a.kt)("inlineCode",{parentName:"p"},"ninja")," for the actual build."),(0,a.kt)("h2",s({},{id:"the-js-wrapper"}),"The JS Wrapper"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"bsb")," itself is a Node.js wrapper which takes care of some miscellaneous tasks, plus the watcher. The lower-level, watcher-less, true ",(0,a.kt)("inlineCode",{parentName:"p"},"bsb")," is called ",(0,a.kt)("inlineCode",{parentName:"p"},"bsb.exe"),". It can be located in the same directory as where ",(0,a.kt)("inlineCode",{parentName:"p"},"bsb")," is found:"),(0,a.kt)("pre",null,(0,a.kt)("code",s({parentName:"pre"},{className:"language-sh"}),"> bsb -where\n/usr/local/lib/node_modules/bs-platform/lib\n")),(0,a.kt)("p",null,"The path varies across systems."),(0,a.kt)("p",null,"If you don't need the watcher, you can run said ",(0,a.kt)("inlineCode",{parentName:"p"},"bsb.exe"),": ",(0,a.kt)("inlineCode",{parentName:"p"},"/usr/local/lib/node_modules/bs-platform/lib/bsb.exe"),". This side-steps the node.js startup time, which can be big (in the order of ",(0,a.kt)("inlineCode",{parentName:"p"},"100ms"),")."),(0,a.kt)("h2",s({},{id:"numbers"}),"Numbers"),(0,a.kt)("p",null,"Raw ",(0,a.kt)("inlineCode",{parentName:"p"},"bsb.exe")," build on a small project should be around ",(0,a.kt)("inlineCode",{parentName:"p"},"70ms"),". This doubles when you use the more common ",(0,a.kt)("inlineCode",{parentName:"p"},"bsb")," wrapper which comes with a watcher, which is practically faster since you don't manually run the build at every change (though you should opt for the raw ",(0,a.kt)("inlineCode",{parentName:"p"},"bsb.exe")," for programmatic usage, e.g. inserting bsb into your existing JS build pipeline)."),(0,a.kt)("p",null,"No-op build (when no file's changed) should be around ",(0,a.kt)("inlineCode",{parentName:"p"},"15ms"),". Incremental rebuild (described soon) of a single file in a project is around ",(0,a.kt)("inlineCode",{parentName:"p"},"70ms")," too."),(0,a.kt)("p",null,"Cleaning the artifacts should be instantaneous."),(0,a.kt)("h3",s({},{id:"extreme-test"}),"Extreme Test"),(0,a.kt)("p",null,"We've stress-tested bsb on a big project of 10,000 files (2 directories, 5000 files each, first 5000 no dependencies, last 5000 10 dependencies on files from the former directory) using ",(0,a.kt)("a",s({parentName:"p"},{href:"https://github.com/ocaml-omake/omake/blob/perf-test/performance/generate.ml"}),"https://github.com/ocaml-omake/omake/blob/perf-test/performance/generate.ml"),", on Retina Macbook Pro Early 2015 (3.1 GHz Intel Core i7)."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"No-op build of 10k files: ",(0,a.kt)("inlineCode",{parentName:"li"},"800ms")," (the minimum amount of time required to check the mtimes of 10k files)."),(0,a.kt)("li",{parentName:"ul"},"Clean build: <3 minutes."),(0,a.kt)("li",{parentName:"ul"},"Incremental build: depends on the number of the dependents of the file. No dependent means ",(0,a.kt)("inlineCode",{parentName:"li"},"1s"),".")),(0,a.kt)("p",null,"Note that bsb is a file-based build system. We don't do in-memory build, even if that speeds up the build a lot. In-memory builds risk memory leaks, out-of-memory errors and others. The bsb watcher, on the other hand, can stay open for days."),(0,a.kt)("h2",s({},{id:"incrementality"}),"Incrementality"),(0,a.kt)("p",null,"Bsb doesn't take whole seconds to run every time. The bulk of the build performance comes from incremental build, aka re-building a previously built project when a few files changed."),(0,a.kt)("p",null,"In short, thanks to our bsc compiler and bsb build system's architecture, we're able to ",(0,a.kt)("strong",{parentName:"p"},"only build what's needed"),". E.g. if ",(0,a.kt)("inlineCode",{parentName:"p"},"MyFile.res")," isn't changed, then it's not recompiled. You can roughly emulate such incrementality in languages like JavaScript, but the degree of correctness is unfortunately low. For example, if you rename or move a JS file, then the watcher might get confused and not pick up the \"new\" file or fail to clean things up correctly, resulting in you needing to clean your build and restart anew, which defeats the purpose."),(0,a.kt)("h2",s({},{id:"speed-up-incremental-build"}),"Speed Up Incremental Build"),(0,a.kt)("p",null,"ReScript uses the concept of interface files (",(0,a.kt)("inlineCode",{parentName:"p"},".rei"),") (or, equivalently, ",(0,a.kt)("a",s({parentName:"p"},{href:"module.md#signatures"}),"module signatures"),"). Exposing only what you need naturally speeds up incremental builds. E.g. if you change a ",(0,a.kt)("inlineCode",{parentName:"p"},".re")," file whose corresponding ",(0,a.kt)("inlineCode",{parentName:"p"},".rei")," file doesn't expose the changed part, then you've reduced the amount of dependent files you have to rebuild."),(0,a.kt)("h2",s({},{id:"programmatic-usage"}),"Programmatic Usage"),(0,a.kt)("p",null,"Unfortunately, JS build systems are usually the bottleneck for building a JS project nowadays. Having parts of the build blazingly fast doesn't matter much if the rest of the build takes seconds or literally minutes. Here are a few suggestions:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Convert more files into ReScript =). Fewer files going through fewer parts of the JS pipeline helps a ton."),(0,a.kt)("li",{parentName:"ul"},"Careful with bringing in more dependencies: libraries, syntax transforms, build step loaders, etc. The bulk of these dragging down the editing & building experience might out-weight the API benefits they provide."),(0,a.kt)("li",{parentName:"ul"},"Wait for us to create our own super fast linker (aka bundler).")),(0,a.kt)("h2",s({},{id:"hot-reloading"}),"Hot Reloading"),(0,a.kt)("p",null,"Hot reloading refers to maintaining a dev server and listening to file changes in a way that allows the server to pipe some delta changes right into the currently running browser page. This provides a relatively fast iteration workflow while working in specific frameworks."),(0,a.kt)("p",null,"However, hot reloading is fragile by nature, and counts on the occasional inconsistencies (bad state, bad eval, etc.) and the heavy devserver setup/config being less of a hassle than the benefits it provides. We err on the side of caution and stability in general, and decided not to provide a built-in hot reloading ",(0,a.kt)("em",{parentName:"p"},"yet"),". ",(0,a.kt)("strong",{parentName:"p"},"Note"),": you can still use the hot reloading facility provided by your JS build pipeline."))}d.isMDXComponent=!0,d.frontmatter={title:"Build Performance",description:"ReScript build performance and measuring tools",canonical:"/docs/manual/latest/build-performance",__ghEditHref:"https://github.com/reason-association/rescript-lang.org/blob/master/pages/docs/manual/v8.0.0/build-performance.mdx"}},29643:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/docs/manual/v8.0.0/build-performance",function(){return n(55817)}])}},function(e){e.O(0,[92888,49774,40179],(function(){return t=29643,e(e.s=t);var t}));var t=e.O();_N_E=t}]);