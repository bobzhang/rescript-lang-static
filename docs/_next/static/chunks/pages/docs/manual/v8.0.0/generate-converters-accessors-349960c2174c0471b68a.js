(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[32140],{17375:function(e,n,t){"use strict";function a(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}t.d(n,{Z:function(){return a}})},2072:function(e,n,t){"use strict";t.r(n),t.d(n,{default:function(){return d}});var a=t(17375),r=t(96156),o=(t(67294),t(3905));function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){(0,r.Z)(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}var l,p=(l="CodeTab",function(e){return console.warn("Component "+l+" was not imported, exported, or provided by MDXProvider as global scope"),(0,o.kt)("div",i({},e))}),c={};function d(e){var n=e.components,t=(0,a.Z)(e,["components"]);return(0,o.kt)("wrapper",i(i(i({},c),t),{},{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",i({},{id:"generate-converters--helpers"}),"Generate Converters & Helpers"),(0,o.kt)("p",null,"When using ReScript, you will sometimes come into situations where you want to"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Automatically generate functions that convert between ReScript's internal and JS runtime values (e.g. variants)."),(0,o.kt)("li",{parentName:"ul"},"Convert a record type into an abstract type with generated creation, accessor and method functions."),(0,o.kt)("li",{parentName:"ul"},"Generate some other helper functions, such as functions from record attribute names.")),(0,o.kt)("p",null,"You can use the ",(0,o.kt)("inlineCode",{parentName:"p"},"@bs.deriving")," decorator to trigger code generation. All different options and configurations will be discussed on this page."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Note:")," Please be aware that extensive use of code generation might make it harder to understand your programs (since the code being generated is not visible in the source code, and you just need to know what kind of functions / values a decorator generates)."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Another Note:")," Since ",(0,o.kt)("inlineCode",{parentName:"p"},"v8.3")," you can drop the ",(0,o.kt)("inlineCode",{parentName:"p"},"bs.")," prefix for all our decorators (e.g. ",(0,o.kt)("inlineCode",{parentName:"p"},"@bs.deriving")," => ",(0,o.kt)("inlineCode",{parentName:"p"},"@deriving"),")."),(0,o.kt)("h2",i({},{id:"generate-functions--plain-values-for-variants"}),"Generate Functions & Plain Values for Variants"),(0,o.kt)("p",null,"Use ",(0,o.kt)("inlineCode",{parentName:"p"},"[@bs.deriving accessors]")," on a variant type to create accessor functions for its constructors."),(0,o.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-reason"}),"[@bs.deriving accessors]\ntype action =\n  | Click\n  | Submit(string)\n  | Cancel;\n")),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-ocaml"}),"type action =\n  | Click\n  | Submit of string\n  | Cancel\n  [@@bs.deriving accessors]\n")),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-js"}),"function submit(param_0) {\n  return /* Submit */[param_0];\n}\n\nvar click = /* Click */0;\n\nvar cancel = /* Cancel */1;\n\nexports.click  = click;\nexports.submit = submit;\nexports.cancel = cancel;\n"))),(0,o.kt)("p",null,"Variants constructors with payloads generate functions, payload-less constructors generate plain integers (the internal representation of variants)."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Note"),":"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The generated accessors are lower-cased."),(0,o.kt)("li",{parentName:"ul"},"You can now use these helpers on the JavaScript side! But don't rely on their actual values please.")),(0,o.kt)("h3",i({},{id:"usage"}),"Usage"),(0,o.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-reason"}),'let s = submit("hello"); /* gives Submit("hello") */\n')),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-ocaml"}),'let s = submit "hello" (* gives Submit("hello") *)\n'))),(0,o.kt)("p",null,"This is useful:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"When you're passing the accessor function as a higher-order function (which plain variant constructors aren't)."),(0,o.kt)("li",{parentName:"ul"},"When you'd like the JS side to use these values & functions opaquely and pass you back a variant constructor (since JS has no such thing).")),(0,o.kt)("p",null,"Please note that in case you just want to ",(0,o.kt)("em",{parentName:"p"},"pipe a payload into a constructor"),", you don't need to generate functions for that. Use the ",(0,o.kt)("inlineCode",{parentName:"p"},"->")," syntax instead, e.g. ",(0,o.kt)("inlineCode",{parentName:"p"},'"test"->Submit'),"."),(0,o.kt)("h2",i({},{id:"generate-field-accessors-for-records"}),"Generate Field Accessors for Records"),(0,o.kt)("p",null,"Use ",(0,o.kt)("inlineCode",{parentName:"p"},"[@bs.deriving accessors]")," on a record type to create accessors for its record field names."),(0,o.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-reason"}),'[@bs.deriving accessors]\ntype pet = {\n  name: string,\n};\n\nlet pets = [|{name: "bob"}, {name: "bob2"}|];\n\npets\n  ->Belt.Array.map(name)\n  ->Js.Array2.joinWith("&")\n  ->Js.log;\n')),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-ocaml"}),'type pet = {\n  name: string;\n}[@@bs.deriving accessors]\n\nlet pets = [|{ name = ("bob") }; { name = ("bob2") }|]\n\nlet _ =\n  ((((pets |. Belt.Array.map) name) |. Js.Array2.joinWith)\n     ("&"))\n    |. Js.log\n')),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-js"}),'function name(param) {\n  return param.name;\n}\n\nvar pets = [\n  {\n    name: "bob"\n  },\n  {\n    name: "bob2"\n  }\n];\n\nconsole.log(Belt_Array.map(pets, name).join("&"));\n'))),(0,o.kt)("h2",i({},{id:"generate-converters-for-js-object-and-record"}),"Generate Converters for JS Object and Record"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"Note:")," In ReScript >= v7 ",(0,o.kt)("a",i({parentName:"p"},{href:"bind-to-js-object#bind-to-record-like-js-objects"}),"records are already compiled to JS\nobjects"),". ",(0,o.kt)("inlineCode",{parentName:"p"},"[@bs.deriving jsConverter]")," is therefore\nobsolete and will generate a no-op function for compatibility instead.")),(0,o.kt)("p",null,"Use ",(0,o.kt)("inlineCode",{parentName:"p"},"[@bs.deriving jsConverter]")," on a record type to create convertion functions between records / JS object runtime values."),(0,o.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-reason"}),"[@bs.deriving jsConverter]\ntype coordinates = {\n  x: int,\n  y: int\n};\n")),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-ocaml"}),"type coordinates = {\n  x: int;\n  y: int;\n}[@@bs.deriving jsConverter]\n"))),(0,o.kt)("p",null,"Generates 2 functions of the following types:"),(0,o.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-reason"}),'let coordinatesToJs: coordinates => {. "x": int, "y": int};\n\nlet coordinatesFromJs: {.. "x": int, "y": int} => coordinates;\n')),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-ocaml"}),"val coordinatesToJs : coordinates -> < x: int; y: int>  Js.t\n\nval coordinatesFromJs : < x: int; y: int ; .. >  Js.t -> coordinates\n"))),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Note"),":"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"coordinatesFromJs")," uses an open object type that accepts more fields, just to be more permissive."),(0,o.kt)("li",{parentName:"ul"},"The converters are shallow. They don't recursively drill into the fields and convert them. This preserves the speed and simplicity of output while satisfying 80% of use-cases.")),(0,o.kt)("h3",i({},{id:"usage-1"}),"Usage"),(0,o.kt)("p",null,"This exports a ",(0,o.kt)("inlineCode",{parentName:"p"},"jsCoordinates")," JS object (not a record!) for JS files to use:"),(0,o.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-reason"}),"let jsCoordinates = coordinatesToJs({x: 1, y: 2});\n")),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-ocaml"}),"let jsCoordinates = coordinatesToJs { x = 1; y = 2 }\n"))),(0,o.kt)("p",null,"This binds to a ",(0,o.kt)("inlineCode",{parentName:"p"},"jsCoordinates")," record (not a JS object!) that exists on the JS side, presumably created by JS calling the function ",(0,o.kt)("inlineCode",{parentName:"p"},"coordinatesFromJs"),":"),(0,o.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-reason"}),'[@bs.module "myGame"] external jsCoordinates : coordinates = "jsCoordinates";\n')),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-ocaml"}),'external jsCoordinates : coordinates = "jsCoordinates"[@@bs.module "myGame"]\n'))),(0,o.kt)("h3",i({},{id:"more-safety"}),"More Safety"),(0,o.kt)("p",null,"The above generated functions use ",(0,o.kt)("inlineCode",{parentName:"p"},"Js.t")," object types. You can also hide this implementation detail by making the object type ",(0,o.kt)("strong",{parentName:"p"},"abstract")," by using the ",(0,o.kt)("inlineCode",{parentName:"p"},"newType")," option with ",(0,o.kt)("inlineCode",{parentName:"p"},"[@bs.deriving jsConverter]"),":"),(0,o.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-reason"}),"[@bs.deriving {jsConverter: newType}]\ntype coordinates = {\n  x: int,\n  y: int\n};\n")),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-ocaml"}),"type coordinates = {\n  x: int ;\n  y: int\n} [@@bs.deriving { jsConverter = newType }]\n"))),(0,o.kt)("p",null,"Generates 2 functions of the following types:"),(0,o.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-reason"}),"let coordinatesToJs: coordinates => abs_coordinates;\n\nlet coordinatesFromJs: abs_coordinates => coordinates;\n")),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-ocaml"}),"val coordinatesToJs : coordinates -> abs_coordinates\n\nval coordinatesFromJs : abs_coordinates -> coordinates\n"))),(0,o.kt)("h4",i({},{id:"usage-2"}),"Usage"),(0,o.kt)("p",null,"Using ",(0,o.kt)("inlineCode",{parentName:"p"},"newType"),", you've now prevented consumers from inadvertently doing the following:"),(0,o.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-reason"}),"let myCoordinates = {\n  x: 10,\n  y: 20\n};\nlet jsCoords = coordinatesToJs(myCoordinates);\n\nlet x = jsCoords##x; /* disallowed! Don't access the object's internal details */\n")),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-ocaml"}),"let myCoordinates = {\n  x = 10;\n  y = 20\n}\n\nlet jsCoords = coordinatesToJs myCoordinates\n\nlet x = jsCoords ## x (* disallowed! Don't access the object's internal details *)\n"))),(0,o.kt)("p",null,"Same generated output. Isn't it great that types prevent invalid accesses you'd otherwise have to encode at runtime?"),(0,o.kt)("h2",i({},{id:"generate-converters-for-js-integer-enums-and-variants"}),"Generate Converters for JS Integer Enums and Variants"),(0,o.kt)("p",null,"Use ",(0,o.kt)("inlineCode",{parentName:"p"},"[@bs.deriving jsConverter]")," on a variant type to create converter functions that allow back and forth conversion between JS integer enum and ReScript variant values."),(0,o.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-reason"}),"[@bs.deriving jsConverter]\ntype fruit =\n  | Apple\n  | Orange\n  | Kiwi\n  | Watermelon;\n")),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-ocaml"}),"type fruit =\n  | Apple \n  | Orange \n  | Kiwi \n  | Watermelon [@@bs.deriving jsConverter]\n"))),(0,o.kt)("p",null,"This option causes ",(0,o.kt)("inlineCode",{parentName:"p"},"jsConverter")," to, again, generate functions of the following types:"),(0,o.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-reason"}),"let fruitToJs: fruit => int;\n\nlet fruitFromJs: int => option(fruit);\n")),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-ocaml"}),"val fruitToJs : fruit -> int\n\nval fruitFromJs : int -> fruit option\n"))),(0,o.kt)("p",null,"For ",(0,o.kt)("inlineCode",{parentName:"p"},"fruitToJs"),", each fruit variant constructor would map into an integer, starting at 0, in the order they're declared."),(0,o.kt)("p",null,"For ",(0,o.kt)("inlineCode",{parentName:"p"},"fruitFromJs"),", the return value is an ",(0,o.kt)("inlineCode",{parentName:"p"},"option"),", because not every int maps to a constructor."),(0,o.kt)("p",null,"You can also attach a ",(0,o.kt)("inlineCode",{parentName:"p"},"[@bs.as alternativeIntValue]")," to each constructor to customize their output."),(0,o.kt)("h3",i({},{id:"usage-3"}),"Usage"),(0,o.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-reason"}),'[@bs.deriving jsConverter]\ntype fruit =\n  | Apple\n  | [@bs.as 10] Orange\n  | [@bs.as 100] Kiwi\n  | Watermelon;\n\nlet zero = fruitToJs(Apple); /* 0 */\n\nswitch (fruitFromJs(100)) {\n| Some(Kiwi) => Js.log("this is Kiwi")\n| _ => Js.log("received something wrong from the JS side")\n};\n')),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-ocaml"}),'type fruit =\n  | Apple \n  | Orange [@bs.as 10]\n  | Kiwi [@bs.as 100]\n  | Watermelon [@@bs.deriving jsConverter]\n\nlet zero = fruitToJs Apple;;\n\nmatch fruitFromJs 100 with\n  | ((Some (Kiwi))[@explicit_arity ]) -> Js.log "this is Kiwi"\n  | _ -> Js.log "received something wrong from the JS side"\n'))),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Note"),": by using ",(0,o.kt)("inlineCode",{parentName:"p"},"bs.as")," here, all subsequent number encoding changes. ",(0,o.kt)("inlineCode",{parentName:"p"},"Apple")," is still ",(0,o.kt)("inlineCode",{parentName:"p"},"0"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"Orange")," is ",(0,o.kt)("inlineCode",{parentName:"p"},"10"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"Kiwi")," is ",(0,o.kt)("inlineCode",{parentName:"p"},"100")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Watermelon")," is ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("inlineCode",{parentName:"strong"},"101")),"!"),(0,o.kt)("h3",i({},{id:"more-safety-1"}),"More Safety"),(0,o.kt)("p",null,"Similar to the JS object <-> record deriving, you can hide the fact that the JS enum are ints by using the same ",(0,o.kt)("inlineCode",{parentName:"p"},"newType")," option with ",(0,o.kt)("inlineCode",{parentName:"p"},"[@bs.deriving jsConverter]"),":"),(0,o.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-reason"}),"[@bs.deriving {jsConverter: newType}]\ntype fruit =\n  | Apple\n  | [@bs.as 100] Kiwi\n  | Watermelon;\n")),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-ocaml"}),"type fruit =\n  | Apple \n  | Kiwi [@bs.as 100]\n  | Watermelon [@@bs.deriving { jsConverter = newType }]\n"))),(0,o.kt)("p",null,"This option causes ",(0,o.kt)("inlineCode",{parentName:"p"},"jsConverter")," to generate functions of the following types:"),(0,o.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-reason"}),"let fruitToJs: fruit => abs_fruit;\n\nlet fruitFromJs: abs_fruit => fruit;\n")),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-ocaml"}),"val fruitToJs : fruit -> abs_fruit\n\nval fruitFromJs : abs_fruit -> fruit\n"))),(0,o.kt)("p",null,"For ",(0,o.kt)("inlineCode",{parentName:"p"},"fruitFromJs"),", the return value, unlike the previous non-abstract type case, doesn't contain an ",(0,o.kt)("inlineCode",{parentName:"p"},"option"),", because there's no way a bad value can be passed into it; the only creator of ",(0,o.kt)("inlineCode",{parentName:"p"},"abs_fruit")," values is ",(0,o.kt)("inlineCode",{parentName:"p"},"fruitToJs"),"!"),(0,o.kt)("h4",i({},{id:"usage-4"}),"Usage"),(0,o.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-reason"}),'[@bs.deriving {jsConverter: newType}]\ntype fruit =\n  | Apple\n  | [@bs.as 100] Kiwi\n  | Watermelon;\n\nlet opaqueValue = fruitToJs(Apple);\n\n[@bs.module "myJSFruits"] external jsKiwi : abs_fruit = "iSwearThisIsAKiwi";\nlet kiwi = fruitFromJs(jsKiwi);\n\nlet error = fruitFromJs(100); /* nope, can\'t take a random int */\n')),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-ocaml"}),'type fruit =\n  | Apple \n  | Kiwi [@bs.as 100]\n  | Watermelon [@@bs.deriving { jsConverter = newType }]\n\nlet opaqueValue = fruitToJs Apple\n\nexternal jsKiwi : abs_fruit = "iSwearThisIsAKiwi"[@@bs.module "myJSFruits"]\n\nlet kiwi = fruitFromJs jsKiwi\nlet error = fruitFromJs 100\n'))),(0,o.kt)("h2",i({},{id:"generate-converters-for-js-string-enums-and-polymorphic-variants"}),"Generate Converters for JS String Enums and Polymorphic Variants"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"Note"),": Since ReScript 8.2, polymorphic variants are already compiled to strings, so this feature is getting deprecated at some point. It's currently still useful for aliasing JS output with ",(0,o.kt)("inlineCode",{parentName:"p"},"@bs.as"),".")),(0,o.kt)("p",null,"Similarly as with ",(0,o.kt)("a",i({parentName:"p"},{href:"#generate-converters-between-js-integer-enums-and-variants"}),"generating int converters"),", use ",(0,o.kt)("inlineCode",{parentName:"p"},"[@bs.deriving jsConverter]")," on a polymorphic variant type to create converter functions for JS string and ReScript poly variant values."),(0,o.kt)("h3",i({},{id:"usage-5"}),"Usage"),(0,o.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-reason"}),'[@bs.deriving jsConverter]\ntype fruit = [\n  | `Apple\n  | [@bs.as "miniCoconut"] `Kiwi\n  | `Watermelon\n];\n\nlet appleString = fruitToJs(`Apple); /* "Apple" */\nlet kiwiString = fruitToJs(`Kiwi); /* "miniCoconut" */\n')),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-ocaml"}),'type fruit = [\n  | `Apple \n  | `Kiwi [@bs.as "miniCoconut"]\n  | `Watermelon\n] [@@bs.deriving jsConverter]\n\nlet appleString = fruitToJs `Apple\nlet kiwiString = fruitToJs `Kiwi\n'))),(0,o.kt)("p",null,"You can also use ",(0,o.kt)("inlineCode",{parentName:"p"},"[@bs.deriving {jsConverter: newType}]")," to generate abstract types instead."),(0,o.kt)("h2",i({},{id:"convert-record-type-to-abstract-record"}),"Convert Record Type to Abstract Record"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"Note"),": For ReScript >= v7, we recommend using ",(0,o.kt)("a",i({parentName:"p"},{href:"bind-to-js-object#bind-to-record-like-js-objects"}),"plain records to compile to JS objects"),".\nThis feature might still be useful for certain scenarios, but the ergonomics might be worse ")),(0,o.kt)("p",null,"Use ",(0,o.kt)("inlineCode",{parentName:"p"},"[@bs.deriving abstract]")," on a record type to expand the type into a creation, and a set of getter / setter functions for fields and methods."),(0,o.kt)("p",null,"Usually you'd just use ReScript records to compile to JS objects of the same shape. There is still one particular use-case left where the ",(0,o.kt)("inlineCode",{parentName:"p"},"[@bs.deriving abstract]")," convertion is still useful: Whenever you need compile a record with an optional field where the JS object attribute shouldn't show up in the resulting JS when undefined (e.g. ",(0,o.kt)("inlineCode",{parentName:"p"},'{name: "Carl", age: undefined}')," vs ",(0,o.kt)("inlineCode",{parentName:"p"},'{name: "Carl"}'),"). Check the ",(0,o.kt)("a",i({parentName:"p"},{href:"#optional-labels"}),"Optional Labels")," section for more infos on this particular scenario."),(0,o.kt)("h3",i({},{id:"usage-example"}),"Usage Example"),(0,o.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-reason"}),'[@bs.deriving abstract]\ntype person = {\n  name: string,\n  age: int,\n  job: string,\n};\n\n[@bs.val] external john : person = "john";\n')),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-ocaml"}),'type person = {\n  name: string;\n  age: int;\n  job: string;\n} [@@bs.deriving abstract]\n\nexternal john : person = "john" [@@bs.val]\n'))),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Note"),": the ",(0,o.kt)("inlineCode",{parentName:"p"},"person")," type is ",(0,o.kt)("strong",{parentName:"p"},"not")," a record! It's a record-looking type that uses the record's syntax and type-checking. The ",(0,o.kt)("inlineCode",{parentName:"p"},"[@bs.deriving abstract]")," decorator turns it into an \"abstract type\" (aka you don't know what the actual value's shape)."),(0,o.kt)("h3",i({},{id:"creation"}),"Creation"),(0,o.kt)("p",null,"You don't have to bind to an existing ",(0,o.kt)("inlineCode",{parentName:"p"},"person")," object from the JS side. You can also create such ",(0,o.kt)("inlineCode",{parentName:"p"},"person")," JS object from ReScript's side."),(0,o.kt)("p",null,"Since ",(0,o.kt)("inlineCode",{parentName:"p"},"[@bs.deriving abstract]")," turns the above ",(0,o.kt)("inlineCode",{parentName:"p"},"person")," record into an abstract type, you can't directly create a person record as you would usually. This doesn't work: ",(0,o.kt)("inlineCode",{parentName:"p"},'{name: "Joe", age: 20, job: "teacher"}'),"."),(0,o.kt)("p",null,"Instead, you'd use the ",(0,o.kt)("strong",{parentName:"p"},"creation function")," of the same name as the record type, implicitly generated by the ",(0,o.kt)("inlineCode",{parentName:"p"},"[@bs.deriving abstract]")," annotation:"),(0,o.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-reason"}),'let joe = person(~name="Joe", ~age=20, ~job="teacher")\n')),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-ocaml"}),'let joe = person ~name:"Joe" ~age:20 ~job:"teacher"\n')),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-js"}),'var joe = {\n  name: "Joe",\n  age: 20,\n  job: "teacher"\n};\n'))),(0,o.kt)("p",null,"Note how in the example above there is no JS runtime overhead."),(0,o.kt)("h4",i({},{id:"rename-fields"}),"Rename Fields"),(0,o.kt)("p",null,"Sometimes you might be binding to a JS object with field names that are invalid in ReScript/Reason. Two examples would be ",(0,o.kt)("inlineCode",{parentName:"p"},'{type: "foo"}')," (reserved keyword in ReScript/Reason) and ",(0,o.kt)("inlineCode",{parentName:"p"},'{"aria-checked": true}'),". Choose a valid field name then use ",(0,o.kt)("inlineCode",{parentName:"p"},"[@bs.as]")," to circumvent this:"),(0,o.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-reason"}),'[@bs.deriving abstract]\ntype data = {\n  [@bs.as "type"] type_: string,\n  [@bs.as "aria-label"] ariaLabel: string,\n};\n\nlet d = data(~type_="message", ~ariaLabel="hello");\n')),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-ocaml"}),'type data = {\n  type_: string [@bs.as "type"];\n  ariaLabel: string [@bs.as "aria-label"];\n} [@@bs.deriving abstract]\n\nlet d = data ~type_:"message" ~ariaLabel:"hello"\n')),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-js"}),'var d = {\n  type: "message",\n  "aria-label": "hello"\n};\n'))),(0,o.kt)("h4",i({},{id:"optional-labels"}),"Optional Labels"),(0,o.kt)("p",null,"You can omit fields during the creation of the object:"),(0,o.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-reason"}),'[@bs.deriving abstract]\ntype person = {\n  [@bs.optional] name: string,\n  age: int,\n  job: string,\n};\n\nlet joe = person(~age=20, ~job="teacher", ());\n')),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-ocaml"}),'type person = {\n  name: string [@bs.optional];\n  age: int;\n  job: string;\n} [@@bs.deriving abstract]\n\nlet joe = person ~age:20 ~job:"teacher" ()\n')),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-js"}),'var joe = {\n  age: 20,\n  job: "teacher"\n};\n'))),(0,o.kt)("p",null,"Optional values that are not defined, will not show up as an attribute in the resulting JS object. In the example above, you will see that ",(0,o.kt)("inlineCode",{parentName:"p"},"name")," was omitted."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Note")," that the ",(0,o.kt)("inlineCode",{parentName:"p"},"[@bs.optional]")," tag turned the ",(0,o.kt)("inlineCode",{parentName:"p"},"name")," field optional. Merely typing ",(0,o.kt)("inlineCode",{parentName:"p"},"name")," as ",(0,o.kt)("inlineCode",{parentName:"p"},"option(string)")," wouldn't work."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Note"),": now that your creation function contains optional fields, we mandate an unlabeled ",(0,o.kt)("inlineCode",{parentName:"p"},"()")," at the end to indicate that ",(0,o.kt)("a",i({parentName:"p"},{href:"function#optional-labeled-arguments"}),"you've finished applying the function"),"."),(0,o.kt)("h3",i({},{id:"accessors"}),"Accessors"),(0,o.kt)("p",null,"Again, since ",(0,o.kt)("inlineCode",{parentName:"p"},"[@bs.deriving abstract]")," hides the actual record shape, you can't access a field using e.g. ",(0,o.kt)("inlineCode",{parentName:"p"},"joe.age"),". We remediate this by generating getter and setters."),(0,o.kt)("h4",i({},{id:"read"}),"Read"),(0,o.kt)("p",null,"One getter function is generated per ",(0,o.kt)("inlineCode",{parentName:"p"},"bs.deriving abstract")," record type field. In the above example, you'd get 3 functions: ",(0,o.kt)("inlineCode",{parentName:"p"},"nameGet"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"ageGet"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"jobGet"),". They take in a ",(0,o.kt)("inlineCode",{parentName:"p"},"person")," value and return ",(0,o.kt)("inlineCode",{parentName:"p"},"string"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"int"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"string")," respectively:"),(0,o.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-reason"}),"let twenty = ageGet(joe)\n")),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-ocaml"}),"let twenty = ageGet joe\n"))),(0,o.kt)("p",null,"Alternatively, you can use the ",(0,o.kt)("a",i({parentName:"p"},{href:"pipe"}),"Pipe")," operator (",(0,o.kt)("inlineCode",{parentName:"p"},"->"),") for a nicer-looking access syntax:"),(0,o.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-reason"}),"let twenty = joe->ageGet\n")),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-ocaml"}),"let twenty = joe |. ageGet\n"))),(0,o.kt)("p",null,"If you prefer shorter names for the getter functions, we also support a ",(0,o.kt)("inlineCode",{parentName:"p"},"light")," setting:"),(0,o.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-reason"}),'[@bs.deriving {abstract: light}]\ntype person = {\n  name: string,\n  age: int,\n};\n\nlet joe = person(~name="Joe", ~age=20);\nlet joeName = name(joe);\n')),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-ocaml"}),'type person = {\n  name: string;\n  age: int;\n} [@@bs.deriving {abstract = light}]\n\nlet joe = person ~name:"Joe" ~age:20\nlet joeName = name joe\n'))),(0,o.kt)("p",null,"The getter functions will now have the same names as the object fields themselves."),(0,o.kt)("h4",i({},{id:"write"}),"Write"),(0,o.kt)("p",null,"A ",(0,o.kt)("inlineCode",{parentName:"p"},"[@bs.deriving abstract]")," value is immutable by default. To mutate such value, you need to first mark one of the abstract record field as ",(0,o.kt)("inlineCode",{parentName:"p"},"mutable"),", the same way you'd mark a normal record as mutable:"),(0,o.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-reason"}),"[@bs.deriving abstract]\ntype person = {\n  name: string,\n  mutable age: int,\n  job: string,\n};\n")),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-ocaml"}),"type person = {\n  name: string;\n  mutable age: int;\n  job: string;\n} [@@bs.deriving abstract]\n"))),(0,o.kt)("p",null,"Then, a setter of the name ",(0,o.kt)("inlineCode",{parentName:"p"},"ageSet")," will be generated. Use it like so:"),(0,o.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-reason"}),'let joe = person(~name="Joe", ~age=20, ~job="teacher");\nageSet(joe, 21);\n')),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-ocaml"}),'let joe = person ~name:"Joe" ~age:20 ~job:"teacher"\nlet () = ageSet joe 21\n'))),(0,o.kt)("p",null,"Alternatively, with the Pipe First syntax:"),(0,o.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-reason"}),"joe->ageSet(21)\n")),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-ocaml"}),"joe |. ageSet 21\n"))),(0,o.kt)("h3",i({},{id:"methods"}),"Methods"),(0,o.kt)("p",null,"You can attach arbitrary methods onto a type (",(0,o.kt)("em",{parentName:"p"},"any")," type, as a matter of fact. Not just ",(0,o.kt)("inlineCode",{parentName:"p"},"[@bs.deriving abstract]")," record types). See ",(0,o.kt)("a",i({parentName:"p"},{href:"bind-to-js-function#object-method"}),"Object Method"),' in the "Bind to JS Function" section for more infos.'),(0,o.kt)("h3",i({},{id:"tips--tricks"}),"Tips & Tricks"),(0,o.kt)("p",null,"You can leverage ",(0,o.kt)("inlineCode",{parentName:"p"},"[@bs.deriving abstract]")," for finer-grained access control."),(0,o.kt)("h4",i({},{id:"mutability"}),"Mutability"),(0,o.kt)("p",null,"You can mark a field as mutable in the implementation (",(0,o.kt)("inlineCode",{parentName:"p"},"ml"),"/",(0,o.kt)("inlineCode",{parentName:"p"},"re"),") file, while ",(0,o.kt)("em",{parentName:"p"},"hiding")," such mutability in the interface file:"),(0,o.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-reason"}),"/* test.re */\n[@bs.deriving abstract]\ntype cord = {\n  [@bs.optional] mutable x: int,\n  y: int,\n};\n")),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-ocaml"}),"(* test.ml *)\ntype cord = {\n  mutable x: int [@bs.optional];\n  y: int;\n} [@@bs.deriving abstract]\n"))),(0,o.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-reason"}),"/* test.rei */\n[@bs.deriving abstract]\ntype cord = {\n  [@bs.optional] x: int,\n  y: int,\n};\n")),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-ocaml"}),"(* test.mli *)\ntype cord = {\n  x: int [@bs.optional];\n  y: int;\n} [@@bs.deriving abstract]\n"))),(0,o.kt)("p",null,"Tada! Now you can mutate inside your own file as much as you want, and prevent others from doing so!"),(0,o.kt)("h4",i({},{id:"hide-the-creation-function"}),"Hide the Creation Function"),(0,o.kt)("p",null,"Mark the record as ",(0,o.kt)("inlineCode",{parentName:"p"},"private")," to disable the creation function:"),(0,o.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-reason"}),"[@bs.deriving abstract]\ntype cord = pri {\n  [@bs.optional] x: int,\n  y: int,\n};\n")),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-ocaml"}),"type cord = private {\n  x: int [@bs.optional];\n  y: int\n} [@@bs.deriving abstract]\n"))),(0,o.kt)("p",null,"The accessors are still there, but you can no longer create such data structure. Great for binding to a JS object while preventing others from creating more such object!"),(0,o.kt)("h4",i({},{id:"use-submodules-to-prevent-naming-collisions-and-binding-shadowing"}),"Use submodules to prevent naming collisions and binding shadowing"),(0,o.kt)("p",null,"Oftentimes you will have multiple abstract types with similar attributes. Since\nReScript will expand all abstract getter, setter and creation functions in the\nsame scope where the type is defined, you will eventually run into value shadowing problems."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"For example:")),(0,o.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-reason"}),'[@bs.deriving abstract]\ntype person = {name: string};\n\n[@bs.deriving abstract]\ntype cat = {\n  name: string,\n  isLazy: bool,\n};\n\nlet person = person(~name="Alice");\n\n/* Error: This expression has type person but an expression was expected\n   of type cat */\nperson->nameGet();\n')),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-ocaml"}),'type person = { name: string }[@@bs.deriving abstract]\ntype cat = {\n  name: string;\n  isLazy: bool\n}[@@bs.deriving abstract]\n\nlet person = person ~name:"Alice";;\n\n(person |. nameGet) ()\n'))),(0,o.kt)("p",null,"To get around this issue, you can use modules to group a type with its related\nfunctions and later use them via local open statements:"),(0,o.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-reason"}),'module Person = {\n  [@bs.deriving abstract]\n  type t = {name: string};\n};\n\nmodule Cat = {\n  [@bs.deriving abstract]\n  type t = {\n    name: string,\n    isLazy: bool,\n  };\n};\n\nlet person = Person.t(~name="Alice");\nlet cat = Cat.t(~name="Snowball", ~isLazy=true);\n\n/* We can use each nameGet function separately now */\nlet shoutPersonName = Person.(person->nameGet->Js.String.toUpperCase);\n\n/* Note how we use a local open Cat.([some expression]) to \n   get access to Cat\'s nameGet function */\nlet whisperCatName = Cat.(cat->nameGet->Js.String.toLowerCase);\n')),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-ocaml"}),'module Person =\n  struct type t = { name: string }[@@bs.deriving abstract] end\n\nmodule Cat = struct type t = {\n  name: string;\n  isLazy: bool\n}[@@bs.deriving abstract] end\n\nlet person = Person.t ~name:"Alice"\nlet cat = Cat.t ~name:"Snowball" ~isLazy:true\n\nlet shoutPersonName =\n  let open Person in (person |. nameGet) |. Js.String.toUpperCase\n\nlet whisperCatName =\n  let open Cat in (cat |. nameGet) |. Js.String.toLowerCase\n'))),(0,o.kt)("h2",i({},{id:"convert-external-into-js-object-creation-function"}),"Convert External into JS Object Creation Function"),(0,o.kt)("p",null,"Use ",(0,o.kt)("inlineCode",{parentName:"p"},"@bs.obj")," on an ",(0,o.kt)("inlineCode",{parentName:"p"},"external")," binding to create a function that, when called, will evaluate to a ",(0,o.kt)("inlineCode",{parentName:"p"},"Js.t")," object with fields corresponding to the function's parameter labels."),(0,o.kt)("p",null,"This is very handy because you can make some of those labelled parameters optional and if you don't pass them in, the output object won't include the corresponding fields. Thus you can use it to dynamically create objects with the subset of fields you need at runtime."),(0,o.kt)("p",null,"For example, suppose you need a JavaScript object like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-js"}),'var homeRoute = {\n  method: "GET",\n  path: "/",\n  action: () => console.log("Home"),\n  // options: ...\n};\n')),(0,o.kt)("p",null,"But only the first three fields are required; the options field is optional. You can declare the binding function like so:"),(0,o.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-reason"}),'[@bs.obj] external route: (\n  ~_method:string,\n  ~path:string,\n  ~action:(list(string) => unit),\n  ~options:Js.t({..})=?,\n  unit\n) => _ = "";\n')),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-ocaml"}),'external route :\n  _method:string ->\n  path:string ->\n  action:(string list -> unit) ->\n  ?options:< .. > Js.t ->\n  unit ->\n  _ = "" [@@bs.obj]\n'))),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Note"),": the ",(0,o.kt)("inlineCode",{parentName:"p"},' = ""')," part at the end is just a dummy placeholder, due to syntactic limitations. It serves no purpose currently."),(0,o.kt)("p",null,"This function has four labelled parameters (the fourth one optional), one unlabelled parameter at the end (which we mandate for functions with ",(0,o.kt)("a",i({parentName:"p"},{href:"function#optional-labeled-arguments"}),"optional parameters"),", and one parameter (",(0,o.kt)("inlineCode",{parentName:"p"},"_method"),") that requires an underscore prefix to avoid confusion with the ReScript keyword ",(0,o.kt)("inlineCode",{parentName:"p"},"method"),"."),(0,o.kt)("p",null,"Also of interest is the return type: ",(0,o.kt)("inlineCode",{parentName:"p"},"_"),", which tells ReScript to automatically infer the full type of the ",(0,o.kt)("inlineCode",{parentName:"p"},"Js.t")," object, sparing you the hassle of writing down the type manually!"),(0,o.kt)("p",null,"The function is called like so:"),(0,o.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-reason"}),'let homeRoute = route(~_method="GET", ~path="/", ~action=(_ => Js.log("Home")), ());\n')),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-ocaml"}),'let homeRoute = route ~_method:"GET" ~path:"/" ~action:(fun _ -> Js.log "Home") ()\n'))))}d.isMDXComponent=!0,d.frontmatter={title:"Generate Converters & Helpers",description:"All about the @bs.deriving decorator, and how to generate code from types",canonical:"/docs/manual/latest/generate-converters-accessors",__ghEditHref:"https://github.com/reason-association/rescript-lang.org/blob/master/pages/docs/manual/v8.0.0/generate-converters-accessors.mdx"}},58625:function(e,n,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/docs/manual/v8.0.0/generate-converters-accessors",function(){return t(2072)}])}},function(e){e.O(0,[92888,49774,40179],(function(){return n=58625,e(e.s=n);var n}));var n=e.O();_N_E=n}]);