(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[24411],{17375:function(e,n,t){"use strict";function a(e,n){if(null==e)return{};var t,a,l=function(e,n){if(null==e)return{};var t,a,l={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(l[t]=e[t]);return l}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(l[t]=e[t])}return l}t.d(n,{Z:function(){return a}})},88264:function(e,n,t){"use strict";t.r(n),t.d(n,{default:function(){return d}});var a=t(17375),l=t(96156),r=(t(67294),t(3905));function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){(0,l.Z)(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}var s,p=(s="CodeTab",function(e){return console.warn("Component "+s+" was not imported, exported, or provided by MDXProvider as global scope"),(0,r.kt)("div",i({},e))}),u={};function d(e){var n=e.components,t=(0,a.Z)(e,["components"]);return(0,r.kt)("wrapper",i(i(i({},u),t),{},{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",i({},{id:"module"}),"Module"),(0,r.kt)("h2",i({},{id:"basics"}),"Basics"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Modules are like mini files"),"! They can contain type definitions, ",(0,r.kt)("inlineCode",{parentName:"p"},"let"),"\nbindings, nested modules, etc."),(0,r.kt)("h3",i({},{id:"creation"}),"Creation"),(0,r.kt)("p",null,"To create a module, use the ",(0,r.kt)("inlineCode",{parentName:"p"},"module")," keyword. The module name must start with a\n",(0,r.kt)("strong",{parentName:"p"},"capital letter"),". Whatever you could place in a ",(0,r.kt)("inlineCode",{parentName:"p"},".re")," file, you may place\ninside a module definition's ",(0,r.kt)("inlineCode",{parentName:"p"},"{}")," block."),(0,r.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-re"}),'module School = {\n  type profession = Teacher | Director;\n\n  let person1 = Teacher;\n  let getProfession = (person) =>\n    switch person {\n    | Teacher => "A teacher"\n    | Director => "A director"\n    };\n};\n')),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-ml"}),'module School = struct\n  type profession = Teacher | Director\n\n  let person1 = Teacher\n  let getProfession person =\n    match person with\n    | Teacher -> "A teacher"\n    | Director -> "A director"\nend\n')),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-js"}),'function getProfession(person) {\n  if (person) {\n    return "A director";\n  } else {\n    return "A teacher";\n  }\n}\n\nvar School = {\n  person1: /* Teacher */0,\n  getProfession: getProfession\n};\n'))),(0,r.kt)("p",null,"A module's contents (including types!) can be accessed much like a record's,\nusing the ",(0,r.kt)("inlineCode",{parentName:"p"},".")," notation. This demonstrates modules' utility for namespacing."),(0,r.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-re"}),'let anotherPerson: School.profession = School.Teacher;\nJs.log(School.getProfession(anotherPerson)); /* "A teacher" */\n')),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-ml"}),'let anotherPerson: School.profession = School.Teacher\nJs.log (School.getProfession anotherPerson) (* "A teacher" *)\n')),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-js"}),'var anotherPerson = /* Teacher */0;\nconsole.log("A teacher");\n'))),(0,r.kt)("p",null,"Nested modules work too."),(0,r.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-re"}),'module MyModule = {\n  module NestedModule = {\n    let message = "hello"\n  };\n};\n\nlet message = MyModule.NestedModule.message;\n')),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-ml"}),'module MyModule = struct\n  module NestedModule = struct\n    let message = "hello"\n  end\nend\n\nlet message = MyModule.NestedModule.message\n')),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-js"}),"var NestedModule = {\n  message: message\n};\n\nvar MyModule = {\n  NestedModule: NestedModule\n};\n\nvar message = MyModule.NestedModule.message;\n"))),(0,r.kt)("h3",i({},{id:"opening-a-module"}),(0,r.kt)("inlineCode",{parentName:"h3"},"open"),"ing a module"),(0,r.kt)("p",null,'Constantly referring to a value/type in a module can be tedious. Instead, we can "open" a module and refer to its contents without always prepending them with the\nmodule\'s name. Instead of writing:'),(0,r.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-re"}),"let p = School.getProfession(School.person1);\n")),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-ml"}),"let p = School.getProfession School.person1\n")),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-js"}),"var p = School.getProfession(School.person1);\n"))),(0,r.kt)("p",null,"We can write:"),(0,r.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-re"}),"open School;\nlet p = getProfession(person1);\n")),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-ml"}),"open School\nlet p = getProfession person1\n")),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-js"}),"var p = School.getProfession(School.person1);\n"))),(0,r.kt)("p",null,"The content of ",(0,r.kt)("inlineCode",{parentName:"p"},"School")," module are made visible (",(0,r.kt)("strong",{parentName:"p"},"not")," copied into the file, but simply made visible!) in scope. ",(0,r.kt)("inlineCode",{parentName:"p"},"profession"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"getProfession")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"person1")," will thus correctly be found."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Use ",(0,r.kt)("inlineCode",{parentName:"strong"},"open")," this sparingly, it's convenient, but makes it hard to know where some values come from"),". You should usually use ",(0,r.kt)("inlineCode",{parentName:"p"},"open")," in a local scope:"),(0,r.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-re"}),"let p = {\n  open School;\n  getProfession(person1);\n};\n/* School's content isn't visible here anymore */\n")),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-ml"}),"let p =\n  let open School in\n  getProfession person1\n(* School's content isn't visible here anymore *)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-js"}),"var p = School.getProfession(School.person1);\n"))),(0,r.kt)("h3",i({},{id:"extending-modules"}),"Extending modules"),(0,r.kt)("p",null,"Using ",(0,r.kt)("inlineCode",{parentName:"p"},"include"),' in a module statically "spreads" a module\'s content into a new one, thus often fulfill the role of "inheritance" or "mixin".'),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Note"),": this is equivalent to a compiler-level copy paste. ",(0,r.kt)("strong",{parentName:"p"},"We heavily discourage ",(0,r.kt)("inlineCode",{parentName:"strong"},"include")),". Use it as last resort!"),(0,r.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-re"}),'module BaseComponent = {\n  let defaultGreeting = "Hello";\n  let getAudience = (~excited) => excited ? "world!" : "world";\n};\n\nmodule ActualComponent = {\n  /* the content is copied over */\n  include BaseComponent;\n  /* overrides BaseComponent.defaultGreeting */\n  let defaultGreeting = "Hey";\n  let render = () => defaultGreeting ++ " " ++ getAudience(~excited=true);\n};\n')),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-ml"}),'module BaseComponent = struct\n  let defaultGreeting = "Hello"\n  let getAudience ~excited = if excited then "world!" else "world"\nend\n\nmodule ActualComponent = struct\n  (* the content is copied over *)\n  include BaseComponent\n  (* overrides BaseComponent.defaultGreeting *)\n  let defaultGreeting = "Hey"\n  let render () = defaultGreeting ^ " " ^ (getAudience ~excited:true)\nend\n')),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-js"}),'function getAudience(excited) {\n  if (excited) {\n    return "world!";\n  } else {\n    return "world";\n  }\n}\n\nvar BaseComponent = {\n  defaultGreeting: "Hello",\n  getAudience: getAudience\n};\n\nvar defaultGreeting = "Hey";\n\nfunction render(param) {\n  return "Hey world!";\n}\n\nvar ActualComponent = {\n  getAudience: getAudience,\n  defaultGreeting: defaultGreeting,\n  render: render\n};\n'))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Note"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"open")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"include")," are very different! The former brings a module's content into your current scope, so that you don't have to refer to a value by prefixing it with the module's name every time. The latter ",(0,r.kt)("strong",{parentName:"p"},"copies over")," the definition of a module statically, then also do an ",(0,r.kt)("inlineCode",{parentName:"p"},"open"),"."),(0,r.kt)("h3",i({},{id:"every-re-file-is-a-module"}),"Every ",(0,r.kt)("inlineCode",{parentName:"h3"},".re")," file is a module"),(0,r.kt)("p",null,"Every ReScript file is itself compiled to a module of the same name as the file name, capitalized. The file ",(0,r.kt)("inlineCode",{parentName:"p"},"React.re")," implicitly forms a module ",(0,r.kt)("inlineCode",{parentName:"p"},"React"),", which can be seen by other source files."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Note"),": ReScript file names should, by convention, be capitalized so that their casing matches their module name. Uncapitalized file names are not invalid, but will be implicitly transformed into a capitalized module name. I.e. ",(0,r.kt)("inlineCode",{parentName:"p"},"file.res")," will be compiled into the module ",(0,r.kt)("inlineCode",{parentName:"p"},"File"),". To simplify and minimize the disconnect here, the convention is therefore to capitalize file names."),(0,r.kt)("h2",i({},{id:"signatures"}),"Signatures"),(0,r.kt)("p",null,'A module\'s type is called a "signature", and can be written explicitly. If a\nmodule is like a ',(0,r.kt)("inlineCode",{parentName:"p"},".re")," (implementation) file, then a module's signature is like\na ",(0,r.kt)("inlineCode",{parentName:"p"},".rei")," (interface) file."),(0,r.kt)("h3",i({},{id:"creation-1"}),"Creation"),(0,r.kt)("p",null,"To create a signature, use the ",(0,r.kt)("inlineCode",{parentName:"p"},"module type")," keyword. The signature name must start with a\n",(0,r.kt)("strong",{parentName:"p"},"capital letter"),". Whatever you could place in a ",(0,r.kt)("inlineCode",{parentName:"p"},".rei")," file, you may place\ninside a signature definition's ",(0,r.kt)("inlineCode",{parentName:"p"},"{}")," block."),(0,r.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-re"}),"/* Picking up previous section's example */\nmodule type EstablishmentType = {\n  type profession;\n  let getProfession: profession => string;\n};\n")),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-ml"}),"(* Picking up previous section's example *)\nmodule type EstablishmentType  = sig\n  type profession\n  val getProfession: profession -> string\nend\n")),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-js"}),"// Empty output\n"))),(0,r.kt)("p",null,"A signature defines the list of requirements that a module must satisfy in order\nfor that module to match the signature. Those requirements are of the form:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"let x: int")," requires a ",(0,r.kt)("inlineCode",{parentName:"li"},"let")," binding named ",(0,r.kt)("inlineCode",{parentName:"li"},"x"),", of type ",(0,r.kt)("inlineCode",{parentName:"li"},"int"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"type t = someType")," requires a type field ",(0,r.kt)("inlineCode",{parentName:"li"},"t")," to be equal to ",(0,r.kt)("inlineCode",{parentName:"li"},"someType"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"type t")," requires a type field ",(0,r.kt)("inlineCode",{parentName:"li"},"t"),", but without imposing any requirements on the actual, concrete type of ",(0,r.kt)("inlineCode",{parentName:"li"},"t"),". We'd use ",(0,r.kt)("inlineCode",{parentName:"li"},"t")," in other entries in the signature to describe relationships, e.g. ",(0,r.kt)("inlineCode",{parentName:"li"},"let makePair: t => (t, t)")," but we cannot, for example, assume that ",(0,r.kt)("inlineCode",{parentName:"li"},"t")," is an ",(0,r.kt)("inlineCode",{parentName:"li"},"int"),". This gives us great, enforced abstraction abilities.")),(0,r.kt)("p",null,"To illustrate the various kinds of type entries, consider the above signature\n",(0,r.kt)("inlineCode",{parentName:"p"},"EstablishmentType")," which requires that a module:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Declare a type named ",(0,r.kt)("inlineCode",{parentName:"li"},"profession"),"."),(0,r.kt)("li",{parentName:"ul"},"Must include a function that takes in a value of the type ",(0,r.kt)("inlineCode",{parentName:"li"},"profession")," and returns a string.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Note"),":"),(0,r.kt)("p",null,"Modules of the type ",(0,r.kt)("inlineCode",{parentName:"p"},"EstablishmentType")," can contain more fields than the\nsignature declares, just like the module ",(0,r.kt)("inlineCode",{parentName:"p"},"School")," in the previous section (if we\nchoose to assign it the type ",(0,r.kt)("inlineCode",{parentName:"p"},"EstablishmentType"),". Otherwise, ",(0,r.kt)("inlineCode",{parentName:"p"},"School")," exposes\nevery field). This effectively makes the ",(0,r.kt)("inlineCode",{parentName:"p"},"person1")," field an enforced\nimplementation detail! Outsiders can't access it, since it's not present in the\nsignature; the signature ",(0,r.kt)("strong",{parentName:"p"},"constrained")," what others can access."),(0,r.kt)("p",null,"The type ",(0,r.kt)("inlineCode",{parentName:"p"},"EstablishmentType.profession")," is ",(0,r.kt)("strong",{parentName:"p"},"abstract"),": it doesn't have a\nconcrete type; it's saying \"I don't care what the actual type is, but it's used\nas input to ",(0,r.kt)("inlineCode",{parentName:"p"},"getProfession"),'". This is useful to fit many modules under the same\ninterface:'),(0,r.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-re"}),"module Company: EstablishmentType = {\n  type profession = CEO | Designer | Engineer | ...\n\n  let getProfession = (person) => ...\n  let person1 = ...\n  let person2 = ...\n};\n")),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-ml"}),"module Company: EstablishmentType = struct\n  type profession = CEO | Designer | Engineer | ...\n\n  let getProfession person = ...\n  let person1 = ...\n  let person2 = ...\nend\n")),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-js"}),"function getProfession(person) {\n  ...\n}\n\nvar person1 = ...\n\nvar person2 = ...\n\nvar Company = {\n  getProfession: getProfession,\n  person1: person1,\n  person2: person2\n};\n"))),(0,r.kt)("p",null,"It's also useful to hide the underlying type as an implementation detail others\ncan't rely on. If you ask what the type of ",(0,r.kt)("inlineCode",{parentName:"p"},"Company.profession")," is, instead of\nexposing the variant, it'll only tell you \"it's ",(0,r.kt)("inlineCode",{parentName:"p"},"Company.profession"),'".'),(0,r.kt)("h3",i({},{id:"extending-module-signatures"}),"Extending module signatures"),(0,r.kt)("p",null,"Like modules themselves, module signatures can also be extended by other module signatures using ",(0,r.kt)("inlineCode",{parentName:"p"},"include"),". Again, ",(0,r.kt)("strong",{parentName:"p"},"heavily discouraged"),":"),(0,r.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-re"}),"module type BaseComponent = {\n  let defaultGreeting: string;\n  let getAudience: (~excited: bool) => string;\n};\n\nmodule type ActualComponent = {\n  /* the BaseComponent signature is copied over */\n  include BaseComponent;\n  let render: unit => string;\n};\n")),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-ml"}),"module type BaseComponent = sig\n  val defaultGreeting: string\n  val getAudience: excited:bool -> string\nend\n\nmodule type ActualComponent = sig\n  (* the BaseComponent signature is copied over *)\n  include BaseComponent\n  val render: unit -> string\nend\n")),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-js"}),"// Empty output\n"))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Note"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"BaseComponent")," is a module ",(0,r.kt)("strong",{parentName:"p"},"type"),", not an actual module itself!"),(0,r.kt)("p",null,"If you do not have a defined module type, you can extract it from an actual module\nusing ",(0,r.kt)("inlineCode",{parentName:"p"},"include (module type of ActualModuleName)"),". For example, we can extend the\n",(0,r.kt)("inlineCode",{parentName:"p"},"List")," module from the standard library, which does not define a module\ntype."),(0,r.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-re"}),"module type MyList = {\n  include (module type of List);\n  let myListFun: list('a) => list('a);\n};\n")),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-ml"}),"module type MyList = sig\n  include module type of List\n  val myListFun: 'a list -> 'a list\nend\n")),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-js"}),"// Empty output\n"))),(0,r.kt)("h3",i({},{id:"every-rei-file-is-a-signature"}),"Every ",(0,r.kt)("inlineCode",{parentName:"h3"},".rei")," file is a signature"),(0,r.kt)("p",null,"Similar to how a ",(0,r.kt)("inlineCode",{parentName:"p"},"React.re")," file implicitly defines a module ",(0,r.kt)("inlineCode",{parentName:"p"},"React"),", a file\n",(0,r.kt)("inlineCode",{parentName:"p"},"React.rei")," implicitly defines a signature for ",(0,r.kt)("inlineCode",{parentName:"p"},"React"),". If ",(0,r.kt)("inlineCode",{parentName:"p"},"React.rei")," isn't\nprovided, the signature of ",(0,r.kt)("inlineCode",{parentName:"p"},"React.re")," defaults to exposing all the fields of the\nmodule. Because they don't contain implementation files, ",(0,r.kt)("inlineCode",{parentName:"p"},".rei")," files are used\nin the ecosystem to also document the public API of their corresponding modules."),(0,r.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-re"}),"/* file React.re (implementation. Compiles to module React) */\ntype state = int;\nlet render = (str) => str;\n")),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-ml"}),"(* file React.ml (implementation. Compiles to module React) *)\ntype state = int\nlet render str = str\n")),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-js"}),"function render(str) {\n  return str;\n}\n"))),(0,r.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-re"}),"/* file React.rei (interface. Compiles to the signature of React.re) */\ntype state = int;\nlet render: string => string;\n")),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-ml"}),"(* file React.mli (interface. Compiles to the signature of React.re) *)\ntype state = int\nval render: str -> str\n"))),(0,r.kt)("h2",i({},{id:"module-functions-functors"}),"Module Functions (functors)"),(0,r.kt)("p",null,'Modules can be passed to functions! It would be the equivalent of passing a file\nas a first-class item. However, modules are at a different "layer" of the\nlanguage than other common concepts, so we can\'t pass them to ',(0,r.kt)("em",{parentName:"p"},"regular"),'\nfunctions. Instead, we pass them to special functions called "functors".'),(0,r.kt)("p",null,"The syntax for defining and using functors is very much like the syntax\nfor defining and using regular functions. The primary differences are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Functors use the ",(0,r.kt)("inlineCode",{parentName:"li"},"module")," keyword instead of ",(0,r.kt)("inlineCode",{parentName:"li"},"let"),"."),(0,r.kt)("li",{parentName:"ul"},"Functors take modules as arguments and return a module."),(0,r.kt)("li",{parentName:"ul"},"Functors ",(0,r.kt)("em",{parentName:"li"},"require")," annotating arguments."),(0,r.kt)("li",{parentName:"ul"},"Functors must start with a capital letter (just like modules/signatures).")),(0,r.kt)("p",null,"Here's an example ",(0,r.kt)("inlineCode",{parentName:"p"},"MakeSet")," functor, that takes in a module of the type\n",(0,r.kt)("inlineCode",{parentName:"p"},"Comparable")," and returns a new set that can contain such comparable items."),(0,r.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-re"}),"module type Comparable = {\n  type t;\n  let equal: (t, t) => bool;\n}\n\nmodule MakeSet = (Item: Comparable) => {\n  // let's use a list as our naive backing data structure\n  type backingType = list(Item.t);\n  let empty = [];\n  let add = (currentSet: backingType, newItem: Item.t): backingType =>\n    // if item exists\n    if (List.exists(x => Item.equal(x, newItem), currentSet)) {\n      currentSet; // return the same (immutable) set (a list really)\n    } else {\n      [\n        newItem,\n        ...currentSet // prepend to the set and return it\n      ]\n    };\n};\n")),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-ml"}),"module type Comparable = sig\n  type t\n  val equal: t -> t -> bool\nend\n\nmodule MakeSet (Item: Comparable) = struct\n  (* let's use a list as our naive backing data structure *)\n  type backingType = Item.t list\n  let empty = []\n  let add (currentSet: backingType) (newItem: Item.t) : backingType =\n    (* if item exists *)\n    if List.exists (fun x -> Item.equal x newItem) currentSet then\n      currentSet (* return the same (immutable) set (a list really) *)\n    else\n      newItem::currentSet (* prepend to the set and return it *)\nend\n")),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-js"}),'var List = require("./stdlib/list.js");\n\nfunction MakeSet(Item) {\n  var add = function(currentSet, newItem) {\n    if (\n      List.exists(function(x) {\n        return Item.equal(x, newItem);\n      }, currentSet)\n    ) {\n      return currentSet;\n    } else {\n      return {\n        hd: newItem,\n        tl: currentSet,\n      };\n    }\n  };\n  return {\n    empty: /* [] */ 0,\n    add: add,\n  };\n}\n'))),(0,r.kt)("p",null,"Functors can be applied using function application syntax. In this case, we're\ncreating a set, whose items are pairs of integers."),(0,r.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-re"}),"module IntPair = {\n  type t = (int, int);\n  let equal = ((x1: int, y1: int), (x2, y2)) => x1 == x2 && y1 == y2;\n  let create = (x, y) => (x, y);\n};\n\n/* IntPair abides by the Comparable signature required by MakeSet */\nmodule SetOfIntPairs = MakeSet(IntPair);\n")),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-ml"}),"module IntPair = struct\n  type t = int * int\n  let equal ((x1: int), (y1: int)) (x2,y2) = (x1 = x2) && (y1 = y2)\n  let create x y = (x, y)\nend\n\n(* IntPair abides by the Comparable signature required by MakeSet *)\nmodule SetOfIntPairs = MakeSet(IntPair)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-js"}),"function equal(param, param$1) {\n  if (param[0] === param$1[0]) {\n    return param[1] === param$1[1];\n  } else {\n    return false;\n  }\n}\n\nfunction create(x, y) {\n  return [x, y];\n}\n\nvar IntPair = {\n  equal: equal,\n  create: create,\n};\n\nvar SetOfIntPairs = {\n  empty: /* [] */ 0,\n  add: add,\n};\n"))),(0,r.kt)("h3",i({},{id:"module-functions-types"}),"Module functions types"),(0,r.kt)("p",null,"Like with module types, functor types also act to constrain and hide what we may\nassume about functors. The syntax for functor types are consistent with those\nfor function types, but with types capitalized to represent the signatures of\nmodules the functor accepts as arguments and return values. In the\nprevious example, we're exposing the backing type of a set; by giving ",(0,r.kt)("inlineCode",{parentName:"p"},"MakeSet"),"\na functor signature, we can hide the underlying data structure!"),(0,r.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-re"}),"module type Comparable = ...\n\nmodule type MakeSetType = (Item: Comparable) => {\n  type backingType;\n  let empty: backingType;\n  let add: (backingType, Item.t) => backingType;\n};\n\nmodule MakeSet: MakeSetType = (Item: Comparable) => {\n  ...\n};\n")),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-ml"}),"module type Comparable = ...\n\nmodule type MakeSetType = functor (Item : Comparable) -> sig\n  type backingType\n  val empty: backingType\n  val add: backingType -> Item.t -> backingType\nend\n\nmodule MakeSet: MakeSetType = functor (Item: Comparable) -> struct\n  ...\nend\n")),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-js"}),"// Empty output\n"))),(0,r.kt)("h2",i({},{id:"tips--tricks"}),"Tips & Tricks"),(0,r.kt)("p",null,'Modules and functors are at a different "layer" of language than the rest (functions, let bindings, data structures, etc.). For example, you can\'t easily pass them into a tuple or record. Use them judiciously, if ever! Lots of times, just a record or a function is enough.'))}d.isMDXComponent=!0,d.frontmatter={title:"Module",description:"ReScript modules, module signatures and interface files",canonical:"/docs/manual/latest/module",__ghEditHref:"https://github.com/reason-association/rescript-lang.org/blob/master/pages/docs/manual/v8.0.0/module.mdx"}},27883:function(e,n,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/docs/manual/v8.0.0/module",function(){return t(88264)}])}},function(e){e.O(0,[92888,49774,40179],(function(){return n=27883,e(e.s=n);var n}));var n=e.O();_N_E=n}]);