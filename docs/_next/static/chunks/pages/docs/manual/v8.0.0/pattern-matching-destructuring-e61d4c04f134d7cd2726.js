(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[95581],{17375:function(e,t,n){"use strict";function a(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}n.d(t,{Z:function(){return a}})},80588:function(e,t,n){"use strict";n.r(t),n.d(t,{default:function(){return c}});var a=n(17375),r=n(96156),o=(n(67294),n(3905));function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){(0,r.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var i,p=(i="CodeTab",function(e){return console.warn("Component "+i+" was not imported, exported, or provided by MDXProvider as global scope"),(0,o.kt)("div",s({},e))}),u={};function c(e){var t=e.components,n=(0,a.Z)(e,["components"]);return(0,o.kt)("wrapper",s(s(s({},u),n),{},{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",s({},{id:"pattern-matching--destructuring"}),"Pattern Matching / Destructuring"),(0,o.kt)("p",null,"One of ReScript's ",(0,o.kt)("strong",{parentName:"p"},"best")," feature is our pattern matching. Pattern matching combines 3 brilliant features into one:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Destructuring."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"switch")," based on shape of data."),(0,o.kt)("li",{parentName:"ul"},"Exhaustiveness check.")),(0,o.kt)("p",null,"We'll dive into each aspect below."),(0,o.kt)("h2",s({},{id:"destructuring"}),"Destructuring"),(0,o.kt)("p",null,'Even JavaScript has destructuring, which is "opening up" a data structure to extract the parts we want and assign variable names to them:'),(0,o.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-re"}),"let coordinates = (10, 20, 30);\nlet (x, _, _) = coordinates;\nJs.log(x); // 10\n")),(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-ml"}),"let coordinates = (10, 20, 30)\nlet (x, _, _) = coordinates\nJs.log x (* 10 *)\n")),(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-js"}),"var coordinates = [10, 20, 30];\nvar x = 10;\nconsole.log(10);\n"))),(0,o.kt)("p",null,"Destructuring works with most built-in data structures:"),(0,o.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-re"}),'// Record\ntype student = {name: string, age: int};\nlet student1 = {name: "John", age: 10};\nlet {name} = student1; // "John" assigned to `name`\n\n// Variant\ntype result =\n  | Success(string);\nlet myResult = Success("You did it!");\nlet Success(message) = myResult; // "You did it!" assigned to `message`\n\n// Array\nlet myArray = [|1, 2, 3|];\nlet [|item1, item2, _|] = myArray; // 1 assigned to `item1`, 2 assigned to `item2`, 3rd item ignored\n\n// List\nlet myList = [1, 2, 3];\nlet [head, ...tail] = myList; // 1 assigned to `head`, `[2, 3]` assigned to tail\n')),(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-ml"}),'// Record\ntype student = {name: string; age: int}\nlet student1 = {name = "John"; age = 10}\nlet {name} = student1; (* "John" assigned to `name` *)\n\n(* Variant *)\ntype result =\n  | Success of string\nlet myResult = Success "You did it!"\nlet Success message = myResult (* "You did it!" assigned to `message` *)\n\n(* Array *)\nlet myArray = [|1; 2; 3|]\nlet [|item1; item2; _|] = myArray (* 1 assigned to `item1`, 2 assigned to `item2`, 3rd item ignored *)\n\n(* List *)\nlet myList = [1; 2; 3]\nlet head::tail = myList (* 1 assigned to `head`, `[2, 3]` assigned to tail *)\n')),(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-js"}),'var student1 = {\n  name: "John",\n  age: 10\n};\nvar name = "John";\n\nvar myResult = /* Success */{\n  _0: "You did it!"\n};\nvar message = "You did it!"\n\nvar myArray = [1, 2, 3];\nif (myArray.length !== 2) {\n  throw {\n    RE_EXN_ID: "Match_failure",\n    _1: [\n      "playground.res",\n      14,\n      4\n    ],\n    Error: new Error()\n  };\n}\nvar item1 = myArray[0];\nvar item2 = myArray[1];\n\nvar myList = {\n  hd: 1,\n  tl: {\n    hd: 2,\n    tl: {\n      hd: 3,\n      tl: /* [] */0\n    }\n  }\n};\n// ...\n'))),(0,o.kt)("p",null,"You can also use destructuring anywhere you'd usually put a binding:"),(0,o.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-re"}),'type result =\n  | Success(string);\nlet displayMessage = (Success(m)) => {\n  // we\'ve directly extracted the success message\n  // string by destructuring the parameter\n  Js.log(m);\n}\ndisplayMessage(Success("You did it!"));\n')),(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-ml"}),'type result =\n  | Success of string\nlet displayMessage (Success m) =\n  (* we\'ve directly extracted the success message *)\n  (* string by destructuring the parameter *)\n  Js.log m\n\nlet () = displayMessage (Success "You did it!")\n')),(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-js"}),'function displayMessage(m) {\n  console.log(m._0);\n}\n\ndisplayMessage(/* Success */{\n  _0: "You did it!"\n});\n'))),(0,o.kt)("p",null,"For a record, you can rename the field while destructuring:"),(0,o.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-re"}),'let {name: n} = student1; // "John" assigned to `n`\n')),(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-ml"}),'let {name = n} = student1 (* "John" assigned to `n` *)\n')),(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-js"}),'var n = "John";\n'))),(0,o.kt)("h2",s({},{id:"switch-based-on-shape-of-data"}),(0,o.kt)("inlineCode",{parentName:"h2"},"switch")," Based on Shape of Data"),(0,o.kt)("p",null,"While the destructuring aspect of pattern matching is nice, it doesn't really change the way you think about structuring your code. One paradigm-changing way of thinking about your code is to execute some code based on the shape of the data."),(0,o.kt)("p",null,"Consider a variant:"),(0,o.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-re"}),"type payload =\n  | BadResult(int)\n  | GoodResult(string)\n  | NoResult;\n")),(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-ml"}),"type payload =\n  | BadResult of int\n  | GoodResult of string\n  | NoResult\n")),(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-js"}),"// Empty output\n"))),(0,o.kt)("p",null,"We'd like to handle each of the 3 cases differently. For example, print a success message if the value is ",(0,o.kt)("inlineCode",{parentName:"p"},"GoodResult(...)"),", do something else when the value is ",(0,o.kt)("inlineCode",{parentName:"p"},"NoResult"),", etc."),(0,o.kt)("p",null,"In other languages, you'd end up with a series of if-elses that are hard to read and error-prone. In ReScript, you can instead use the supercharged ",(0,o.kt)("inlineCode",{parentName:"p"},"switch")," pattern matching facility to destructure the value while calling the right code based on what you destructured:"),(0,o.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-re"}),'let data = GoodResult("Product shipped!");\nswitch (data) {\n| GoodResult(theMessage) =>\n  Js.log("Success! " ++ theMessage)\n| BadResult(errorCode) =>\n  Js.log("Something\'s wrong. The error code is: " ++ Js.Int.toString(errorCode))\n| NoResult =>\n  Js.log("Bah.")\n};\n')),(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-ml"}),'let data = GoodResult ("Product shipped!")\nlet () = match data with\n| GoodResult theMessage ->\n  Js.log ("Success! " ^ theMessage)\n| BadResult errorCode ->\n  Js.log ("Something\'s wrong. The error code is: " ^ (Js.Int.toString errorCode))\n| NoResult -> Js.log "Bah."\n')),(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-js"}),'var data = {\n  TAG: /* GoodResult */1,\n  _0: "Product shipped!"\n};\n\nif (typeof data === "number") {\n  console.log("Bah.");\n} else if (data.TAG) {\n  console.log("Success! Product shipped!");\n} else {\n  console.log("Something\'s wrong. The error code is: " + "Product shipped!".toString());\n}\n'))),(0,o.kt)("p",null,"In this case, ",(0,o.kt)("inlineCode",{parentName:"p"},"message")," will have the value ",(0,o.kt)("inlineCode",{parentName:"p"},'"Success! Product shipped!"'),"."),(0,o.kt)("p",null,"Suddenly, your if-elses that messily checks some structure of the value got turned into a clean, compiler-verified, linear list of code to execute based on exactly the shape of the value."),(0,o.kt)("h3",s({},{id:"complex-examples"}),"Complex Examples"),(0,o.kt)("p",null,"Here's a real-world scenario that'd be a headache to code in other languages. Given this data structure:"),(0,o.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-re"}),"type status = Vacations(int) | Sabbatical(int) | Sick | Present;\ntype reportCard = {passing: bool, gpa: float};\ntype person =\n  | Teacher({\n    name: string,\n    age: int,\n  })\n  | Student({\n    name: string,\n    status: status,\n    reportCard: reportCard,\n  });\n")),(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-ml"}),"type status = Vacations of int | Sabbatical of int | Sick | Present\ntype reportCard = {passing: bool; gpa: float}\ntype person =\n  | Teacher of {\n    name: string;\n    age: int;\n  }\n  | Student of {\n    name: string;\n    status: status;\n    reportCard: reportCard;\n  }\n")),(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-js"}),"// Empty output\n"))),(0,o.kt)("p",null,"Imagine this requirement:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Informally greet a person who's a teacher and if his name is Mary or Joe."),(0,o.kt)("li",{parentName:"ul"},"Greet other teachers formally."),(0,o.kt)("li",{parentName:"ul"},"If the person's a student, congratulate him/her score if they passed the semester."),(0,o.kt)("li",{parentName:"ul"},"If the student has a gpa of 0 and is on vacations or sabbatical, display a different message."),(0,o.kt)("li",{parentName:"ul"},"A catch-all message for a student.")),(0,o.kt)("p",null,"ReScript can do this easily!"),(0,o.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-re"}),'let message = switch (person1) {\n| Teacher({name: "Mary" | "Joe"}) =>\n  "Hey, still going to the party on Saturday?"\n| Teacher({name}) =>\n  // this is matched only if `name` isn\'t "Joe"\n  {j|Hello $(name).|j}\n| Student({name, reportCard: {passing: true, gpa}}) =>\n  "Congrats " ++ name + ", nice GPA of " ++ Js.Float.toString(gpa) ++ " you got there!"\n| Student({\n    reportCard: {gpa: 0.0},\n    status: Vacations(daysLeft) | Sabbatical(daysLeft)\n  }) =>\n  "Come back in " ++ Js.Int.toString(daysLeft) ++ " days!"\n| Student({status: Sick}) =>\n  "How are you feeling?"\n| Student({name}) =>\n  {j|Good luck next semester $(name)!|j}\n};\n')),(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-ml"}),'let message = match person1 with\n| Teacher {name = "Mary" | "Joe"} ->\n  "Hey, still going to the party on Saturday?"\n| Teacher {name} ->\n  (* this is matched only if `name` isn\'t "Joe" *)\n  {j|Hello $(name).|j}\n| Student {name; reportCard = {passing = true; gpa}} ->\n  "Congrats " ++ name + ", nice GPA of " ++ Js.Float.toString(gpa) ++ " you got there!"\n| Student {\n    reportCard = {gpa = 0.0};\n    status = (Vacations daysLeft) | (Sabbatical daysLeft)\n  } ->\n  "Come back in " ++ (Js.Int.toString daysLeft) ++ " days!"\n| Student {status = Sick} ->\n  "How are you feeling?"\n| Student {name} ->\n  {j|Good luck next semester $(name)!|j}\n')),(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-js"}),'var message;\n\nif (person1.TAG) {\n  var match$1 = person1.status;\n  var name = person1.name;\n  var match$2 = person1.reportCard;\n  message = match$2.passing\n    ? "Congrats " +\n      name +\n      ", nice GPA of " +\n      match$2.gpa.toString() +\n      " you got there!"\n    : typeof match$1 === "number"\n    ? match$1 !== 0\n      ? "Good luck next semester " + name + "!"\n      : "How are you feeling?"\n    : person1.reportCard.gpa !== 0.0\n    ? "Good luck next semester " + name + "!"\n    : "Come back in " + match$1._0.toString() + " days!";\n} else {\n  var name$1 = person1.name;\n  switch (name$1) {\n    case "Joe":\n    case "Mary":\n      message = "Hey, still going to the party on Saturday?";\n      break;\n    default:\n      message = "Hello " + name$1 + ".";\n  }\n}\n'))),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Note")," how we've:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"drilled deep down into the value concisely"),(0,o.kt)("li",{parentName:"ul"},"using a nested pattern check ",(0,o.kt)("inlineCode",{parentName:"li"},'"Mary" | "Joe"')," and ",(0,o.kt)("inlineCode",{parentName:"li"},"Vacations | Sabbatical")),(0,o.kt)("li",{parentName:"ul"},"while extracting the ",(0,o.kt)("inlineCode",{parentName:"li"},"daysLeft")," number from the latter case"),(0,o.kt)("li",{parentName:"ul"},"and assigned the greeting to the binding ",(0,o.kt)("inlineCode",{parentName:"li"},"message"),".")),(0,o.kt)("p",null,"Here's another example of pattern matching, this time on an inline tuple."),(0,o.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-re"}),"type animal = Dog | Cat | Bird;\nlet categoryId = switch (isBig, myAnimal) {\n| (true, Dog) => 1\n| (true, Cat) => 2\n| (true, Bird) => 3\n| (false, Dog | Cat) => 4\n| (false, Bird) => 5\n};\n")),(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-ml"}),"type animal = Dog | Cat | Bird\nlet categoryId = match (isBig, myAnimal) with\n| (true, Dog) -> 1\n| (true, Cat) -> 2\n| (true, Bird) -> 3\n| (false, (Dog | Cat)) -> 4\n| (false, Bird) -> 5\n")),(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-js"}),"var categoryId = isBig ? (myAnimal + 1) | 0 : myAnimal >= 2 ? 5 : 4;\n"))),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Note")," how pattern matching on a tuple is equivalent to a 2D table:"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",s({parentName:"tr"},{align:null}),"isBig \\ myAnimal"),(0,o.kt)("th",s({parentName:"tr"},{align:null}),"Dog"),(0,o.kt)("th",s({parentName:"tr"},{align:null}),"Cat"),(0,o.kt)("th",s({parentName:"tr"},{align:null}),"Bird"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",s({parentName:"tr"},{align:null}),"true"),(0,o.kt)("td",s({parentName:"tr"},{align:null}),"1"),(0,o.kt)("td",s({parentName:"tr"},{align:null}),"2"),(0,o.kt)("td",s({parentName:"tr"},{align:null}),"3")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",s({parentName:"tr"},{align:null}),"false"),(0,o.kt)("td",s({parentName:"tr"},{align:null}),"4"),(0,o.kt)("td",s({parentName:"tr"},{align:null}),"4"),(0,o.kt)("td",s({parentName:"tr"},{align:null}),"5")))),(0,o.kt)("h3",s({},{id:"ignore-part-of-a-value"}),"Ignore Part of a Value"),(0,o.kt)("p",null,"If you have a value like ",(0,o.kt)("inlineCode",{parentName:"p"},"Teacher(payload)")," where you just want to pattern match on the ",(0,o.kt)("inlineCode",{parentName:"p"},"Teacher")," part and ignore the ",(0,o.kt)("inlineCode",{parentName:"p"},"payload")," completely, you can use the ",(0,o.kt)("inlineCode",{parentName:"p"},"_")," wildcard like this:"),(0,o.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-re"}),'switch (person) {\n| Teacher(_) => Js.log("Hi teacher")\n| Student(_) => Js.log("Hey student")\n};\n')),(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-ml"}),'let () = match person with\n| Teacher _ -> Js.log "Hi teacher"\n| Student _ -> Js.log "Hey student"\n')),(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-js"}),'if (person.TAG) {\n  console.log("Hey student");\n} else {\n  console.log("Hi teacher");\n}\n'))),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"_")," also works at the top level of the pattern like ",(0,o.kt)("inlineCode",{parentName:"p"},"| _ => ...")," if you want to execute catch-all condition."),(0,o.kt)("h3",s({},{id:"when-clause"}),"When Clause"),(0,o.kt)("p",null,"Sometime, you want to check more than the shape of a value. You want to also run some arbitrary check on it. You might be tempted to write this:"),(0,o.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-re"}),'switch (person) {\n| Teacher(_) => () // do nothing\n| Student({reportCard: {gpa}}) =>\n  if (gpa < 0.5) {\n    Js.log("What\'s happening")\n  } else {\n    Js.log("Heyo")\n  }\n};\n')),(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-ml"}),'let () = match person with\n| Teacher _ -> () (* do nothing *)\n| Student {reportCard = {gpa}} ->\n  if gpa < 0.5 then\n    Js.log "What\'s happening"\n  else\n    Js.log "Heyo"\n')),(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-js"}),'if (person.TAG) {\n  if (person.reportCard.gpa < 0.5) {\n    console.log("What\'s happening");\n  } else {\n    console.log("Heyo");\n  }\n}\n'))),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"switch")," patterns support a shortcut for the arbitrary ",(0,o.kt)("inlineCode",{parentName:"p"},"if")," check, to keep your pattern linear-looking:"),(0,o.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-re"}),'switch (person) {\n| Teacher(_) => () // do nothing\n| Student({reportCard: {gpa}}) when gpa < 0.5 =>\n  Js.log("What\'s happening");\n| Student(_) =>\n  // fall-through, catch-all case\n  Js.log("Heyo");\n}\n')),(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-ml"}),'let () = match person with\n| Teacher _ -> () (* do nothing *)\n| Student {reportCard = {gpa}} when gpa < 0.5 ->\n  Js.log "What\'s happening"\n| Student _ ->\n  (* fall-through, catch-all case *)\n  Js.log "Heyo"\n')),(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-js"}),'if (person.TAG) {\n  if (person.reportCard.gpa < 0.5) {\n    console.log("What\'s happening");\n  } else {\n    console.log("Heyo");\n  }\n}\n'))),(0,o.kt)("h3",s({},{id:"match-on-exceptions"}),"Match on Exceptions"),(0,o.kt)("p",null,"If the function throws an exception (covered later), you can also match on ",(0,o.kt)("em",{parentName:"p"},"that"),", in addition to the function's normally returned values."),(0,o.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-re"}),'switch (List.find(i => i === theItem, myItems)) {\n| item => Js.log(item)\n| exception Not_found => Js.log("No such item found!")\n};\n')),(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-ml"}),'let () = match List.find (fun i -> i == theItem) myItems with\n| item -> Js.log item\n| exception Not_found -> Js.log "No such item found!"\n')),(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-js"}),'var exit = 0;\n\nvar item;\n\ntry {\n  item = List.find(function(i) {\n    return i === theItem;\n  }, myItems);\n  exit = 1;\n}\ncatch (raw_exn){\n  var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);\n  if (exn.RE_EXN_ID === "Not_found") {\n    console.log("No such item found!");\n  } else {\n    throw exn;\n  }\n}\n\nif (exit === 1) {\n  console.log(item);\n}\n'))),(0,o.kt)("h3",s({},{id:"small-pitfall"}),"Small Pitfall"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Note"),": you can only pass literals (i.e. concrete values) as a pattern, not let-binding names or other things. The following doesn't work as expected:"),(0,o.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-re"}),"let coordinates = (10, 20, 30)\nlet centerY = 20\nswitch (coordinates) {\n| (x, centerY, _) => /* code */\n}\n")),(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-ml"}),"let coordinates = (10, 20, 30)\nlet centerY = 20\nlet () = match coordinates with\n| (x, centerY, _) => (* code *)\n")),(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-js"}),"var coordinates = [10, 20, 30];\nvar centerY = 20;\n\nconsole.log(10);\n"))),(0,o.kt)("p",null,"A first time ReScript user might accidentally write that code, assuming that it's matching on ",(0,o.kt)("inlineCode",{parentName:"p"},"coordinates")," when the second value is of the same value as ",(0,o.kt)("inlineCode",{parentName:"p"},"centerY"),". In reality, this is interpreted as matching on coordinates and assigning the second value of the tuple to the name ",(0,o.kt)("inlineCode",{parentName:"p"},"centerY"),", which isn't what's intended."),(0,o.kt)("h2",s({},{id:"exhaustiveness-check"}),"Exhaustiveness Check"),(0,o.kt)("p",null,"As if the above features aren't enough, ReScript also provides arguably the most important pattern matching feature: ",(0,o.kt)("strong",{parentName:"p"},"compile-time check of missing patterns"),"."),(0,o.kt)("p",null,"Let's revisit one of the above examples:"),(0,o.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-re"}),'let message = switch (person) {\n| Teacher({name: "Mary" | "Joe"}) =>\n  "Hey, still going to the party on Saturday?"\n| Student({name, reportCard: {passing: true, gpa}}) =>\n  "Congrats " ++ name ++ ", nice GPA of " ++ Js.Float.toString(gpa) ++ " you got there!"\n| Student({\n    reportCard: {gpa: 0.0},\n    status: Vacations(daysLeft) | Sabbatical(daysLeft)\n  }) =>\n  "Come back in " ++ Js.Int.toString(daysLeft) ++ " days!"\n| Student({status: Sick}) =>\n  "How are you feeling?"\n| Student({name}) =>\n  "Good luck next semester " ++ name ++ "!"\n}\n')),(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-ml"}),'let message = match person with\n| Teacher {name = "Mary" | "Joe"} ->\n  "Hey, still going to the party on Saturday?"\n| Student {name; reportCard = {passing = true; gpa}} ->\n  "Congrats " ^ name ^ ", nice GPA of " ^ (Js.Float.toString gpa) ^ " you got there!"\n| Student {\n    reportCard = {gpa = 0.0};\n    status = (Vacations daysLeft) | (Sabbatical daysLeft)\n  } ->\n  "Come back in " ^ (Js.Int.toString daysLeft) ^ " days!"\n| Student {status = Sick} ->\n    "How are you feeling?"\n| Student {name} ->\n  "Good luck next semester "^ name ^ "!"\n')),(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-js"}),'if (person.TAG) {\n  var match$1 = person.status;\n  var name = person.name;\n  var match$2 = person.reportCard;\n  if (match$2.passing) {\n    "Congrats " + name + ", nice GPA of " + match$2.gpa.toString() + " you got there!";\n  } else if (typeof match$1 === "number") {\n    if (match$1 !== 0) {\n      "Good luck next semester " + name + "!";\n    } else {\n      "How are you feeling?";\n    }\n  } else if (person.reportCard.gpa !== 0.0) {\n    "Good luck next semester " + name + "!";\n  } else {\n    "Come back in " + match$1._0.toString() + " days!";\n  }\n} else {\n  switch (person.name) {\n    case "Joe":\n    case "Mary":\n      break;\n    default:\n      throw {\n        RE_EXN_ID: "Match_failure",\n        _1: [\n          "playground.res",\n          13,\n          0\n        ],\n        Error: new Error()\n      };\n  }\n}\n'))),(0,o.kt)("p",null,"Did you see what we removed? This time, we've omitted the handling of the case where ",(0,o.kt)("inlineCode",{parentName:"p"},"person")," is ",(0,o.kt)("inlineCode",{parentName:"p"},"Teacher({name})")," when ",(0,o.kt)("inlineCode",{parentName:"p"},"name")," isn't Mary or Joe."),(0,o.kt)("p",null,"Failing to handle every scenario of a value likely constitutes the majority of program bugs out there. This happens very often when you refactor a piece of code someone else wrote. Fortunately for ReScript, the compiler will tell you so:"),(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{}),'Warning 8: this pattern-matching is not exhaustive.\nHere is an example of a value that is not matched:\nSome({name: ""})\n')),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"BAM"),"! You've just erased an entire category of important bugs before you even ran the code. In fact, this is how most of nullable values is handled:"),(0,o.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-re"}),'switch (myNullableValue) {\n| Some(v) => Js.log("value is present")\n| None => Js.log("value is absent")\n};\n')),(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-ml"}),'match myNullableValue with\n| Some v -> Js.log "value is present"\n| None -> Js.log "value is absent"\n')),(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-js"}),'if (myNullableValue !== undefined) {\n  console.log("value is present");\n} else {\n  console.log("value is absent");\n}\n'))),(0,o.kt)("p",null,"If you don't handle the ",(0,o.kt)("inlineCode",{parentName:"p"},"None")," case, the compiler warns. No more ",(0,o.kt)("inlineCode",{parentName:"p"},"undefined")," bugs in your code!"),(0,o.kt)("h2",s({},{id:"conclusion--tips--tricks"}),"Conclusion & Tips & Tricks"),(0,o.kt)("p",null,"Hopefully you can see how pattern matching is a game changer for writing correct code, through the concise destructuring syntax, the proper conditions handling of ",(0,o.kt)("inlineCode",{parentName:"p"},"switch"),", and the static exhaustiveness check."),(0,o.kt)("p",null,"Here are some advices."),(0,o.kt)("p",null,"Do not abuse the wildcard ",(0,o.kt)("inlineCode",{parentName:"p"},"_")," too much. This prevents the compiler from giving you better exhaustiveness check, which would be especially important after a refactoring where you add a new case to a variant. Try only using ",(0,o.kt)("inlineCode",{parentName:"p"},"_")," against infinite possibilities, e.g. string, int, etc."),(0,o.kt)("p",null,"Use ",(0,o.kt)("inlineCode",{parentName:"p"},"when")," clause sparingly."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Flatten your pattern-match whenever you can"),". This is a real bug remover. Here's a series of examples, from worst to best:"),(0,o.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-re"}),"let optionBoolToBool = opt => {\n  if (opt == None) {\n    false\n  } else if (opt === Some(true)) {\n    true\n  } else {\n    false\n  }\n}\n")),(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-ml"}),"let optionBoolToBool opt =\n  if opt = None\n    then false\n  else if opt == Some true then\n    true\n  else false\n")),(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-js"}),"function optionBoolToBool(opt) {\n  if (opt === undefined) {\n    return false;\n  } else {\n    return opt === true;\n  }\n}\n"))),(0,o.kt)("p",null,"Now that's just silly =). Let's turn it into pattern-matching:"),(0,o.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-re"}),"let optionBoolToBool = opt => {\n  switch (opt) {\n  | None => false\n  | Some(a) => a ? true : false\n  }\n};\n")),(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-ml"}),"let optionBoolToBool opt =\n  match opt with\n  | None -> false\n  | Some a -> if a then true else false\n")),(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-js"}),"function optionBoolToBool(opt) {\n  if (opt !== undefined && opt) {\n    return true;\n  } else {\n    return false;\n  }\n}\n"))),(0,o.kt)("p",null,"Slightly better, but still nested. Pattern-matching allows you to do this:"),(0,o.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-re"}),"let optionBoolToBool = opt => {\n  switch (opt) {\n  | None => false\n  | Some(true) => true\n  | Some(false) => false\n  }\n};\n")),(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-ml"}),"let optionBoolToBool opt =\n  match opt with\n  | None -> false\n  | Some true -> true\n  | Some false -> false\n")),(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-js"}),"function optionBoolToBool(opt) {\n  if (opt !== undefined && opt) {\n    return true;\n  } else {\n    return false;\n  }\n}\n"))),(0,o.kt)("p",null,"Much more linear-looking! Now, you might be tempted to do this:"),(0,o.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-re"}),"let optionBoolToBool = opt => {\n  switch (opt) {\n  | Some(true) => true\n  | _ => false\n  }\n};\n")),(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-ml"}),"let optionBoolToBool opt =\n  match opt with\n  | Some true -> true\n  | _ -> false\n")),(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-js"}),"function optionBoolToBool(opt) {\n  if (opt !== undefined && opt) {\n    return true;\n  } else {\n    return false;\n  }\n}\n"))),(0,o.kt)("p",null,"Which is much more concise, but kills the exhaustiveness check mentioned above; refrain from using that. This is the best:"),(0,o.kt)(p,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-re"}),"let optionBoolToBool opt =\n  match opt with\n  | Some trueOrFalse -> trueOrFalse\n  | None -> false\n")),(0,o.kt)("pre",null,(0,o.kt)("code",s({parentName:"pre"},{className:"language-js"}),"function optionBoolToBool(opt) {\n  if (opt !== undefined) {\n    return opt;\n  } else {\n    return false;\n  }\n}\n"))),(0,o.kt)("p",null,"Pretty darn hard to make a mistake in this code at this point! Whenever you'd like to use an if-else with many branches, prefer pattern matching instead. It's more concise and ",(0,o.kt)("a",s({parentName:"p"},{href:"variant#design-decisions"}),"performant")," too."))}c.isMDXComponent=!0,c.frontmatter={title:"Pattern Matching / Destructuring",description:"Pattern matching and destructuring complex data structures in ReScript",canonical:"/docs/manual/latest/pattern-matching-destructuring",__ghEditHref:"https://github.com/reason-association/rescript-lang.org/blob/master/pages/docs/manual/v8.0.0/pattern-matching-destructuring.mdx"}},78024:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/docs/manual/v8.0.0/pattern-matching-destructuring",function(){return n(80588)}])}},function(e){e.O(0,[92888,49774,40179],(function(){return t=78024,e(e.s=t);var t}));var t=e.O();_N_E=t}]);