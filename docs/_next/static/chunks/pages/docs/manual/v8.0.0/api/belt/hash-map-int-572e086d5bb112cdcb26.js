(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[59723],{17375:function(e,a,t){"use strict";function n(e,a){if(null==e)return{};var t,n,r=function(e,a){if(null==e)return{};var t,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)t=l[n],a.indexOf(t)>=0||(r[t]=e[t]);return r}(e,a);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)t=l[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}t.d(a,{Z:function(){return n}})},23619:function(e,a,t){"use strict";t.r(a),t.d(a,{default:function(){return o}});var n=t(17375),r=t(96156),l=(t(67294),t(3905));function p(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function s(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?p(Object(t),!0).forEach((function(a){(0,r.Z)(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):p(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}var i,m=(i="Intro",function(e){return console.warn("Component "+i+" was not imported, exported, or provided by MDXProvider as global scope"),(0,l.kt)("div",s({},e))}),u={};function o(e){var a=e.components,t=(0,n.Z)(e,["components"]);return(0,l.kt)("wrapper",s(s(s({},u),t),{},{components:a,mdxType:"MDXLayout"}),(0,l.kt)("h1",s({},{id:"hashmapint"}),"HashMapInt"),(0,l.kt)(m,{mdxType:"Intro"},(0,l.kt)("p",null,"Specalized when key type is ",(0,l.kt)("inlineCode",{parentName:"p"},"int"),", more efficient than the generic type")),(0,l.kt)("h2",s({},{id:"key"}),"key"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-re",metastring:"sig",sig:!0}),"type key = int;\n")),(0,l.kt)("p",null,"Type of the ",(0,l.kt)("inlineCode",{parentName:"p"},"Belt.HashMap.Int")," key."),(0,l.kt)("h2",s({},{id:"t"}),"t"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-re",metastring:"sig",sig:!0}),"type t('b);\n")),(0,l.kt)("p",null,"Type of the ",(0,l.kt)("inlineCode",{parentName:"p"},"Belt.HashMap.Int")),(0,l.kt)("h2",s({},{id:"make"}),"make"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-re",metastring:"sig",sig:!0}),"let make: (~hintSize: int) => t('b);\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"make(~hintSize=10)")," creates a new hash map by taking the ",(0,l.kt)("inlineCode",{parentName:"p"},"hintSize"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-re",metastring:"example",example:!0}),'\nlet hMap = Belt.HashMap.Int.make(~hintSize=10);\n\nBelt.HashMap.Int.set(hMap, 1, "a");\n')),(0,l.kt)("h2",s({},{id:"clear"}),"clear"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-re",metastring:"sig",sig:!0}),"let clear: t('b) => unit;\n")),(0,l.kt)("p",null,"Clears a hash table."),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-re",metastring:"example",example:!0}),'let hMap = Belt.HashMap.Int.fromArray([|(1, "1")|])  \nBelt.HashMap.Int.clear(hMap)\nBelt.HashMap.Int.isEmpty(hMap) == true;\n')),(0,l.kt)("h2",s({},{id:"isempty"}),"isEmpty"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-re",metastring:"sig",sig:!0}),"let isEmpty: t('a) => bool;\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"isEmpty(m)")," checks whether a hash map is empty."),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-re",metastring:"example",example:!0}),'let hMap = Belt.HashMap.Int.fromArray([|(1, "1")|])  \nBelt.HashMap.Int.isEmpty(hMap) == false;\n')),(0,l.kt)("h2",s({},{id:"set"}),"set"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-re",metastring:"sig",sig:!0}),"let set: (t('a), key, 'a) => unit;\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"set(tbl, k, v)")," if ",(0,l.kt)("inlineCode",{parentName:"p"},"k")," does not exist, add the binding ",(0,l.kt)("inlineCode",{parentName:"p"},"k,v"),", otherwise, update the old value with the new ",(0,l.kt)("inlineCode",{parentName:"p"},"v"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-re",metastring:"example",example:!0}),' \nlet hMap = Belt.HashMap.Int.fromArray([|(2, "2")|]);\n\nBelt.HashMap.Int.set(hMap, 1, "1");\n\nBelt.HashMap.Int.valuesToArray(hMap) == [|"1", "2"|];\n')),(0,l.kt)("h2",s({},{id:"copy"}),"copy"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-re",metastring:"sig",sig:!0}),"let copy: t('a) => t('a);\n")),(0,l.kt)("p",null,"Creates copy of a hash map."),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-re",metastring:"example",example:!0}),'let hMap1 = Belt.HashMap.Int.fromArray([|(1, "1"), (2, "2")|]);\nlet hMap2 = Belt.HashMap.Int.copy(hMap1)\n\nBelt.HashMap.Int.set(hMap2, 2, "3");\n\nBelt.HashMap.Int.get(hMap1, 2) != Belt.HashMap.Int.get(hMap2, 2)\n')),(0,l.kt)("h2",s({},{id:"get"}),"get"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-re",metastring:"sig",sig:!0}),"let get: (t('a), key) => option('a);\n")),(0,l.kt)("h2",s({},{id:"has"}),"has"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-re",metastring:"sig",sig:!0}),"let has: (t('b), key) => bool;\n")),(0,l.kt)("p",null,"Returns value bound under specific key. If values not exist returns ",(0,l.kt)("inlineCode",{parentName:"p"},"None"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-re",metastring:"example",example:!0}),'let hMap = Belt.HashMap.Int.make(~hintSize=10);\nBelt.HashMap.Int.set(hMap, 1, "value1");\n\nBelt.HashMap.Int.get(hMap, 1) == Some("value1");\nBelt.HashMap.Int.get(hMap, 2) == None;\n')),(0,l.kt)("h2",s({},{id:"remove"}),"remove"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-re",metastring:"sig",sig:!0}),"let remove: (t('a), key) => unit;\n")),(0,l.kt)("p",null,"If bound exists, removes it from the hash map."),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-re",metastring:"example",example:!0}),'let hMap = Belt.HashMap.Int.make(~hintSize=10);\nBelt.HashMap.Int.set(hMap, 1, "value1");\nBelt.HashMap.Int.remove(hMap, 1);\nBelt.HashMap.Int.has(hMap, 1) == false;\n')),(0,l.kt)("h2",s({},{id:"foreachu"}),"forEachU"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-re",metastring:"sig",sig:!0}),"let forEachU: (t('b), [@bs] ((key, 'b) => unit)) => unit;\n")),(0,l.kt)("p",null,"Same as ",(0,l.kt)("a",s({parentName:"p"},{href:"##forEach"}),"forEach")," but takes uncurried functon."),(0,l.kt)("h2",s({},{id:"foreach"}),"forEach"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-re",metastring:"sig",sig:!0}),"let forEach: (t('b), (key, 'b) => unit) => unit;\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"forEach(tbl, f)")," applies ",(0,l.kt)("inlineCode",{parentName:"p"},"f")," to all bindings in table ",(0,l.kt)("inlineCode",{parentName:"p"},"tbl"),". ",(0,l.kt)("inlineCode",{parentName:"p"},"f")," receives the key as first argument, and the associated value as second argument. Each binding is presented exactly once to ",(0,l.kt)("inlineCode",{parentName:"p"},"f"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-re",metastring:"example",example:!0}),'let hMap = Belt.HashMap.Int.make(~hintSize=10);\nBelt.HashMap.Int.set(hMap, 1, "value1");\nBelt.HashMap.Int.forEach(hMap, (key, value) => Js.log2(key, value));\n// prints ("1", "value1")\n')),(0,l.kt)("h2",s({},{id:"reduceu"}),"reduceU"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-re",metastring:"sig",sig:!0}),"let reduceU: (t('b), 'c, [@bs] (('c, key, 'b) => 'c)) => 'c;\n")),(0,l.kt)("p",null,"Same as ",(0,l.kt)("a",s({parentName:"p"},{href:"##reduce"}),"reduce")," but takes uncurried functon."),(0,l.kt)("h2",s({},{id:"reduce"}),"reduce"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-re",metastring:"sig",sig:!0}),"let reduce: (t('b), 'c, ('c, key, 'b) => 'c) => 'c;\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"reduce(tbl, init, f)")," computes ",(0,l.kt)("inlineCode",{parentName:"p"},"(f(kN, dN) ... (f(k1, d1, init))...)"),", where ",(0,l.kt)("inlineCode",{parentName:"p"},"k1 ... kN")," are the keys of all bindings in ",(0,l.kt)("inlineCode",{parentName:"p"},"tbl"),", and ",(0,l.kt)("inlineCode",{parentName:"p"},"d1 ... dN")," are the associated values. Each binding is presented exactly once to ",(0,l.kt)("inlineCode",{parentName:"p"},"f"),"."),(0,l.kt)("p",null,"The order in which the bindings are passed to ",(0,l.kt)("inlineCode",{parentName:"p"},"f")," is unspecified. However, if the table contains several bindings for the same key, they are passed to ",(0,l.kt)("inlineCode",{parentName:"p"},"f")," in reverse order of introduction, that is, the most recent binding is passed first."),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-re",metastring:"example",example:!0}),'let hMap = Belt.HashMap.Int.make(~hintSize=10);\nBelt.HashMap.Int.set(hMap, 1, "value1");\nBelt.HashMap.Int.set(hMap, 2, "value2");\n\nBelt.HashMap.Int.reduce(hMap, "", (acc, key, value) => {\n  acc ++ ", " ++ value\n}) == "value1, value2";\n')),(0,l.kt)("h2",s({},{id:"keepmapinplaceu"}),"keepMapInPlaceU"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-re",metastring:"sig",sig:!0}),"let keepMapInPlaceU: (t('a), [@bs] ((key, 'a) => option('a))) => unit;\n")),(0,l.kt)("p",null,"Same as ",(0,l.kt)("a",s({parentName:"p"},{href:"##keepMapInPlace"}),"keepMapInPlace")," but takes uncurried functon."),(0,l.kt)("h2",s({},{id:"keepmapinplace"}),"keepMapInPlace"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-re",metastring:"sig",sig:!0}),"let keepMapInPlace: (t('a), (key, 'a) => option('a)) => unit;\n")),(0,l.kt)("p",null,"Filters out values for which function ",(0,l.kt)("inlineCode",{parentName:"p"},"f")," returned ",(0,l.kt)("inlineCode",{parentName:"p"},"None"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-re",metastring:"example",example:!0}),'let hMap = Belt.HashMap.Int.make(~hintSize=10);\nBelt.HashMap.Int.set(hMap, 1, "value1");\nBelt.HashMap.Int.set(hMap, 2, "value2");\n\nBelt.HashMap.Int.keepMapInPlace(hMap, (key, value) => {\n  key mod 1 == 0 ? None : Some(value)\n});\n')),(0,l.kt)("h2",s({},{id:"size"}),"size"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-re",metastring:"sig",sig:!0}),"let size: t('a) => int;\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"size(tbl)")," returns the number of bindings in ",(0,l.kt)("inlineCode",{parentName:"p"},"tbl"),". It takes constant time."),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-re",metastring:"example",example:!0}),'let hMap = Belt.HashMap.Int.make(~hintSize=10);\nBelt.HashMap.Int.set(hMap, 1, "value1");\nBelt.HashMap.Int.set(hMap, 2, "value2");\n\nBelt.HashMap.Int.size(hMap) == 2;\n')),(0,l.kt)("h2",s({},{id:"toarray"}),"toArray"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-re",metastring:"sig",sig:!0}),"let toArray: t('a) => array((key, 'a));\n")),(0,l.kt)("p",null,"Returns array of key value pairs."),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-re",metastring:"example",example:!0}),'let hMap = Belt.HashMap.Int.make(~hintSize=10);\nBelt.HashMap.Int.set(hMap, 1, "value1");\nBelt.HashMap.Int.set(hMap, 2, "value2");\n\nBelt.HashMap.Int.toArray(hMap) == [|(1, "value1"), (2, "value2")|];\n')),(0,l.kt)("h2",s({},{id:"keystoarray"}),"keysToArray"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-re",metastring:"sig",sig:!0}),"let keysToArray: t('a) => array(key);\n")),(0,l.kt)("p",null,"Returns array of keys."),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-re",metastring:"example",example:!0}),'let hMap = Belt.HashMap.Int.make(~hintSize=10);\nBelt.HashMap.Int.set(hMap, 1, "value1");\nBelt.HashMap.Int.set(hMap, 2, "value2");\n\nBelt.HashMap.Int.keysToArray(hMap) == [|1, 2|];\n')),(0,l.kt)("h2",s({},{id:"valuestoarray"}),"valuesToArray"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-re",metastring:"sig",sig:!0}),"let valuesToArray: t('a) => array('a);\n")),(0,l.kt)("p",null,"Returns array of values."),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-re",metastring:"example",example:!0}),'let hMap = Belt.HashMap.Int.make(~hintSize=10);\nBelt.HashMap.Int.set(hMap, 1, "value1");\nBelt.HashMap.Int.set(hMap, 2, "value2");\n\nBelt.HashMap.Int.valuesToArray(hMap) == [|"value1", "value2"|];\n')),(0,l.kt)("h2",s({},{id:"fromarray"}),"fromArray"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-re",metastring:"sig",sig:!0}),"let fromArray: array((key, 'a)) => t('a);\n")),(0,l.kt)("p",null,"Creates new hash map from array of pairs."),(0,l.kt)("p",null,"Returns array of values."),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-re",metastring:"example",example:!0}),'let hMap = Belt.HashMap.Int.fromArray([|(1, "value1"), (1, "value2")|]);\nBelt.HashMap.Int.toArray(hMap) == [|(1, "value1"), (2, "value2")|];\n')),(0,l.kt)("h2",s({},{id:"mergemany"}),"mergeMany"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-re",metastring:"sig",sig:!0}),"let mergeMany: (t('a), array((key, 'a))) => unit;\n")),(0,l.kt)("p",null,"Merges many key value pairs into hash map."),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-re",metastring:"example",example:!0}),'let hMap = Belt.HashMap.Int.make(~hintSize=10);\nBelt.HashMap.Int.mergeMany(hMap, [|(1, "value1"), (2, "value2")|]);\n')),(0,l.kt)("h2",s({},{id:"getbuckethistogram"}),"getBucketHistogram"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-re",metastring:"sig",sig:!0}),"let getBucketHistogram: t('a) => array(int);\n")),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-re",metastring:"example",example:!0}),'let hMap = Belt.HashMap.Int.make(~hintSize=10);\nBelt.HashMap.Int.set(hMap, 1, "1");\n\nBelt.HashMap.Int.getBucketHistogram(hMap);\n')),(0,l.kt)("h2",s({},{id:"logstats"}),"logStats"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-re",metastring:"sig",sig:!0}),"let logStats: t('a) => unit;\n")),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-re",metastring:"example",example:!0}),'let hMap = Belt.HashMap.Int.make(~hintSize=10);\nBelt.HashMap.Int.set(hMap, 1, "1");\n\nBelt.HashMap.Int.logStats(hMap);\n')))}o.isMDXComponent=!0,o.frontmatter={__ghEditHref:"https://github.com/reason-association/rescript-lang.org/blob/master/pages/docs/manual/v8.0.0/api/belt/hash-map-int.mdx"}},10024:function(e,a,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/docs/manual/v8.0.0/api/belt/hash-map-int",function(){return t(23619)}])}},function(e){e.O(0,[92888,49774,40179],(function(){return a=10024,e(e.s=a);var a}));var a=e.O();_N_E=a}]);