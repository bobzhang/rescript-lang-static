(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[3435],{17375:function(e,t,n){"use strict";function a(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}n.d(t,{Z:function(){return a}})},82800:function(e,t,n){"use strict";n.r(t),n.d(t,{default:function(){return d}});var a=n(17375),r=n(96156),l=(n(67294),n(3905));function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){(0,r.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var p,s=(p="CodeTab",function(e){return console.warn("Component "+p+" was not imported, exported, or provided by MDXProvider as global scope"),(0,l.kt)("div",i({},e))}),c={};function d(e){var t=e.components,n=(0,a.Z)(e,["components"]);return(0,l.kt)("wrapper",i(i(i({},c),n),{},{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",i({},{id:"record"}),"Record"),(0,l.kt)("p",null,"Records are like JavaScript objects but:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"are immutable by default"),(0,l.kt)("li",{parentName:"ul"},"have fixed fields (not extensible)")),(0,l.kt)("h2",i({},{id:"type-declaration"}),"Type Declaration"),(0,l.kt)("p",null,"A record needs a mandatory type declaration:"),(0,l.kt)(s,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,l.kt)("pre",null,(0,l.kt)("code",i({parentName:"pre"},{className:"language-re"}),"type person = {\n  age: int,\n  name: string\n};\n")),(0,l.kt)("pre",null,(0,l.kt)("code",i({parentName:"pre"},{className:"language-ml"}),"type person = {\n  age: int;\n  name: string;\n}\n")),(0,l.kt)("pre",null,(0,l.kt)("code",i({parentName:"pre"},{className:"language-js"}),"// Empty output\n"))),(0,l.kt)("h2",i({},{id:"creation"}),"Creation"),(0,l.kt)("p",null,"To create a ",(0,l.kt)("inlineCode",{parentName:"p"},"person")," record (declared above):"),(0,l.kt)(s,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,l.kt)("pre",null,(0,l.kt)("code",i({parentName:"pre"},{className:"language-re"}),'let me = {\n  age: 5,\n  name: "Big ReScript"\n};\n')),(0,l.kt)("pre",null,(0,l.kt)("code",i({parentName:"pre"},{className:"language-ml"}),'let me = {\n  age = 5;\n  name = "Big ReScript";\n}\n')),(0,l.kt)("pre",null,(0,l.kt)("code",i({parentName:"pre"},{className:"language-js"}),'var me = {\n  age: 5,\n  name: "Big ReScript"\n};\n'))),(0,l.kt)("p",null,"When you create a new record value, ReScript tries to find a record type declaration that conforms to the shape of the value. So the ",(0,l.kt)("inlineCode",{parentName:"p"},"me")," value here is inferred as of type ",(0,l.kt)("inlineCode",{parentName:"p"},"person"),"."),(0,l.kt)("p",null,"The type is found by looking above the ",(0,l.kt)("inlineCode",{parentName:"p"},"me")," value. ",(0,l.kt)("strong",{parentName:"p"},"Note"),": if the type instead resides in another file or module, you need to explicitly indicate which file or module it is:"),(0,l.kt)(s,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,l.kt)("pre",null,(0,l.kt)("code",i({parentName:"pre"},{className:"language-re"}),"// School.re\ntype person = {age: int, name: string};\n")),(0,l.kt)("pre",null,(0,l.kt)("code",i({parentName:"pre"},{className:"language-ml"}),"(* School.ml *)\ntype person = {age: int; name: string}\n")),(0,l.kt)("pre",null,(0,l.kt)("code",i({parentName:"pre"},{className:"language-js"}),"// Empty output\n"))),(0,l.kt)(s,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,l.kt)("pre",null,(0,l.kt)("code",i({parentName:"pre"},{className:"language-re"}),'// Example.re\n\nlet me: School.person = {age: 20, name: "Big ReScript"};\n/* or */\nlet me2 = {School.age: 20, name: "Big ReScript"};\n')),(0,l.kt)("pre",null,(0,l.kt)("code",i({parentName:"pre"},{className:"language-ml"}),'(* Example.re *)\n\nlet me: School.person = {age = 20; name = "Big ReScript"}\n(* or *)\nlet me2 = {School.age = 20; name = "Big ReScript"}\n')),(0,l.kt)("pre",null,(0,l.kt)("code",i({parentName:"pre"},{className:"language-js"}),'var me = {\n  age: 20,\n  name: "Big ReScript"\n};\nvar me2 = {\n  age: 20,\n  name: "Big ReScript"\n};\n'))),(0,l.kt)("p",null,'Either of the above 3 says "this record\'s definition is found in the School file". The first one, the regular type annotation, is preferred.'),(0,l.kt)("h2",i({},{id:"access"}),"Access"),(0,l.kt)("p",null,"Use the familiar dot notation:"),(0,l.kt)(s,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,l.kt)("pre",null,(0,l.kt)("code",i({parentName:"pre"},{className:"language-re"}),"let name = me.name;\n")),(0,l.kt)("pre",null,(0,l.kt)("code",i({parentName:"pre"},{className:"language-ml"}),"let name = me.name\n")),(0,l.kt)("pre",null,(0,l.kt)("code",i({parentName:"pre"},{className:"language-js"}),'var name = "Big ReScript";\n'))),(0,l.kt)("h2",i({},{id:"immutable-update"}),"Immutable Update"),(0,l.kt)("p",null,"New records can be created from old records with the ",(0,l.kt)("inlineCode",{parentName:"p"},"...")," spread operator. The original record isn't mutated."),(0,l.kt)(s,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,l.kt)("pre",null,(0,l.kt)("code",i({parentName:"pre"},{className:"language-re"}),"let meNextYear = {...me, age: me.age + 1};\n")),(0,l.kt)("pre",null,(0,l.kt)("code",i({parentName:"pre"},{className:"language-ml"}),"let meNextYear = {me with age = me.age + 1}\n")),(0,l.kt)("pre",null,(0,l.kt)("code",i({parentName:"pre"},{className:"language-js"}),'var meNextYear = {\n  age: 21,\n  name: "Big ReScript"\n};\n'))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Note"),": spread cannot add new fields to the record value, as a record's shape is fixed by its type."),(0,l.kt)("h2",i({},{id:"mutable-update"}),"Mutable Update"),(0,l.kt)("p",null,"Record fields can optionally be mutable. This allows you to efficiently update those fields in-place with the ",(0,l.kt)("inlineCode",{parentName:"p"},"=")," operator."),(0,l.kt)(s,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,l.kt)("pre",null,(0,l.kt)("code",i({parentName:"pre"},{className:"language-re"}),'type person = {\n  name: string,\n  mutable age: int\n};\n\nlet baby = {name: "Baby ReScript", age: 5};\nbaby.age = baby.age + 1; // `baby.age` is now 6. Happy birthday!\n')),(0,l.kt)("pre",null,(0,l.kt)("code",i({parentName:"pre"},{className:"language-ml"}),'type person = {\n  name: string;\n  mutable age: int;\n}\n\nlet baby = {name = "Baby ReScript"; age = 5}\nlet () = baby.age <- baby.age + 1 (* `baby.age` is now 6. Happy birthday! *)\n')),(0,l.kt)("pre",null,(0,l.kt)("code",i({parentName:"pre"},{className:"language-js"}),'var baby = {\n  name: "Baby ReScript",\n  age: 5\n};\n\nbaby.age = baby.age + 1 | 0;\n'))),(0,l.kt)("h2",i({},{id:"tips--tricks"}),"Tips & Tricks"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Record Types Are Found By Field Name"),". With records, you ",(0,l.kt)("strong",{parentName:"p"},"cannot")," say \"I'd like this function to take any record type, as long as they have the field ",(0,l.kt)("inlineCode",{parentName:"p"},"age"),'". The following ',(0,l.kt)("strong",{parentName:"p"},"won't work as intended"),":"),(0,l.kt)(s,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,l.kt)("pre",null,(0,l.kt)("code",i({parentName:"pre"},{className:"language-re"}),"type person = {age: int, name: string};\ntype monster = {age: int, hasTentacles: bool};\n\nlet getAge = (entity) => entity.age;\n")),(0,l.kt)("pre",null,(0,l.kt)("code",i({parentName:"pre"},{className:"language-ml"}),"type person = {age: int; name: string}\ntype monster = {age: int; hasTentacles: bool}\n\nlet getAge entity = entity.age\n")),(0,l.kt)("pre",null,(0,l.kt)("code",i({parentName:"pre"},{className:"language-js"}),"function getAge(entity) {\n  return entity.age;\n}\n"))),(0,l.kt)("p",null,"Instead, ",(0,l.kt)("inlineCode",{parentName:"p"},"getAge")," will infer that the parameter ",(0,l.kt)("inlineCode",{parentName:"p"},"entity")," must be of type ",(0,l.kt)("inlineCode",{parentName:"p"},"monster"),", the closest record type with the field ",(0,l.kt)("inlineCode",{parentName:"p"},"age"),". The following code's last line fails:"),(0,l.kt)(s,{labels:["Reason (Old Syntax)","ML (Older Syntax)"],mdxType:"CodeTab"},(0,l.kt)("pre",null,(0,l.kt)("code",i({parentName:"pre"},{className:"language-re"}),'let kraken = {age: 9999, hasTentacles: true};\nlet me = {age: 5, name: "Baby ReScript"};\n\ngetAge(kraken);\ngetAge(me); // type error!\n')),(0,l.kt)("pre",null,(0,l.kt)("code",i({parentName:"pre"},{className:"language-ml"}),'let kraken = {age = 9999; hasTentacles = true}\nlet me = {age = 5; name = "Baby ReScript"}\n\nlet () = getAge kraken\nlet () = getAge me (* type error! *)\n'))),(0,l.kt)("p",null,"The type system will complain that ",(0,l.kt)("inlineCode",{parentName:"p"},"me")," is a ",(0,l.kt)("inlineCode",{parentName:"p"},"person"),", and that ",(0,l.kt)("inlineCode",{parentName:"p"},"getAge")," only works on ",(0,l.kt)("inlineCode",{parentName:"p"},"monster"),". If you need such capability, use ReScript objects, described ",(0,l.kt)("a",i({parentName:"p"},{href:"object.md"}),"here"),"."),(0,l.kt)("h2",i({},{id:"design-decisions"}),"Design Decisions"),(0,l.kt)("p",null,"After reading the constraints in the previous sections, and if you're coming from a dynamic language background, you might be wondering why one would bother with record in the first place instead of straight using object, since the former needs explicit typing and doesn't allow different records with the same field name to be passed to the same function, etc."),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"The truth is that most of the times in your app, your data's shape is actually fixed, and if it's not, it can potentially be better represented as a combination of variant (introduced next) + record instead."),(0,l.kt)("li",{parentName:"ol"},'Since a record type is resolved through finding that single explicit type declaration (we call this "nominal typing"), the type error messages end up better than the counterpart ("structural typing", like for tuples). This makes refactoring easier; changing a record type\'s fields naturally allows the compiler to know that it\'s still the same record, just misused in some places. Otherwise, under structural typing, it might get hard to tell whether the definition site or the usage site is wrong.')))}d.isMDXComponent=!0,d.frontmatter={title:"Record",description:"Record types in ReScript",canonical:"/docs/manual/latest/record",__ghEditHref:"https://github.com/reason-association/rescript-lang.org/blob/master/pages/docs/manual/v8.0.0/record.mdx"}},44466:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/docs/manual/v8.0.0/record",function(){return n(82800)}])}},function(e){e.O(0,[92888,49774,40179],(function(){return t=44466,e(e.s=t);var t}));var t=e.O();_N_E=t}]);