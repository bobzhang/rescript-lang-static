(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[15714],{17375:function(e,n,t){"use strict";function a(e,n){if(null==e)return{};var t,a,l=function(e,n){if(null==e)return{};var t,a,l={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(l[t]=e[t]);return l}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(l[t]=e[t])}return l}t.d(n,{Z:function(){return a}})},73947:function(e,n,t){"use strict";t.r(n),t.d(n,{default:function(){return d}});var a=t(17375),l=t(96156),o=(t(67294),t(3905));function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function p(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){(0,l.Z)(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}var i,s=(i="CodeTab",function(e){return console.warn("Component "+i+" was not imported, exported, or provided by MDXProvider as global scope"),(0,o.kt)("div",p({},e))}),u={};function d(e){var n=e.components,t=(0,a.Z)(e,["components"]);return(0,o.kt)("wrapper",p(p(p({},u),t),{},{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",p({},{id:"null-undefined-and-option"}),"Null, Undefined and Option"),(0,o.kt)("p",null,"ReScript itself doesn't have the notion of ",(0,o.kt)("inlineCode",{parentName:"p"},"null")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"undefined"),". This is a ",(0,o.kt)("em",{parentName:"p"},"great")," thing, as it wipes out an entire category of bugs. No more ",(0,o.kt)("inlineCode",{parentName:"p"},"undefined is not a function"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"cannot access someAttribute of undefined"),"!"),(0,o.kt)("p",null,"However, the ",(0,o.kt)("strong",{parentName:"p"},"concept")," of a potentially nonexistent value is still useful, and safely exists in our language."),(0,o.kt)("p",null,"We represent the existence and nonexistence of a value by wrapping it with the ",(0,o.kt)("inlineCode",{parentName:"p"},"option")," type. Here's its definition from the standard library:"),(0,o.kt)(s,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",p({parentName:"pre"},{className:"language-re"}),"type option('a) = None | Some('a);\n")),(0,o.kt)("p",null,"type 'a option = | None | Some of 'a"),(0,o.kt)("pre",null,(0,o.kt)("code",p({parentName:"pre"},{}),"```js\n// Empty output\n"))),(0,o.kt)("p",null,'It means "a value of type option is either None (representing nothing) or that actual value wrapped in a Some".'),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Note")," how the ",(0,o.kt)("inlineCode",{parentName:"p"},"option")," type is just a regular ",(0,o.kt)("a",p({parentName:"p"},{href:"variant.md"}),"variant"),"."),(0,o.kt)("h2",p({},{id:"example"}),"Example"),(0,o.kt)("p",null,"Here's a normal value:"),(0,o.kt)(s,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",p({parentName:"pre"},{className:"language-re"}),"let licenseNumber = 5;\n")),(0,o.kt)("pre",null,(0,o.kt)("code",p({parentName:"pre"},{className:"language-ml"}),"let licenseNumber = 5\n")),(0,o.kt)("pre",null,(0,o.kt)("code",p({parentName:"pre"},{className:"language-js"}),"var licenseNumber = 5;\n"))),(0,o.kt)("p",null,'To represent the concept of "maybe null", you\'d turn this into an ',(0,o.kt)("inlineCode",{parentName:"p"},"option")," type by wrapping it. For the sake of a more illustrative example, we'll put a condition around it:"),(0,o.kt)(s,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",p({parentName:"pre"},{className:"language-re"}),"let licenseNumber =\n  if (personHasACar) {\n    Some(5);\n  } else {\n    None;\n  };\n")),(0,o.kt)("pre",null,(0,o.kt)("code",p({parentName:"pre"},{className:"language-ml"}),"let licenseNumber =\n  if personHasACar then\n    Some 5\n  else\n    None\n")),(0,o.kt)("pre",null,(0,o.kt)("code",p({parentName:"pre"},{className:"language-js"}),"var licenseNumber = personHasACar ? 5 : undefined;\n"))),(0,o.kt)("p",null,"Later on, when another piece of code receives such value, it'd be forced to handle both cases through ",(0,o.kt)("a",p({parentName:"p"},{href:"pattern-matching-destructuring.md"}),"pattern matching"),":"),(0,o.kt)(s,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",p({parentName:"pre"},{className:"language-re"}),'switch (licenseNumber) {\n| None =>\n  Js.log("The person doesn\'t have a car");\n| Some(number) =>\n  Js.log("The person\'s license number is " ++ Js.Int.toString(number));\n};\n')),(0,o.kt)("pre",null,(0,o.kt)("code",p({parentName:"pre"},{className:"language-ml"}),'let () = match licenseNumber with\n| None ->\n  Js.log "The person doesn\'t have a car"\n| Some number ->\n  Js.log ("The person\'s license number is " ^ (Js.Int.toString number))\n')),(0,o.kt)("pre",null,(0,o.kt)("code",p({parentName:"pre"},{className:"language-js"}),'var number = licenseNumber;\n\nif (number !== undefined) {\n  console.log("The person\'s license number is " + number.toString());\n} else {\n  console.log("The person doesn\'t have a car");\n}\n'))),(0,o.kt)("p",null,"By turning your ordinary number into an ",(0,o.kt)("inlineCode",{parentName:"p"},"option")," type, and by forcing you to handle the ",(0,o.kt)("inlineCode",{parentName:"p"},"None")," case, the language effectively removed the possibility for you to mishandle, or forget to handle, a conceptual ",(0,o.kt)("inlineCode",{parentName:"p"},"null")," value! ",(0,o.kt)("strong",{parentName:"p"},"A pure ReScript program doesn't have null errors"),"."),(0,o.kt)("h2",p({},{id:"interoperate-with-javascript-undefined-and-null"}),"Interoperate with JavaScript ",(0,o.kt)("inlineCode",{parentName:"h2"},"undefined")," and ",(0,o.kt)("inlineCode",{parentName:"h2"},"null")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"option")," type is common enough that we special-case it when compiling to JavaScript:"),(0,o.kt)(s,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",p({parentName:"pre"},{className:"language-re"}),"let x = Some(5);\n")),(0,o.kt)("pre",null,(0,o.kt)("code",p({parentName:"pre"},{className:"language-ml"}),"let x = Some 5\n")),(0,o.kt)("pre",null,(0,o.kt)("code",p({parentName:"pre"},{className:"language-js"}),"var x = 5;\n"))),(0,o.kt)("p",null,"simply compiles down to ",(0,o.kt)("inlineCode",{parentName:"p"},"5"),", and"),(0,o.kt)(s,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",p({parentName:"pre"},{className:"language-re"}),"let x = None;\n")),(0,o.kt)("pre",null,(0,o.kt)("code",p({parentName:"pre"},{className:"language-ml"}),"let x = None\n")),(0,o.kt)("pre",null,(0,o.kt)("code",p({parentName:"pre"},{className:"language-js"}),"var x;\n"))),(0,o.kt)("p",null,"compiles to ",(0,o.kt)("inlineCode",{parentName:"p"},"undefined"),"! If you've got e.g. a string in JavaScript that you know might be ",(0,o.kt)("inlineCode",{parentName:"p"},"undefined"),", type it as ",(0,o.kt)("inlineCode",{parentName:"p"},"option(string)")," and you're done! Likewise, you can send a ",(0,o.kt)("inlineCode",{parentName:"p"},"Some(5)")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"None")," to the JS side and expect it to be interpreted correctly =)"),(0,o.kt)("h3",p({},{id:"caveat-1"}),"Caveat 1"),(0,o.kt)("p",null,"The option-to-undefined translation isn't perfect, because on our side, ",(0,o.kt)("inlineCode",{parentName:"p"},"option")," values can be composed:"),(0,o.kt)(s,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",p({parentName:"pre"},{className:"language-re"}),"let x = Some(Some(Some(5)));\n")),(0,o.kt)("pre",null,(0,o.kt)("code",p({parentName:"pre"},{className:"language-ml"}),"let x = Some (Some (Some 5))\n")),(0,o.kt)("pre",null,(0,o.kt)("code",p({parentName:"pre"},{className:"language-js"}),"var x = 5;\n"))),(0,o.kt)("p",null,"This still compiles to ",(0,o.kt)("inlineCode",{parentName:"p"},"5"),", but this gets troublesome:"),(0,o.kt)(s,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",p({parentName:"pre"},{className:"language-re"}),"let x = Some(None);\n")),(0,o.kt)("pre",null,(0,o.kt)("code",p({parentName:"pre"},{className:"language-ml"}),"let x = Some None\n")),(0,o.kt)("pre",null,(0,o.kt)("code",p({parentName:"pre"},{className:"language-js"}),'var Caml_option = require("./stdlib/caml_option.js");\n\nvar x = Caml_option.some(undefined);\n')),(0,o.kt)("p",null,"(See output tab).")),(0,o.kt)("p",null,"What's this ",(0,o.kt)("inlineCode",{parentName:"p"},"Caml_option.some")," thing? Why can't this compile to ",(0,o.kt)("inlineCode",{parentName:"p"},"undefined"),"? Long story short, when dealing with a polymorphic ",(0,o.kt)("inlineCode",{parentName:"p"},"option")," type (aka ",(0,o.kt)("inlineCode",{parentName:"p"},"option('a)"),", for any ",(0,o.kt)("inlineCode",{parentName:"p"},"'a"),"), many operations become tricky if we don't mark the value with some special annotation. If this doesn't make sense, don't worry; just remember the following rule:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Never, EVER, pass a nested ",(0,o.kt)("inlineCode",{parentName:"strong"},"option")," value (e.g. ",(0,o.kt)("inlineCode",{parentName:"strong"},"Some(Some(Some(5)))"),") into the JS side.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Never, EVER, annotate a value coming from JS as ",(0,o.kt)("inlineCode",{parentName:"strong"},"option('a)"),". Always give the concrete, non-polymorphic type."))),(0,o.kt)("h3",p({},{id:"caveat-2"}),"Caveat 2"),(0,o.kt)("p",null,"Unfortunately, lots of times, your JavaScript value might be ",(0,o.kt)("em",{parentName:"p"},"both")," ",(0,o.kt)("inlineCode",{parentName:"p"},"null")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"undefined"),". In that case, you unfortunately can't type such value as e.g. ",(0,o.kt)("inlineCode",{parentName:"p"},"option(int)"),", since our ",(0,o.kt)("inlineCode",{parentName:"p"},"option")," type only checks for ",(0,o.kt)("inlineCode",{parentName:"p"},"undefined")," and not ",(0,o.kt)("inlineCode",{parentName:"p"},"null")," when dealing with a ",(0,o.kt)("inlineCode",{parentName:"p"},"None"),"."),(0,o.kt)("h4",p({},{id:"solution-more-sophisticated-undefined--null-interop"}),"Solution: More Sophisticated ",(0,o.kt)("inlineCode",{parentName:"h4"},"undefined")," & ",(0,o.kt)("inlineCode",{parentName:"h4"},"null")," Interop"),(0,o.kt)("p",null,"To solve this, we provide access to more elaborate ",(0,o.kt)("inlineCode",{parentName:"p"},"null")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"undefined")," helpers through the ",(0,o.kt)("a",p({parentName:"p"},{href:"api/js/nullable"}),(0,o.kt)("inlineCode",{parentName:"a"},"Js.Nullable"))," module. This somewhat works like an ",(0,o.kt)("inlineCode",{parentName:"p"},"option")," type, but is different from it."),(0,o.kt)("h4",p({},{id:"examples"}),"Examples"),(0,o.kt)("p",null,"To create a JS ",(0,o.kt)("inlineCode",{parentName:"p"},"null"),", use the value ",(0,o.kt)("inlineCode",{parentName:"p"},"Js.Nullable.null"),". To create a JS ",(0,o.kt)("inlineCode",{parentName:"p"},"undefined"),", use ",(0,o.kt)("inlineCode",{parentName:"p"},"Js.Nullable.undefined")," (you can naturally use ",(0,o.kt)("inlineCode",{parentName:"p"},"None")," too, but that's not the point here; the ",(0,o.kt)("inlineCode",{parentName:"p"},"Js.Nullable.*")," helpers wouldn't work with it)."),(0,o.kt)("p",null,"If you're receiving, for example, a JS string that can be ",(0,o.kt)("inlineCode",{parentName:"p"},"null")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"undefined"),", type it as:"),(0,o.kt)(s,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",p({parentName:"pre"},{className:"language-re"}),'[@bs.module "MyConstant"] external myId: Js.Nullable.t(string) = "myId";\n')),(0,o.kt)("pre",null,(0,o.kt)("code",p({parentName:"pre"},{className:"language-ml"}),'external myId: string Js.Nullable.t = "myId" [@@bs.module "MyConstant"]\n')),(0,o.kt)("pre",null,(0,o.kt)("code",p({parentName:"pre"},{className:"language-js"}),"// Empty output\n"))),(0,o.kt)("p",null,"To create such a nullable string from our side (presumably to pass it to the JS side, for interop purpose), do:"),(0,o.kt)(s,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",p({parentName:"pre"},{className:"language-re"}),'[@bs.module "MyIdValidator"] external validate: Js.Nullable.t(string) => bool = "validate";\nlet personId: Js.Nullable.t(string) = Js.Nullable.return("abc123");\n\nlet result = validate(personId);\n')),(0,o.kt)("pre",null,(0,o.kt)("code",p({parentName:"pre"},{className:"language-ml"}),'external validate: string Js.Nullable.t -> bool = "validate" [@@bs.module "MyIdValidator"]\nlet personId: string Js.Nullable.t = Js.Nullable.return "abc123"\n\nlet result = validate personId\n')),(0,o.kt)("pre",null,(0,o.kt)("code",p({parentName:"pre"},{className:"language-js"}),'var MyIdValidator = require("MyIdValidator");\nvar personId = "abc123";\nvar result = MyIdValidator.validate(personId);\n'))),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"return"),' part "wraps" a string into a nullable string, to make the type system understand and track the fact that, as you pass this value around, it\'s not just a string, but a string that can be ',(0,o.kt)("inlineCode",{parentName:"p"},"null")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"undefined"),"."),(0,o.kt)("h4",p({},{id:"convert-tofrom-option"}),"Convert to/from ",(0,o.kt)("inlineCode",{parentName:"h4"},"option")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"Js.Nullable.fromOption")," converts from a ",(0,o.kt)("inlineCode",{parentName:"p"},"option")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"Js.Nullable.t"),". ",(0,o.kt)("inlineCode",{parentName:"p"},"Js.Nullable.toOption")," does the opposite."))}d.isMDXComponent=!0,d.frontmatter={title:"Null, Undefined and Option",description:"JS interop with nullable and optional values in ReScript",canonical:"/docs/manual/latest/null-undefined-option",__ghEditHref:"https://github.com/reason-association/rescript-lang.org/blob/master/pages/docs/manual/v8.0.0/null-undefined-option.mdx"}},52170:function(e,n,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/docs/manual/v8.0.0/null-undefined-option",function(){return t(73947)}])}},function(e){e.O(0,[92888,49774,40179],(function(){return n=52170,e(e.s=n);var n}));var n=e.O();_N_E=n}]);