(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[33139],{17375:function(e,n,a){"use strict";function t(e,n){if(null==e)return{};var a,t,l=function(e,n){if(null==e)return{};var a,t,l={},r=Object.keys(e);for(t=0;t<r.length;t++)a=r[t],n.indexOf(a)>=0||(l[a]=e[a]);return l}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(t=0;t<r.length;t++)a=r[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(l[a]=e[a])}return l}a.d(n,{Z:function(){return t}})},6053:function(e,n,a){"use strict";a.r(n),a.d(n,{default:function(){return c}});var t=a(17375),l=a(96156),r=(a(67294),a(3905));function o(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,t)}return a}function s(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?o(Object(a),!0).forEach((function(n){(0,l.Z)(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}var i,u=(i="CodeTab",function(e){return console.warn("Component "+i+" was not imported, exported, or provided by MDXProvider as global scope"),(0,r.kt)("div",s({},e))}),p={};function c(e){var n=e.components,a=(0,t.Z)(e,["components"]);return(0,r.kt)("wrapper",s(s(s({},p),a),{},{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",s({},{id:"lazy-values"}),"Lazy Values"),(0,r.kt)("p",null,"A lazy value represents a deferred computation which will automatically memoize the result on the first run, and then return the memoized result on any repeated execution."),(0,r.kt)("p",null,"This is useful for defining functions and expressions for complex procedures that always return the same value, for example:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Doing expensive DOM traversals over the same tree over and over again"),(0,r.kt)("li",{parentName:"ul"},"Doing file system operations on a static set of files that won't change"),(0,r.kt)("li",{parentName:"ul"},"Doing expensive requests to an API server that would always return the same data")),(0,r.kt)("p",null,"A lazy value has a type of ",(0,r.kt)("inlineCode",{parentName:"p"},"Lazy.t('a)"),", where ",(0,r.kt)("inlineCode",{parentName:"p"},"'a")," is the return value of the computation. All its functionality is encapsulated with the globally available ",(0,r.kt)("inlineCode",{parentName:"p"},"Lazy")," module."),(0,r.kt)("h2",s({},{id:"creating-a-lazy-value"}),"Creating a lazy value"),(0,r.kt)("p",null,"Lazy values are part of the language. You can either use the ",(0,r.kt)("inlineCode",{parentName:"p"},"lazy")," keyword to create a lazy value from an expression..."),(0,r.kt)(u,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,r.kt)("pre",null,(0,r.kt)("code",s({parentName:"pre"},{className:"language-re",metastring:"example",example:!0}),'// We only want getFiles to read the file system once,\n// so we wrap it in a lazy value\nlet getFiles =\n  lazy({\n    Js.log("Reading dir");\n    Node.Fs.readdirSync("./pages");\n  });\n\n// On the first call, the computation takes place\nLazy.force(getFiles)->Js.log;\n\n// The second call will just return the already calculated files\nLazy.force(getFiles)->Js.log;\n')),(0,r.kt)("pre",null,(0,r.kt)("code",s({parentName:"pre"},{className:"language-ml"}),'(* We only want getFiles to read the file system once, *)\n(* so we wrap it in a lazy value *)\nlet getFiles = lazy (\n  Js.log "Reading dir";\n  Node.Fs.readdirSync "./pages"\n)\n\n(* On the first call, the computation takes place *)\nlet () = (Lazy.force getFiles) |. Js.log\n\n(* The second call will just return the already calculated files *)\nlet () = (Lazy.force getFiles) |. Js.log\n')),(0,r.kt)("pre",null,(0,r.kt)("code",s({parentName:"pre"},{className:"language-js"}),'var Fs = require("fs");\nvar CamlinternalLazy = require("./stdlib/camlinternalLazy.js");\n\nvar getFiles = {\n  LAZY_DONE: false,\n  VAL: function () {\n    console.log("Reading dir");\n    return Fs.readdirSync("./pages");\n  },\n};\n\nconsole.log(CamlinternalLazy.force(getFiles));\nconsole.log(CamlinternalLazy.force(getFiles));\n'))),(0,r.kt)("p",null,"...or you can also wrap an existing function to make it lazy:"),(0,r.kt)(u,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,r.kt)("pre",null,(0,r.kt)("code",s({parentName:"pre"},{className:"language-re",metastring:"example",example:!0}),'// Example for wrapping a function with 0 parameters\nlet getFiles = () => {\n  Node.Fs.readdirSync("./pages");\n};\n\n// Here we wrap our function in the lazy value\nlet lazyGetFiles = Lazy.from_fun(getFiles);\n')),(0,r.kt)("pre",null,(0,r.kt)("code",s({parentName:"pre"},{className:"language-ml"}),'(* Example for wrapping a function with 0 parameters *)\nlet getFiles () =\n  Node.Fs.readdirSync "./pages"\n\n(* Here we wrap our function in the lazy value *)\nlet lazyGetFiles = Lazy.from_fun getFiles\n')),(0,r.kt)("pre",null,(0,r.kt)("code",s({parentName:"pre"},{className:"language-js"}),'var Fs = require("fs");\nvar Lazy = require("./stdlib/lazy.js");\n\nfunction getFiles(param) {\n  return Fs.readdirSync("./pages");\n}\n\nvar lazyGetFiles = Lazy.from_fun(getFiles);\n'))),(0,r.kt)(u,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,r.kt)("pre",null,(0,r.kt)("code",s({parentName:"pre"},{className:"language-re",metastring:"example",example:!0}),'// Example for wrapping a function with parameters\nlet doesFileExist = name => {\n  Node.Fs.readdirSync("./pages")->Js.Array2.find(s => name === s);\n};\n\n// Here we use the lazy syntax again\n// since we can\'t use Lazy.from_fun\nlet lazyDoesFileExist = lazy(doesFileExist("blog.re"));\n')),(0,r.kt)("pre",null,(0,r.kt)("code",s({parentName:"pre"},{className:"language-ml"}),'(* Example for wrapping a function with parameters *)\nlet doesFileExist name =\n  Node.Fs.readdirSync "./pages" |. Js.Array2.find(fun s -> name == s)\n\n(* Here we use the lazy syntax again *)\n(* since we can\'t use Lazy.from_fun *)\nlet lazyDoesFileExist = lazy(doesFileExist "blog.re")\n')),(0,r.kt)("pre",null,(0,r.kt)("code",s({parentName:"pre"},{className:"language-js"}),'var Fs = require("fs");\nvar Caml_option = require("./stdlib/caml_option.js");\n\nfunction doesFileExist(name) {\n  return Caml_option.undefined_to_opt(\n    Fs.readdirSync("./pages").find(function (s) {\n      return name === s;\n    })\n  );\n}\n\nvar lazyDoesFileExist = {\n  LAZY_DONE: false,\n  VAL: function () {\n    return doesFileExist("blog.re");\n  },\n};\n'))),(0,r.kt)("p",null,"Whenever we want to wrap a function ",(0,r.kt)("inlineCode",{parentName:"p"},"unit => 'a"),", we use ",(0,r.kt)("inlineCode",{parentName:"p"},"Lazy.from_fun"),", otherwise we use the ",(0,r.kt)("inlineCode",{parentName:"p"},"lazy(expr)")," keyword to wrap an expression or a function with 1 or more arguments."),(0,r.kt)("h2",s({},{id:"force-a-lazy-computation"}),"Force a lazy computation"),(0,r.kt)("p",null,"Lazy values need to be explicitly executed to be able to return a value. Use the ",(0,r.kt)("inlineCode",{parentName:"p"},"Lazy.force"),"to start the execution:"),(0,r.kt)(u,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,r.kt)("pre",null,(0,r.kt)("code",s({parentName:"pre"},{className:"language-re",metastring:"example",example:!0}),"let computation = lazy(1);\n\n// Returns 1\nLazy.force(computation);\n")),(0,r.kt)("pre",null,(0,r.kt)("code",s({parentName:"pre"},{className:"language-ml"}),"let computation = lazy 1;\n\n(* Returns 1 *)\nLazy.force computation\n")),(0,r.kt)("pre",null,(0,r.kt)("code",s({parentName:"pre"},{className:"language-js"}),'var CamlinternalLazy = require("./stdlib/camlinternalLazy.js");\n\nvar computation = {\n  LAZY_DONE: true,\n  VAL: 1,\n};\n\nCamlinternalLazy.force(computation);\n'))),(0,r.kt)("p",null,"It is also possible to use pattern matching to force a lazy value to compute, this includes ",(0,r.kt)("inlineCode",{parentName:"p"},"switch")," expressions and similar syntax such as tuple destructuring:"),(0,r.kt)(u,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,r.kt)("pre",null,(0,r.kt)("code",s({parentName:"pre"},{className:"language-re",metastring:"example",example:!0}),'// Extract a lazy value via pattern matching\nlet computation = lazy("computed");\n\nswitch computation {\n| lazy("computed") => Js.log("ok")\n| _ => Js.log("not ok")\n};\n')),(0,r.kt)("pre",null,(0,r.kt)("code",s({parentName:"pre"},{className:"language-ml"}),'(* Extract a lazy value via pattern matching *)\nlet computation = lazy "computed"\n\nlet () = match computation with\n| lazy "computed" -> Js.log "ok"\n| _ -> Js.log "not ok"\n')),(0,r.kt)("pre",null,(0,r.kt)("code",s({parentName:"pre"},{className:"language-js"}),'var CamlinternalLazy = require("./stdlib/camlinternalLazy.js");\n\nvar computation = {\n  LAZY_DONE: true,\n  VAL: "computed",\n};\n\nvar match = CamlinternalLazy.force(computation);\n\nif (match === "computed") {\n  console.log("ok");\n} else {\n  console.log("not ok");\n}\n'))),(0,r.kt)(u,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,r.kt)("pre",null,(0,r.kt)("code",s({parentName:"pre"},{className:"language-re",metastring:"example",example:!0}),'// Destructuring a single value\n// Note: currently the formatter will reprint this\n//       as `let lazy word = ...`\nlet lazy(word) = lazy("hello");\n\n// Output: "hello"\nJs.log(word);\n')),(0,r.kt)("pre",null,(0,r.kt)("code",s({parentName:"pre"},{className:"language-ml"}),'let lazy word = lazy "hello"\n\n(* Output: "hello" *)\nJs.log word\n')),(0,r.kt)("pre",null,(0,r.kt)("code",s({parentName:"pre"},{className:"language-js"}),'var CamlinternalLazy = require("./stdlib/camlinternalLazy.js");\n\nvar match = {\n  LAZY_DONE: true,\n  VAL: "hello",\n};\n\nvar word = CamlinternalLazy.force(match);\n\nconsole.log(word);\n'))),(0,r.kt)(u,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,r.kt)("pre",null,(0,r.kt)("code",s({parentName:"pre"},{className:"language-re",metastring:"example",example:!0}),'// Destructing a tuple\nlet lazyValues = (lazy("hello"), lazy("world"));\nlet (lazy(word1), lazy(word2)) = lazyValues;\n\n// Output: "hello world"\nJs.log2(word1, word2);\nlet lazy(word) = lazy("hello");\n')),(0,r.kt)("pre",null,(0,r.kt)("code",s({parentName:"pre"},{className:"language-ml"}),'(* Destructing a tuple *)\nlet lazyValues = (lazy "hello", lazy "world")\nlet (lazy word1, lazy word2) = lazyValues\n\n(* Output: "hello world" *)\nJs.log2(word1, word2)\nlet lazy word = lazy "hello"\n')),(0,r.kt)("pre",null,(0,r.kt)("code",s({parentName:"pre"},{className:"language-js"}),'var CamlinternalLazy = require("./stdlib/camlinternalLazy.js");\n\nvar lazyValues_0 = {\n  LAZY_DONE: true,\n  VAL: "hello",\n};\n\nvar lazyValues_1 = {\n  LAZY_DONE: true,\n  VAL: "world",\n};\n\nvar lazyValues = [lazyValues_0, lazyValues_1];\n\nvar word1 = CamlinternalLazy.force(lazyValues_0);\n\nvar word2 = CamlinternalLazy.force(lazyValues_1);\n\nconsole.log(word1, word2);\n\nvar match = {\n  LAZY_DONE: true,\n  VAL: "hello",\n};\n\nvar word = CamlinternalLazy.force(match);\n'))),(0,r.kt)("p",null,"As you can see, the ",(0,r.kt)("inlineCode",{parentName:"p"},"lazy")," syntax is a really great way for creating and handling lazy computations!"),(0,r.kt)("h2",s({},{id:"exception-handling"}),"Exception handling"),(0,r.kt)("p",null,"Whenever a lazy value computation raises an exception, the same exception will be thrown by ",(0,r.kt)("inlineCode",{parentName:"p"},"Lazy.force"),"."),(0,r.kt)(u,{labels:["Reason (Old Syntax)","ML (Older Syntax)","JS Output"],mdxType:"CodeTab"},(0,r.kt)("pre",null,(0,r.kt)("code",s({parentName:"pre"},{className:"language-re",metastring:"example",example:!0}),'let readFile =\n  lazy({\n    raise(Not_found)\n  });\n\ntry (Lazy.force(readFile)) {\n| Not_found => Js.log("No file")\n};\n')),(0,r.kt)("pre",null,(0,r.kt)("code",s({parentName:"pre"},{className:"language-ml"}),'let readFile = lazy (raise Not_found)\nlet () = try Lazy.force readFile with\n| Not_found -> Js.log "No file"\n')),(0,r.kt)("pre",null,(0,r.kt)("code",s({parentName:"pre"},{className:"language-js"}),'var CamlinternalLazy = require("./stdlib/camlinternalLazy.js");\nvar Caml_js_exceptions = require("./stdlib/caml_js_exceptions.js");\n\nvar readFile = {\n  LAZY_DONE: false,\n  VAL: function () {\n    throw {\n      RE_EXN_ID: "Not_found",\n      Error: new Error(),\n    };\n  },\n};\n\ntry {\n  CamlinternalLazy.force(readFile);\n} catch (raw_exn) {\n  var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);\n  if (exn.RE_EXN_ID === "Not_found") {\n    console.log("No file");\n  } else {\n    throw exn;\n  }\n}\n'))),(0,r.kt)("p",null,"Nothing new here, since we are using the ",(0,r.kt)("inlineCode",{parentName:"p"},"try")," expression to match the exception raised in the lazy computation!"),(0,r.kt)("p",null,"Please remember: Exceptions should be used sparsely!"),(0,r.kt)("h2",s({},{id:"notes"}),"Notes"),(0,r.kt)("p",null,"A lazy value is ",(0,r.kt)("strong",{parentName:"p"},"not")," a ",(0,r.kt)("a",s({parentName:"p"},{href:"shared-data-types.md"}),"shared data type"),". Don't rely on the runtime representation on the JS side."))}c.isMDXComponent=!0,c.frontmatter={title:"Lazy Values",description:"Data type for deferred computation in ReScript",canonical:"/docs/manual/latest/lazy-values",__ghEditHref:"https://github.com/reason-association/rescript-lang.org/blob/master/pages/docs/manual/v8.0.0/lazy-values.mdx"}},80159:function(e,n,a){(window.__NEXT_P=window.__NEXT_P||[]).push(["/docs/manual/v8.0.0/lazy-values",function(){return a(6053)}])}},function(e){e.O(0,[92888,49774,40179],(function(){return n=80159,e(e.s=n);var n}));var n=e.O();_N_E=n}]);