(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[86999],{17375:function(e,t,n){"use strict";function i(e,t){if(null==e)return{};var n,i,r=function(e,t){if(null==e)return{};var n,i,r={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}n.d(t,{Z:function(){return i}})},90927:function(e,t,n){"use strict";n.d(t,{Z:function(){return r}});var i=n(67294);var r=function(e){var t=e.src,n=e.withShadow,r=e.caption,a=void 0!==n&&n?"shadow-md":"";return i.createElement("div",{className:"mt-8 mb-12 md:-mx-16"},i.createElement("a",{href:t,rel:"noopener noreferrer",target:"_blank"},i.createElement("img",{className:"w-full "+a,src:t})),void 0!==r?i.createElement("div",{className:"mt-4 text-14 text-gray-60 md:ml-16"},r):null)}},77629:function(e,t,n){"use strict";n.r(t),n.d(t,{default:function(){return p}});var i=n(96156),r=n(17375),a=(n(67294),n(3905)),o=n(90927);function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){(0,i.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var u={};function p(e){var t=e.components,n=(0,r.Z)(e,["components"]);return(0,a.kt)("wrapper",s(s(s({},u),n),{},{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",s({},{id:"build-performance"}),"Build Performance"),(0,a.kt)("p",null,"ReScript considers performance at install time, build time and run time as a serious feature; it's one of those things you don't notice until you realize it's missing."),(0,a.kt)("h2",s({},{id:"profile-your-build"}),"Profile Your Build"),(0,a.kt)("p",null,"Sometime your build can be slow due to some confused infra setups. We provide an interactive visualization of your build's performance via ",(0,a.kt)("inlineCode",{parentName:"p"},"bstracing"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",s({parentName:"pre"},{className:"language-sh"}),"./node_modules/.bin/bstracing\n")),(0,a.kt)("p",null,"Run the above command at your ReScript project's root; it'll spit out a JSON file you can drag and drop into ",(0,a.kt)("inlineCode",{parentName:"p"},"chrome://tracing"),"."),(0,a.kt)(o.Z,{withShadow:!0,src:"/static/img/bstracing.png",caption:"Screenshot of bstracing result",mdxType:"Image"}),(0,a.kt)("h2",s({},{id:"under-the-hood"}),"Under the Hood"),(0,a.kt)("p",null,"ReScript itself uses a build system under the hood, called ",(0,a.kt)("a",s({parentName:"p"},{href:"https://ninja-build.org"}),"Ninja"),". Ninja is like Make, but cross-platform, minimal, focuses in perf and destined to be more of a low-level building block than a full-blown build system. In this regard, Ninja's a great implementation detail for ",(0,a.kt)("inlineCode",{parentName:"p"},"rescript"),"."),(0,a.kt)("p",null,"ReScript reads into ",(0,a.kt)("inlineCode",{parentName:"p"},"bsconfig.json")," and generates the Ninja build file in ",(0,a.kt)("inlineCode",{parentName:"p"},"lib/bs"),". The file contains the low-level compiler commands, namespacing rules, intermediate artifacts generation & others. It then runs ",(0,a.kt)("inlineCode",{parentName:"p"},"ninja")," for the actual build."),(0,a.kt)("h2",s({},{id:"the-js-wrapper"}),"The JS Wrapper"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"rescript")," itself is a Node.js wrapper which takes care of some miscellaneous tasks, plus the watcher. The lower-level, watcher-less, fast native ",(0,a.kt)("inlineCode",{parentName:"p"},"rescript")," is called ",(0,a.kt)("inlineCode",{parentName:"p"},"rescript.exe"),". It's located at ",(0,a.kt)("inlineCode",{parentName:"p"},"node_modules/rescript/{your-platform}/rescript.exe"),"."),(0,a.kt)("p",null,"If you don't need the watcher, you can run said ",(0,a.kt)("inlineCode",{parentName:"p"},"rescript.exe"),". This side-steps Node.js' long startup time, which can be in the order of ",(0,a.kt)("inlineCode",{parentName:"p"},"100ms"),". Our editor plugin finds and uses this native ",(0,a.kt)("inlineCode",{parentName:"p"},"rescript.exe")," for better performance."),(0,a.kt)("h2",s({},{id:"numbers"}),"Numbers"),(0,a.kt)("p",null,"Raw ",(0,a.kt)("inlineCode",{parentName:"p"},"rescript.exe")," build on a small project should be around ",(0,a.kt)("inlineCode",{parentName:"p"},"70ms"),". This doubles when you use the JS ",(0,a.kt)("inlineCode",{parentName:"p"},"rescript")," wrapper which comes with a watcher, which is practically faster since you don't manually run the build at every change (though you should opt for the raw ",(0,a.kt)("inlineCode",{parentName:"p"},"rescript.exe")," for programmatic usage, e.g. inserting rescript into your existing JS build pipeline)."),(0,a.kt)("p",null,"No-op build (when no file's changed) should be around ",(0,a.kt)("inlineCode",{parentName:"p"},"15ms"),". Incremental rebuild (described soon) of a single file in a project is around ",(0,a.kt)("inlineCode",{parentName:"p"},"70ms")," too."),(0,a.kt)("p",null,"Cleaning the artifacts should be instantaneous."),(0,a.kt)("h3",s({},{id:"extreme-test"}),"Extreme Test"),(0,a.kt)("p",null,"We've stress-tested ",(0,a.kt)("inlineCode",{parentName:"p"},"rescript.exe")," on a big project of 10,000 files (2 directories, 5000 files each, first 5000 no dependencies, last 5000 10 dependencies on files from the former directory) using ",(0,a.kt)("a",s({parentName:"p"},{href:"https://github.com/rescript-lang/build-benchmark"}),"https://github.com/rescript-lang/build-benchmark"),", on a Retina Macbook Pro Early 2015 (3.1 GHz Intel Core i7)."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"No-op build of 10k files: ",(0,a.kt)("inlineCode",{parentName:"li"},"800ms")," (the minimum amount of time required to check the mtimes of 10k files)."),(0,a.kt)("li",{parentName:"ul"},"Clean build: <3 minutes."),(0,a.kt)("li",{parentName:"ul"},"Incremental build: depends on the number of the dependents of the file. No dependent means ",(0,a.kt)("inlineCode",{parentName:"li"},"1s"),".")),(0,a.kt)("h3",s({},{id:"stability"}),"Stability"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"rescript")," is a file-based build system. We don't do in-memory build, even if that speeds up the build a lot. In-memory builds risk memory leaks, out-of-memory errors, corrupt halfway build and others. Our watcher mode stays open for days or months with no leak."),(0,a.kt)("p",null,"The watcher is also just a thin file watcher that calls ",(0,a.kt)("inlineCode",{parentName:"p"},"rescript.exe"),". We don't like babysitting daemon processes."),(0,a.kt)("h2",s({},{id:"incrementality--correctness"}),"Incrementality & Correctness"),(0,a.kt)("p",null,"ReScript doesn't take whole seconds to run every time. The bulk of the build performance comes from incremental build, aka re-building a previously built project when a few files changed."),(0,a.kt)("p",null,"In short, thanks to our compiler and the build system's architecture, we're able to ",(0,a.kt)("strong",{parentName:"p"},"only build what's needed"),". E.g. if ",(0,a.kt)("inlineCode",{parentName:"p"},"MyFile.res")," isn't changed, then it's not recompiled. You can roughly emulate such incrementalism in languages like JavaScript, but the degree of correctness is unfortunately low. For example, if you rename or move a JS file, then the watcher might get confused and not pick up the \"new\" file or fail to clean things up correctly, resulting in you needing to clean your build and restart anew, which defeats the purpose."),(0,a.kt)("p",null,"Say goodbye to stale build from your JavaScript ecosystem!"),(0,a.kt)("h2",s({},{id:"speed-up-incremental-build"}),"Speed Up Incremental Build"),(0,a.kt)("p",null,"ReScript uses the concept of interface files (",(0,a.kt)("inlineCode",{parentName:"p"},".resi"),") (or, equivalently, ",(0,a.kt)("a",s({parentName:"p"},{href:"module.md#signatures"}),"module signatures"),"). Exposing only what you need naturally speeds up incremental builds. E.g. if you change a ",(0,a.kt)("inlineCode",{parentName:"p"},".res")," file whose corresponding ",(0,a.kt)("inlineCode",{parentName:"p"},".resi")," file doesn't expose the changed part, then you've reduced the amount of dependent files you have to rebuild."),(0,a.kt)("h2",s({},{id:"programmatic-usage"}),"Programmatic Usage"),(0,a.kt)("p",null,"Unfortunately, JS build systems are usually the bottleneck for building a JS project nowadays. Having parts of the build blazingly fast doesn't matter much if the rest of the build takes seconds or literally minutes. Here are a few suggestions:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Convert more files into ReScript =). Fewer files going through fewer parts of the JS pipeline helps a ton."),(0,a.kt)("li",{parentName:"ul"},"Careful with bringing in more dependencies: libraries, syntax transforms (e.g. the unofficially supported PPX), build step loaders, etc. The bulk of these dragging down the editing & building experience might out-weight the API benefits they provide.")),(0,a.kt)("h2",s({},{id:"hot-reloading"}),"Hot Reloading"),(0,a.kt)("p",null,"Hot reloading refers to maintaining a dev server and listening to file changes in a way that allows the server to pipe some delta changes right into the currently running browser page. This provides a relatively fast iteration workflow while working in specific frameworks."),(0,a.kt)("p",null,"However, hot reloading is fragile by nature, and counts on the occasional inconsistencies (bad state, bad eval, etc.) and the heavy devserver setup/config being less of a hassle than the benefits it provides. We err on the side of caution and stability in general, and decided not to provide a built-in hot reloading ",(0,a.kt)("em",{parentName:"p"},"yet"),". ",(0,a.kt)("strong",{parentName:"p"},"Note"),": you can still use the hot reloading facility provided by your JS build pipeline."))}p.isMDXComponent=!0,p.frontmatter={title:"Performance",metaTitle:"Build Performance",description:"ReScript build performance and measuring tools",canonical:"/docs/manual/latest/build-performance",__ghEditHref:"https://github.com/reason-association/rescript-lang.org/blob/master/pages/docs/manual/latest/build-performance.mdx"}},99688:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/docs/manual/latest/build-performance",function(){return n(77629)}])}},function(e){e.O(0,[92888,49774,40179],(function(){return t=99688,e(e.s=t);var t}));var t=e.O();_N_E=t}]);