(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[98999],{17375:function(e,t,n){"use strict";function a(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}n.d(t,{Z:function(){return a}})},25082:function(e,t,n){"use strict";n.r(t),n.d(t,{default:function(){return m}});var a=n(17375),i=n(96156),r=(n(67294),n(3905));function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){(0,i.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var o,p=(o="Intro",function(e){return console.warn("Component "+o+" was not imported, exported, or provided by MDXProvider as global scope"),(0,r.kt)("div",l({},e))}),g={};function m(e){var t=e.components,n=(0,a.Z)(e,["components"]);return(0,r.kt)("wrapper",l(l(l({},g),n),{},{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",l({},{id:"float"}),"Float"),(0,r.kt)(p,{mdxType:"Intro"},(0,r.kt)("p",null,"Provide utilities for JS float.")),(0,r.kt)("h2",l({},{id:"_nan"}),"_NaN"),(0,r.kt)("pre",null,(0,r.kt)("code",l({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let _NaN: float\n")),(0,r.kt)("p",null,'The special value "Not a Number".'),(0,r.kt)("h2",l({},{id:"isnan"}),"isNaN"),(0,r.kt)("pre",null,(0,r.kt)("code",l({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let isNaN: float => bool\n")),(0,r.kt)("p",null,"Tests if the given value is _NaN.\nNote that both ",(0,r.kt)("inlineCode",{parentName:"p"},"_NaN == _NaN")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"_NaN === _NaN")," will return false. ",(0,r.kt)("inlineCode",{parentName:"p"},"isNaN")," is therefore necessary to test for ",(0,r.kt)("inlineCode",{parentName:"p"},"_NaN"),"."),(0,r.kt)("p",null,"Returns true if the given value is ",(0,r.kt)("inlineCode",{parentName:"p"},"_NaN"),", false otherwise."),(0,r.kt)("h2",l({},{id:"isfinite"}),"isFinite"),(0,r.kt)("pre",null,(0,r.kt)("code",l({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let isFinite: float => bool\n")),(0,r.kt)("p",null,"Tests if the given value is finite.\nReturns true if the given value is a finite number, false otherwise."),(0,r.kt)("pre",null,(0,r.kt)("code",l({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"/* returns [false] */\nJs.Float.isFinite(infinity)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",l({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"/* returns [false] */\nJs.Float.isFinite(neg_infinity)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",l({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"/* returns [false] */\nJs.Float.isFinite(Js.Float._NaN)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",l({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"/* returns [true] */\nJs.Float.isFinite(1234.)\n")),(0,r.kt)("h2",l({},{id:"toexponential"}),"toExponential"),(0,r.kt)("pre",null,(0,r.kt)("code",l({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let toExponential: float => string\n")),(0,r.kt)("p",null,"Formats a float using exponential (scientific) notation.\nReturns a string representing the given value in exponential notation.\nRaises ",(0,r.kt)("inlineCode",{parentName:"p"},"RangeError")," if ",(0,r.kt)("inlineCode",{parentName:"p"},"digits")," is not in the range ","[","0, 20","]"," (inclusive)."),(0,r.kt)("pre",null,(0,r.kt)("code",l({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'/* prints "7.71234e+1" */\nJs.Float.toExponential(77.1234)->Js.log\n')),(0,r.kt)("pre",null,(0,r.kt)("code",l({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'/* prints "7.7e+1" */\nJs.Float.toExponential(77.)->Js.log\n')),(0,r.kt)("h2",l({},{id:"toexponentialwithprecision"}),"toExponentialWithPrecision"),(0,r.kt)("pre",null,(0,r.kt)("code",l({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let toExponentialWithPrecision: (float, ~digits: int) => string\n")),(0,r.kt)("p",null,"Formats a ",(0,r.kt)("inlineCode",{parentName:"p"},"float")," using exponential (scientific) notation.\n",(0,r.kt)("inlineCode",{parentName:"p"},"digits")," specifies how many digits should appear after the decimal point. The value must be in the range ","[","0, 20","]"," (inclusive)."),(0,r.kt)("p",null,"Returns a ",(0,r.kt)("inlineCode",{parentName:"p"},"string")," representing the given value in exponential notation."),(0,r.kt)("p",null,"The output will be rounded or padded with zeroes if necessary.\nRaises ",(0,r.kt)("inlineCode",{parentName:"p"},"RangeError")," if ",(0,r.kt)("inlineCode",{parentName:"p"},"digits")," is not in the range ","[","0, 20","]"," (inclusive)."),(0,r.kt)("pre",null,(0,r.kt)("code",l({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'/* prints "7.71e+1" */\nJs.Float.toExponentialWithPrecision(77.1234, ~digits=2)->Js.log\n')),(0,r.kt)("h2",l({},{id:"tofixed"}),"toFixed"),(0,r.kt)("pre",null,(0,r.kt)("code",l({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let toFixed: float => string\n")),(0,r.kt)("p",null,"Formats a ",(0,r.kt)("inlineCode",{parentName:"p"},"float")," using fixed point notation.\nReturns a ",(0,r.kt)("inlineCode",{parentName:"p"},"string")," representing the given value in fixed-point notation (usually).\nRaises ",(0,r.kt)("inlineCode",{parentName:"p"},"RangeError")," if ",(0,r.kt)("inlineCode",{parentName:"p"},"digits")," is not in the range ","[","0, 20","]"," (inclusive)."),(0,r.kt)("pre",null,(0,r.kt)("code",l({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'/* prints "12346" (note the rounding) */\nJs.Float.toFixed(12345.6789)->Js.log\n')),(0,r.kt)("pre",null,(0,r.kt)("code",l({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'/* print "1.2e+21" */\nJs.Float.toFixed(1.2e21)->Js.log\n')),(0,r.kt)("h2",l({},{id:"tofixedwithprecision"}),"toFixedWithPrecision"),(0,r.kt)("pre",null,(0,r.kt)("code",l({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let toFixedWithPrecision: (float, ~digits: int) => string\n")),(0,r.kt)("p",null,"Formats a ",(0,r.kt)("inlineCode",{parentName:"p"},"float")," using fixed point notation.\n",(0,r.kt)("inlineCode",{parentName:"p"},"digits")," specifies how many digits should appear after the decimal point. The value must be in the range ","[","0, 20","]"," (inclusive). Defaults to 0."),(0,r.kt)("p",null,"Returns a ",(0,r.kt)("inlineCode",{parentName:"p"},"string")," representing the given value in fixed-point notation (usually)."),(0,r.kt)("p",null,"The output will be rounded or padded with zeroes if necessary.\nRaises ",(0,r.kt)("inlineCode",{parentName:"p"},"RangeError")," if ",(0,r.kt)("inlineCode",{parentName:"p"},"digits")," is not in the range ","[","0, 20","]"," (inclusive)."),(0,r.kt)("pre",null,(0,r.kt)("code",l({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'/* prints "12345.7" (note the rounding) */\nJs.Float.toFixedWithPrecision(12345.6789, ~digits=1)->Js.log\n')),(0,r.kt)("pre",null,(0,r.kt)("code",l({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'/* prints "0.00" (note the added zeroes) */\nJs.Float.toFixedWithPrecision(0., ~digits=2)->Js.log\n')),(0,r.kt)("h2",l({},{id:"toprecision"}),"toPrecision"),(0,r.kt)("pre",null,(0,r.kt)("code",l({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let toPrecision: float => string\n")),(0,r.kt)("p",null,"Formats a ",(0,r.kt)("inlineCode",{parentName:"p"},"float")," using some fairly arbitrary rules.\nReturns a ",(0,r.kt)("inlineCode",{parentName:"p"},"string")," representing the given value in fixed-point (usually)."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"toPrecision")," differs from ",(0,r.kt)("inlineCode",{parentName:"p"},"toFixed")," in that the former will format the number with full precision, while the latter will not output any digits after the decimal point.\nRaises ",(0,r.kt)("inlineCode",{parentName:"p"},"RangeError")," if ",(0,r.kt)("inlineCode",{parentName:"p"},"digits")," is not in the range accepted by this function."),(0,r.kt)("pre",null,(0,r.kt)("code",l({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'/* prints "12345.6789" */\nJs.Float.toPrecision(12345.6789)->Js.log\n')),(0,r.kt)("pre",null,(0,r.kt)("code",l({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'/* print "1.2e+21" */\nJs.Float.toPrecision(1.2e21)->Js.log\n')),(0,r.kt)("h2",l({},{id:"toprecisionwithprecision"}),"toPrecisionWithPrecision"),(0,r.kt)("pre",null,(0,r.kt)("code",l({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let toPrecisionWithPrecision: (float, ~digits: int) => string\n")),(0,r.kt)("p",null,"Formats a ",(0,r.kt)("inlineCode",{parentName:"p"},"float")," using some fairly arbitrary rules.\n",(0,r.kt)("inlineCode",{parentName:"p"},"digits")," specifies how many digits should appear in total. The value must be between 0 and some arbitrary number that's hopefully at least larger than 20 (for Node it's 21. Why? Who knows)."),(0,r.kt)("p",null,"Returns a ",(0,r.kt)("inlineCode",{parentName:"p"},"string")," representing the given value in fixed-point or scientific notation."),(0,r.kt)("p",null,"The output will be rounded or padded with zeroes if necessary."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"toPrecisionWithPrecision")," differs from ",(0,r.kt)("inlineCode",{parentName:"p"},"toFixedWithPrecision")," in that the former will count all digits against the precision, while the latter will count only the digits after the decimal point.\n",(0,r.kt)("inlineCode",{parentName:"p"},"toPrecisionWithPrecision")," will also use scientific notation if the specified precision is less than the number for digits before the decimal point.\nRaises ",(0,r.kt)("inlineCode",{parentName:"p"},"RangeError")," if ",(0,r.kt)("inlineCode",{parentName:"p"},"digits")," is not in the range accepted by this function."),(0,r.kt)("pre",null,(0,r.kt)("code",l({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'/* prints "1e+4" */\nJs.Float.toPrecisionWithPrecision(12345.6789, ~digits=1)->Js.log\n')),(0,r.kt)("pre",null,(0,r.kt)("code",l({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'/* prints "0.0" */\nJs.Float.toPrecisionWithPrecision(0., ~digits=2)->Js.log\n')),(0,r.kt)("h2",l({},{id:"tostring"}),"toString"),(0,r.kt)("pre",null,(0,r.kt)("code",l({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let toString: float => string\n")),(0,r.kt)("p",null,"Formats a ",(0,r.kt)("inlineCode",{parentName:"p"},"float")," as a ",(0,r.kt)("inlineCode",{parentName:"p"},"string"),".\nReturns a ",(0,r.kt)("inlineCode",{parentName:"p"},"string")," representing the given value in fixed-point (usually)."),(0,r.kt)("pre",null,(0,r.kt)("code",l({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'/* prints "12345.6789" */\nJs.Float.toString(12345.6789)->Js.log\n')),(0,r.kt)("h2",l({},{id:"tostringwithradix"}),"toStringWithRadix"),(0,r.kt)("pre",null,(0,r.kt)("code",l({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let toStringWithRadix: (float, ~radix: int) => string\n")),(0,r.kt)("p",null,"Formats a ",(0,r.kt)("inlineCode",{parentName:"p"},"float")," as a ",(0,r.kt)("inlineCode",{parentName:"p"},"string"),".\n",(0,r.kt)("inlineCode",{parentName:"p"},"radix")," specifies the radix base to use for the formatted number. The value must be in the range ","[","2, 36","]"," (inclusive)."),(0,r.kt)("p",null,"Returns a ",(0,r.kt)("inlineCode",{parentName:"p"},"string")," representing the given value in fixed-point (usually).\nRaises ",(0,r.kt)("inlineCode",{parentName:"p"},"RangeError")," if ",(0,r.kt)("inlineCode",{parentName:"p"},"radix")," is not in the range ","[","2, 36","]"," (inclusive)."),(0,r.kt)("pre",null,(0,r.kt)("code",l({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'/* prints "110" */\nJs.Float.toStringWithRadix(6., ~radix=2)->Js.log\n')),(0,r.kt)("pre",null,(0,r.kt)("code",l({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'/* prints "11.001000111101011100001010001111010111000010100011111" */\nJs.Float.toStringWithRadix(3.14, ~radix=2)->Js.log\n')),(0,r.kt)("pre",null,(0,r.kt)("code",l({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'/* prints "deadbeef" */\nJs.Float.toStringWithRadix(3735928559., ~radix=16)->Js.log\n\n')),(0,r.kt)("pre",null,(0,r.kt)("code",l({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'/* prints "3f.gez4w97ry0a18ymf6qadcxr" */\nJs.Float.toStringWithRadix(123.456, ~radix=36)->Js.log\n')),(0,r.kt)("h2",l({},{id:"fromstring"}),"fromString"),(0,r.kt)("pre",null,(0,r.kt)("code",l({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let fromString: string => float\n")),(0,r.kt)("p",null,"Parses the given ",(0,r.kt)("inlineCode",{parentName:"p"},"string")," into a ",(0,r.kt)("inlineCode",{parentName:"p"},"float")," using JavaScript semantics.\nReturns the number as a ",(0,r.kt)("inlineCode",{parentName:"p"},"float")," if successfully parsed, ",(0,r.kt)("inlineCode",{parentName:"p"},"_NaN")," otherwise."),(0,r.kt)("pre",null,(0,r.kt)("code",l({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'/* returns 123 */\nJs.Float.fromString("123")\n')),(0,r.kt)("pre",null,(0,r.kt)("code",l({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'/* returns 12.3 */\nJs.Float.fromString("12.3")\n')),(0,r.kt)("pre",null,(0,r.kt)("code",l({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'/* returns 0 */\nJs.Float.fromString("")\n')),(0,r.kt)("pre",null,(0,r.kt)("code",l({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'/* returns 17 */\nJs.Float.fromString("0x11")\n')),(0,r.kt)("pre",null,(0,r.kt)("code",l({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'/* returns 3 */\nJs.Float.fromString("0b11")\n')),(0,r.kt)("pre",null,(0,r.kt)("code",l({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'/* returns 9 */\nJs.Float.fromString("0o11")\n')),(0,r.kt)("pre",null,(0,r.kt)("code",l({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'/* returns [_NaN] */\nJs.Float.fromString("hello")\n')),(0,r.kt)("pre",null,(0,r.kt)("code",l({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'/* returns [_NaN] */\nJs.Float.fromString("100a")\n')))}m.isMDXComponent=!0,m.frontmatter={__ghEditHref:"https://github.com/reason-association/rescript-lang.org/blob/master/pages/docs/manual/latest/api/js/float.mdx"}},79550:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/docs/manual/latest/api/js/float",function(){return n(25082)}])}},function(e){e.O(0,[92888,49774,40179],(function(){return t=79550,e(e.s=t);var t}));var t=e.O();_N_E=t}]);