(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[94137],{17375:function(e,t,n){"use strict";function a(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}n.d(t,{Z:function(){return a}})},1970:function(e,t,n){"use strict";n.r(t),n.d(t,{default:function(){return d}});var a=n(17375),o=n(96156),r=(n(67294),n(3905));function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){(0,o.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var p,s=(p="CodeTab",function(e){return console.warn("Component "+p+" was not imported, exported, or provided by MDXProvider as global scope"),(0,r.kt)("div",i({},e))}),u={};function d(e){var t=e.components,n=(0,a.Z)(e,["components"]);return(0,r.kt)("wrapper",i(i(i({},u),n),{},{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",i({},{id:"null-undefined-and-option"}),"Null, Undefined and Option"),(0,r.kt)("p",null,"ReScript itself doesn't have the notion of ",(0,r.kt)("inlineCode",{parentName:"p"},"null")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"undefined"),". This is a ",(0,r.kt)("em",{parentName:"p"},"great")," thing, as it wipes out an entire category of bugs. No more ",(0,r.kt)("inlineCode",{parentName:"p"},"undefined is not a function"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"cannot access someAttribute of undefined"),"!"),(0,r.kt)("p",null,"However, the ",(0,r.kt)("strong",{parentName:"p"},"concept")," of a potentially nonexistent value is still useful, and safely exists in our language."),(0,r.kt)("p",null,"We represent the existence and nonexistence of a value by wrapping it with the ",(0,r.kt)("inlineCode",{parentName:"p"},"option")," type. Here's its definition from the standard library:"),(0,r.kt)(s,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"type option<'a> = None | Some('a)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-js"}),"// Empty output\n"))),(0,r.kt)("p",null,'It means "a value of type option is either None (representing nothing) or that actual value wrapped in a Some".'),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Note")," how the ",(0,r.kt)("inlineCode",{parentName:"p"},"option")," type is just a regular ",(0,r.kt)("a",i({parentName:"p"},{href:"variant.md"}),"variant"),"."),(0,r.kt)("h2",i({},{id:"example"}),"Example"),(0,r.kt)("p",null,"Here's a normal value:"),(0,r.kt)(s,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"let licenseNumber = 5\n")),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-js"}),"var licenseNumber = 5;\n"))),(0,r.kt)("p",null,'To represent the concept of "maybe null", you\'d turn this into an ',(0,r.kt)("inlineCode",{parentName:"p"},"option")," type by wrapping it. For the sake of a more illustrative example, we'll put a condition around it:"),(0,r.kt)(s,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-res"}),"let licenseNumber =\n  if personHasACar {\n    Some(5)\n  } else {\n    None\n  }\n")),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-js"}),"var licenseNumber = personHasACar ? 5 : undefined;\n"))),(0,r.kt)("p",null,"Later on, when another piece of code receives such value, it'd be forced to handle both cases through ",(0,r.kt)("a",i({parentName:"p"},{href:"pattern-matching-destructuring.md"}),"pattern matching"),":"),(0,r.kt)(s,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-res"}),'switch licenseNumber {\n| None =>\n  Js.log("The person doesn\'t have a car")\n| Some(number) =>\n  Js.log("The person\'s license number is " ++ Js.Int.toString(number))\n}\n')),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-js"}),'var number = licenseNumber;\n\nif (number !== undefined) {\n  console.log("The person\'s license number is " + number.toString());\n} else {\n  console.log("The person doesn\'t have a car");\n}\n'))),(0,r.kt)("p",null,"By turning your ordinary number into an ",(0,r.kt)("inlineCode",{parentName:"p"},"option")," type, and by forcing you to handle the ",(0,r.kt)("inlineCode",{parentName:"p"},"None")," case, the language effectively removed the possibility for you to mishandle, or forget to handle, a conceptual ",(0,r.kt)("inlineCode",{parentName:"p"},"null")," value! ",(0,r.kt)("strong",{parentName:"p"},"A pure ReScript program doesn't have null errors"),"."),(0,r.kt)("h2",i({},{id:"interoperate-with-javascript-undefined-and-null"}),"Interoperate with JavaScript ",(0,r.kt)("inlineCode",{parentName:"h2"},"undefined")," and ",(0,r.kt)("inlineCode",{parentName:"h2"},"null")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"option")," type is common enough that we special-case it when compiling to JavaScript:"),(0,r.kt)(s,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"let x = Some(5)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-js"}),"var x = 5;\n"))),(0,r.kt)("p",null,"simply compiles down to ",(0,r.kt)("inlineCode",{parentName:"p"},"5"),", and"),(0,r.kt)(s,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"let x = None\n")),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-js"}),"var x;\n"))),(0,r.kt)("p",null,"compiles to ",(0,r.kt)("inlineCode",{parentName:"p"},"undefined"),"! If you've got e.g. a string in JavaScript that you know might be ",(0,r.kt)("inlineCode",{parentName:"p"},"undefined"),", type it as ",(0,r.kt)("inlineCode",{parentName:"p"},"option<string>")," and you're done! Likewise, you can send a ",(0,r.kt)("inlineCode",{parentName:"p"},"Some(5)")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"None")," to the JS side and expect it to be interpreted correctly =)"),(0,r.kt)("h3",i({},{id:"caveat-1"}),"Caveat 1"),(0,r.kt)("p",null,"The option-to-undefined translation isn't perfect, because on our side, ",(0,r.kt)("inlineCode",{parentName:"p"},"option")," values can be composed:"),(0,r.kt)(s,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"let x = Some(Some(Some(5)))\n")),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-js"}),"var x = 5;\n"))),(0,r.kt)("p",null,"This still compiles to ",(0,r.kt)("inlineCode",{parentName:"p"},"5"),", but this gets troublesome:"),(0,r.kt)(s,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"let x = Some(None)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-js"}),'var Caml_option = require("./stdlib/caml_option.js");\n\nvar x = Caml_option.some(undefined);\n')),(0,r.kt)("p",null,"(See output tab).")),(0,r.kt)("p",null,"What's this ",(0,r.kt)("inlineCode",{parentName:"p"},"Caml_option.some")," thing? Why can't this compile to ",(0,r.kt)("inlineCode",{parentName:"p"},"undefined"),"? Long story short, when dealing with a polymorphic ",(0,r.kt)("inlineCode",{parentName:"p"},"option")," type (aka ",(0,r.kt)("inlineCode",{parentName:"p"},"option<'a>"),", for any ",(0,r.kt)("inlineCode",{parentName:"p"},"'a"),"), many operations become tricky if we don't mark the value with some special annotation. If this doesn't make sense, don't worry; just remember the following rule:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Never, EVER, pass a nested ",(0,r.kt)("inlineCode",{parentName:"strong"},"option")," value (e.g. ",(0,r.kt)("inlineCode",{parentName:"strong"},"Some(Some(Some(5)))"),") into the JS side.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Never, EVER, annotate a value coming from JS as ",(0,r.kt)("inlineCode",{parentName:"strong"},"option<'a>"),". Always give the concrete, non-polymorphic type."))),(0,r.kt)("h3",i({},{id:"caveat-2"}),"Caveat 2"),(0,r.kt)("p",null,"Unfortunately, lots of times, your JavaScript value might be ",(0,r.kt)("em",{parentName:"p"},"both")," ",(0,r.kt)("inlineCode",{parentName:"p"},"null")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"undefined"),". In that case, you unfortunately can't type such value as e.g. ",(0,r.kt)("inlineCode",{parentName:"p"},"option<int>"),", since our ",(0,r.kt)("inlineCode",{parentName:"p"},"option")," type only checks for ",(0,r.kt)("inlineCode",{parentName:"p"},"undefined")," and not ",(0,r.kt)("inlineCode",{parentName:"p"},"null")," when dealing with a ",(0,r.kt)("inlineCode",{parentName:"p"},"None"),"."),(0,r.kt)("h4",i({},{id:"solution-more-sophisticated-undefined--null-interop"}),"Solution: More Sophisticated ",(0,r.kt)("inlineCode",{parentName:"h4"},"undefined")," & ",(0,r.kt)("inlineCode",{parentName:"h4"},"null")," Interop"),(0,r.kt)("p",null,"To solve this, we provide access to more elaborate ",(0,r.kt)("inlineCode",{parentName:"p"},"null")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"undefined")," helpers through the ",(0,r.kt)("a",i({parentName:"p"},{href:"api/js/nullable"}),(0,r.kt)("inlineCode",{parentName:"a"},"Js.Nullable"))," module. This somewhat works like an ",(0,r.kt)("inlineCode",{parentName:"p"},"option")," type, but is different from it."),(0,r.kt)("h4",i({},{id:"examples"}),"Examples"),(0,r.kt)("p",null,"To create a JS ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),", use the value ",(0,r.kt)("inlineCode",{parentName:"p"},"Js.Nullable.null"),". To create a JS ",(0,r.kt)("inlineCode",{parentName:"p"},"undefined"),", use ",(0,r.kt)("inlineCode",{parentName:"p"},"Js.Nullable.undefined")," (you can naturally use ",(0,r.kt)("inlineCode",{parentName:"p"},"None")," too, but that's not the point here; the ",(0,r.kt)("inlineCode",{parentName:"p"},"Js.Nullable.*")," helpers wouldn't work with it)."),(0,r.kt)("p",null,"If you're receiving, for example, a JS string that can be ",(0,r.kt)("inlineCode",{parentName:"p"},"null")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"undefined"),", type it as:"),(0,r.kt)(s,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'@module("MyConstant") external myId: Js.Nullable.t<string> = "myId"\n')),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-js"}),"// Empty output\n"))),(0,r.kt)("p",null,"To create such a nullable string from our side (presumably to pass it to the JS side, for interop purpose), do:"),(0,r.kt)(s,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'@module("MyIdValidator") external validate: Js.Nullable.t<string> => bool = "validate"\nlet personId: Js.Nullable.t<string> = Js.Nullable.return("abc123")\n\nlet result = validate(personId)\n')),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-js"}),'var MyIdValidator = require("MyIdValidator");\nvar personId = "abc123";\nvar result = MyIdValidator.validate(personId);\n'))),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"return"),' part "wraps" a string into a nullable string, to make the type system understand and track the fact that, as you pass this value around, it\'s not just a string, but a string that can be ',(0,r.kt)("inlineCode",{parentName:"p"},"null")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"undefined"),"."),(0,r.kt)("h4",i({},{id:"convert-tofrom-option"}),"Convert to/from ",(0,r.kt)("inlineCode",{parentName:"h4"},"option")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Js.Nullable.fromOption")," converts from a ",(0,r.kt)("inlineCode",{parentName:"p"},"option")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"Js.Nullable.t"),". ",(0,r.kt)("inlineCode",{parentName:"p"},"Js.Nullable.toOption")," does the opposite."))}d.isMDXComponent=!0,d.frontmatter={title:"Null, Undefined and Option",description:"JS interop with nullable and optional values in ReScript",canonical:"/docs/manual/latest/null-undefined-option",__ghEditHref:"https://github.com/reason-association/rescript-lang.org/blob/master/pages/docs/manual/latest/null-undefined-option.mdx"}},96398:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/docs/manual/latest/null-undefined-option",function(){return n(1970)}])}},function(e){e.O(0,[92888,49774,40179],(function(){return t=96398,e(e.s=t);var t}));var t=e.O();_N_E=t}]);