(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[56463],{17375:function(e,t,a){"use strict";function n(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}a.d(t,{Z:function(){return n}})},58863:function(e,t,a){"use strict";a.r(t),a.d(t,{default:function(){return c}});var n=a(17375),r=a(96156),o=(a(67294),a(3905));function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){(0,r.Z)(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}var s,p=(s="CodeTab",function(e){return console.warn("Component "+s+" was not imported, exported, or provided by MDXProvider as global scope"),(0,o.kt)("div",l({},e))}),u={};function c(e){var t=e.components,a=(0,n.Z)(e,["components"]);return(0,o.kt)("wrapper",l(l(l({},u),a),{},{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",l({},{id:"variant"}),"Variant"),(0,o.kt)("p",null,"So far, most of ReScript's data structures might look familiar to you. This section introduces an extremely important, and perhaps unfamiliar, data structure: variant."),(0,o.kt)("p",null,'Most data structures in most languages are about "this ',(0,o.kt)("strong",{parentName:"p"},"and"),' that". A variant allows us to express "this ',(0,o.kt)("strong",{parentName:"p"},"or"),' that".'),(0,o.kt)(p,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",l({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"type myResponse =\n  | Yes\n  | No\n  | PrettyMuch\n\nlet areYouCrushingIt = Yes\n")),(0,o.kt)("pre",null,(0,o.kt)("code",l({parentName:"pre"},{className:"language-js"}),"var areYouCrushingIt = /* Yes */0;\n"))),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"myResponse")," is a variant type with the cases ",(0,o.kt)("inlineCode",{parentName:"p"},"Yes"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"No")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"PrettyMuch"),', which are called "variant constructors" (or "variant tag"). The ',(0,o.kt)("inlineCode",{parentName:"p"},"|")," bar separates each constructor."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Note"),": a variant's constructors need to be capitalized."),(0,o.kt)("h2",l({},{id:"variant-needs-an-explicit-definition"}),"Variant Needs an Explicit Definition"),(0,o.kt)("p",null,"If the variant you're using is in a different file, bring it into scope like you'd do ",(0,o.kt)("a",l({parentName:"p"},{href:"record.md#record-needs-an-explicit-definition"}),"for a record"),":"),(0,o.kt)(p,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",l({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"// Zoo.res\ntype animal = Dog | Cat | Bird\n")),(0,o.kt)("pre",null,(0,o.kt)("code",l({parentName:"pre"},{className:"language-js"}),"// Empty output\n"))),(0,o.kt)(p,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",l({parentName:"pre"},{className:"language-res"}),"// Example.res\nlet pet: Zoo.animal = Dog // preferred\n// or\nlet pet2 = Zoo.Dog\n")),(0,o.kt)("pre",null,(0,o.kt)("code",l({parentName:"pre"},{className:"language-js"}),"var pet = /* Dog */0;\nvar pet2 = /* Dog */0;\n"))),(0,o.kt)("h2",l({},{id:"constructor-arguments"}),"Constructor Arguments"),(0,o.kt)("p",null,"A variant's constructors can hold extra data separated by comma."),(0,o.kt)(p,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",l({parentName:"pre"},{className:"language-res",metastring:"prelude",prelude:!0}),"type account =\n  | None\n  | Instagram(string)\n  | Facebook(string, int)\n")),(0,o.kt)("pre",null,(0,o.kt)("code",l({parentName:"pre"},{className:"language-js"}),"// Empty output\n"))),(0,o.kt)("p",null,"Here, ",(0,o.kt)("inlineCode",{parentName:"p"},"Instagram")," holds a ",(0,o.kt)("inlineCode",{parentName:"p"},"string"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"Facebook")," holds a ",(0,o.kt)("inlineCode",{parentName:"p"},"string")," and an ",(0,o.kt)("inlineCode",{parentName:"p"},"int"),". Usage:"),(0,o.kt)(p,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",l({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'let myAccount = Facebook("Josh", 26)\nlet friendAccount = Instagram("Jenny")\n')),(0,o.kt)("pre",null,(0,o.kt)("code",l({parentName:"pre"},{className:"language-js"}),'var myAccount = {\n  TAG: /* Facebook */1,\n  _0: "Josh",\n  _1: 26\n};\nvar friendAccount = {\n  TAG: /* Instagram */0,\n  _0: "Jenny"\n};\n'))),(0,o.kt)("h3",l({},{id:"labeled-variant-payloads-inline-record"}),"Labeled Variant Payloads (Inline Record)"),(0,o.kt)("p",null,"If a variant payload has multiple fields, you can use a record-like syntax to label them for better readability:"),(0,o.kt)(p,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",l({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'type user =\n  | Number(int)\n  | Id({name: string, password: string})\n\nlet me = Id({name: "Joe", password: "123"})\n')),(0,o.kt)("pre",null,(0,o.kt)("code",l({parentName:"pre"},{className:"language-js"}),'var me = {\n  TAG: /* Id */1,\n  name: "Joe",\n  password: "123"\n};\n'))),(0,o.kt)("p",null,'This is technically called an "inline record", and only allowed within a variant constructor. You cannot inline a record type declaration anywhere else in ReScript.'),(0,o.kt)("p",null,"Of course, you can just put a regular record type in a variant too:"),(0,o.kt)(p,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",l({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'type u = {name: string, password: string}\ntype user =\n  | Number(int)\n  | Id(u)\n\nlet me = Id({name: "Joe", password: "123"})\n')),(0,o.kt)("pre",null,(0,o.kt)("code",l({parentName:"pre"},{className:"language-js"}),'var me = {\n  TAG: /* Id */1,\n  _0: {\n    name: "Joe",\n    password: "123"\n  }\n};\n'))),(0,o.kt)("p",null,"The output is slightly uglier and less performant than the former."),(0,o.kt)("h3",l({},{id:"pattern-matching-on-variant"}),"Pattern Matching On Variant"),(0,o.kt)("p",null,"See the ",(0,o.kt)("a",l({parentName:"p"},{href:"pattern-matching-destructuring.md"}),"Pattern Matching/Destructuring")," section later."),(0,o.kt)("h2",l({},{id:"javascript-output"}),"JavaScript Output"),(0,o.kt)("p",null,"A variant value compiles to 3 possible JavaScript outputs depending on its type declaration:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"If the variant value is a constructor with no payload, it compiles to a number."),(0,o.kt)("li",{parentName:"ul"},"If it's a constructor with a payload, it compiles to an object with the field ",(0,o.kt)("inlineCode",{parentName:"li"},"TAG")," and the field ",(0,o.kt)("inlineCode",{parentName:"li"},"_0")," for the first payload, ",(0,o.kt)("inlineCode",{parentName:"li"},"_1")," for the second payload, etc."),(0,o.kt)("li",{parentName:"ul"},"An exception to the above is a variant whose type declaration contains only a single constructor with payload. In that case, the constructor compiles to an object without the ",(0,o.kt)("inlineCode",{parentName:"li"},"TAG")," field."),(0,o.kt)("li",{parentName:"ul"},"Labeled variant payloads (the inline record trick earlier) compile to an object with the label names instead of ",(0,o.kt)("inlineCode",{parentName:"li"},"_0"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"_1"),", etc. The object might or might not have the ",(0,o.kt)("inlineCode",{parentName:"li"},"TAG")," field as per previous rule.")),(0,o.kt)("p",null,"Check the output in these examples:"),(0,o.kt)(p,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",l({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'type greeting = Hello | Goodbye\nlet g1 = Hello\nlet g2 = Goodbye\n\ntype outcome = Good | Error(string)\nlet o1 = Good\nlet o2 = Error("oops!")\n\ntype family = Child | Mom(int, string) | Dad (int)\nlet f1 = Child\nlet f2 = Mom(30, "Jane")\nlet f3 = Dad(32)\n\ntype person = Teacher | Student({gpa: float})\nlet p1 = Teacher\nlet p2 = Student({gpa: 99.5})\n\ntype s = {score: float}\ntype adventurer = Warrior(s) | Wizard(string)\nlet a1 = Warrior({score: 10.5})\nlet a2 = Wizard("Joe")\n')),(0,o.kt)("pre",null,(0,o.kt)("code",l({parentName:"pre"},{className:"language-js"}),'var g1 = /* Hello */0;\nvar g2 = /* Goodbye */1;\n\nvar o1 = /* Good */0;\nvar o2 = /* Error */{\n  _0: "oops!"\n};\n\nvar f1 = /* Child */0;\nvar f2 = {\n  TAG: /* Mom */0,\n  _0: 30,\n  _1: "Jane"\n};\nvar f3 = {\n  TAG: /* Dad */1,\n  _0: 32\n};\n\nvar p1 = /* Teacher */0;\nvar p2 = /* Student */{\n  gpa: 99.5\n};\n\nvar a1 = {\n  TAG: /* Warrior */0,\n  _0: {\n    score: 10.5\n  }\n};\nvar a2 = {\n  TAG: /* Wizard */1,\n  _0: "Joe"\n};\n'))),(0,o.kt)("h2",l({},{id:"tips--tricks"}),"Tips & Tricks"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Be careful")," not to confuse a constructor carrying 2 arguments with a constructor carrying a single tuple argument:"),(0,o.kt)(p,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",l({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"type account =\n  | Facebook(string, int) // 2 arguments\ntype account2 =\n  | Instagram((string, int)) // 1 argument - happens to be a 2-tuple\n")),(0,o.kt)("pre",null,(0,o.kt)("code",l({parentName:"pre"},{className:"language-js"}),"// Empty output\n"))),(0,o.kt)("h3",l({},{id:"variants-must-have-constructors"}),"Variants Must Have Constructors"),(0,o.kt)("p",null,"If you come from an untyped language, you might be tempted to try ",(0,o.kt)("inlineCode",{parentName:"p"},"type myType = int | string"),". This isn't possible in ReScript; you'd have to give each branch a constructor: ",(0,o.kt)("inlineCode",{parentName:"p"},"type myType = Int(int) | String(string)"),". The former looks nice, but causes lots of trouble down the line."),(0,o.kt)("h3",l({},{id:"interop-with-javascript"}),"Interop with JavaScript"),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"This section assumes knowledge about our JavaScript interop. Skip this if you haven't felt the itch to use variants for wrapping JS functions yet"),"."),(0,o.kt)("p",null,"Quite a few JS libraries use functions that can accept many types of arguments. In these cases, it's very tempting to model them as variants. For example, suppose there's a ",(0,o.kt)("inlineCode",{parentName:"p"},"myLibrary.draw")," JS function that takes in either a ",(0,o.kt)("inlineCode",{parentName:"p"},"number")," or a ",(0,o.kt)("inlineCode",{parentName:"p"},"string"),". You might be tempted to bind it like so:"),(0,o.kt)(p,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",l({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'// reserved for internal usage\n@bs.module("myLibrary") external draw : \'a => unit = "draw"\n\ntype animal =\n  | MyFloat(float)\n  | MyString(string)\n\nlet betterDraw = (animal) =>\n  switch animal {\n  | MyFloat(f) => draw(f)\n  | MyString(s) => draw(s)\n  }\n\nbetterDraw(MyFloat(1.5))\n')),(0,o.kt)("pre",null,(0,o.kt)("code",l({parentName:"pre"},{className:"language-js"}),'var MyLibrary = require("myLibrary");\n\nfunction betterDraw(animal) {\n  MyLibrary.draw(animal._0);\n}\n\nbetterDraw({\n  TAG: /* MyFloat */0,\n  _0: 1.5\n});\n'))),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Try not to do that"),", as this generates extra noisy output. Alternatively, define two ",(0,o.kt)("inlineCode",{parentName:"p"},"external"),"s that both compile to the same JS call:"),(0,o.kt)(p,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",l({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'@bs.module("myLibrary") external drawFloat: float => unit = "draw"\n@bs.module("myLibrary") external drawString: string => unit = "draw"\n')),(0,o.kt)("pre",null,(0,o.kt)("code",l({parentName:"pre"},{className:"language-js"}),"// Empty output\n"))),(0,o.kt)("p",null,"ReScript also provides ",(0,o.kt)("a",l({parentName:"p"},{href:"bind-to-js-function.md#modeling-polymorphic-function"}),"a few other ways")," to do this."),(0,o.kt)("h3",l({},{id:"variant-types-are-found-by-field-name"}),"Variant Types Are Found By Field Name"),(0,o.kt)("p",null,"Please refer to this ",(0,o.kt)("a",l({parentName:"p"},{href:"record#record-types-are-found-by-field-name"}),"record section"),". Variants are the same: a function can't accept an arbitrary constructor shared by two different variants. Again, such feature exists; it's called a polymorphic variant. We'll talk about this in the future =)."),(0,o.kt)("h2",l({},{id:"design-decisions"}),"Design Decisions"),(0,o.kt)("p",null,"Variants, in their many forms (polymorphic variant, open variant, GADT, etc.), are likely ",(0,o.kt)("em",{parentName:"p"},"the")," feature of a type system such as ReScript's. The aforementioned ",(0,o.kt)("inlineCode",{parentName:"p"},"option")," variant, for example, obliterates the need for nullable types, a major source of bugs in other languages. Philosophically speaking, a problem is composed of many possible branches/conditions. Mishandling these conditions is the majority of what we call bugs. ",(0,o.kt)("strong",{parentName:"p"},"A type system doesn't magically eliminate bugs; it points out the unhandled conditions and asks you to cover them"),"*",'. The ability to model "this or that" correctly is crucial.'),(0,o.kt)("p",null,"For example, some folks wonder how the type system can safely eliminate badly formatted JSON data from propagating into their program. They don't, not by themselves! But if the parser returns the ",(0,o.kt)("inlineCode",{parentName:"p"},"option")," type ",(0,o.kt)("inlineCode",{parentName:"p"},"None | Some(actualData)"),", then you'd have to handle the ",(0,o.kt)("inlineCode",{parentName:"p"},"None")," case explicitly in later call sites. That's all there is."),(0,o.kt)("p",null,"Performance-wise, a variant can potentially tremendously speed up your program's logic. Here's a piece of JavaScript:"),(0,o.kt)("pre",null,(0,o.kt)("code",l({parentName:"pre"},{className:"language-js"}),"let data = 'dog'\nif (data === 'dog') {\n  ...\n} else if (data === 'cat') {\n  ...\n} else if (data === 'bird') {\n  ...\n}\n")),(0,o.kt)("p",null,"There's a linear amount of branch checking here (",(0,o.kt)("inlineCode",{parentName:"p"},"O(n)"),"). Compare this to using a ReScript variant:"),(0,o.kt)(p,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",l({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'type animal = Dog | Cat | Bird\nlet data = Dog\nswitch data {\n| Dog => Js.log("Wof")\n| Cat => Js.log("Meow")\n| Bird => Js.log("Kashiiin")\n}\n')),(0,o.kt)("pre",null,(0,o.kt)("code",l({parentName:"pre"},{className:"language-js"}),'console.log("Wof");\n\nvar data = /* Dog */0;\n'))),(0,o.kt)("p",null,"The compiler sees the variant, then"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"conceptually turns them into ",(0,o.kt)("inlineCode",{parentName:"li"},"type animal = 0 | 1 | 2")),(0,o.kt)("li",{parentName:"ol"},"compiles ",(0,o.kt)("inlineCode",{parentName:"li"},"switch")," to a constant-time jump table (",(0,o.kt)("inlineCode",{parentName:"li"},"O(1)"),").")))}c.isMDXComponent=!0,c.frontmatter={title:"Variant",description:"Variant data structures in ReScript",canonical:"/docs/manual/latest/variant",__ghEditHref:"https://github.com/reason-association/rescript-lang.org/blob/master/pages/docs/manual/v9.0.0/variant.mdx"}},54934:function(e,t,a){(window.__NEXT_P=window.__NEXT_P||[]).push(["/docs/manual/v9.0.0/variant",function(){return a(58863)}])}},function(e){e.O(0,[92888,49774,40179],(function(){return t=54934,e(e.s=t);var t}));var t=e.O();_N_E=t}]);