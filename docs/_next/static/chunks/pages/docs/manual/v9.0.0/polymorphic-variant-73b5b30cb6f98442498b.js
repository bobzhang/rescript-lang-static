(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[63670],{17375:function(e,t,n){"use strict";function a(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}n.d(t,{Z:function(){return a}})},24908:function(e,t,n){"use strict";n.r(t),n.d(t,{default:function(){return c}});var a=n(17375),r=n(96156),o=(n(67294),n(3905));function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){(0,r.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var s,p=(s="CodeTab",function(e){return console.warn("Component "+s+" was not imported, exported, or provided by MDXProvider as global scope"),(0,o.kt)("div",i({},e))}),u={};function c(e){var t=e.components,n=(0,a.Z)(e,["components"]);return(0,o.kt)("wrapper",i(i(i({},u),n),{},{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",i({},{id:"polymorphic-variant"}),"Polymorphic Variant"),(0,o.kt)("p",null,"Now that we know what ",(0,o.kt)("a",i({parentName:"p"},{href:"./variant"}),"variant types")," are, let's dive into a more specific version, so called polymorphic variants (or poly variants)."),(0,o.kt)("p",null,"First off, here are some key features:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Poly variants are structurally typed, which means they don't require any explicit type definition to be used as a value, and are not coupled to any specific module. The compiler will infer the type on demand, and compare poly variants by their value, instead of their type name (which would be called nominal typing)."),(0,o.kt)("li",{parentName:"ul"},"They allow easier JavaScript interop (compile to strings / objects with predictable ",(0,o.kt)("inlineCode",{parentName:"li"},"NAME")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"VAL")," attribute) and don't need explicit runtime conversions, unlike common variants."),(0,o.kt)("li",{parentName:"ul"},"Due to their structural nature, poly variant types may cause tricky type checking errors when types don't match up.")),(0,o.kt)("h2",i({},{id:"basics"}),"Basics"),(0,o.kt)("p",null,"Here is how you'd construct a poly variant value:"),(0,o.kt)(p,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-res"}),"// Note how a poly variant starts with a hashtag (#)\n// We also don't need any explicit type definition\nlet myColor = #Red\n")),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-js"}),'var myColor = "Red";\n'))),(0,o.kt)("p",null,"This is how you'd define a closed poly variant type with an exact set of constructors:"),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-res"}),"// Note the surrounding square brackets, and # for constructors\ntype color = [ #Red | #Green | #Blue ]\n")),(0,o.kt)("p",null,"We can also use poly variant types in annotations without an explicit type definition:"),(0,o.kt)(p,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-res"}),'let render = (color: [#Red | #Green | #Blue]) => {\n  switch(color) {\n    | _ => Js.log("...")\n  }\n}\n\nlet color: [#Red] = #Red\n')),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-js"}),'function render(color) {\n  console.log("...");\n}\n\nvar color = "Red";\n'))),(0,o.kt)("h3",i({},{id:"constructor-names"}),"Constructor Names"),(0,o.kt)("p",null,"Poly variant constructor names are less restrictive than in common variants (e.g. they don't need to be capitalized):"),(0,o.kt)(p,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-res"}),"type users = [ #admin | #moderator | #user ]\n\nlet admin = #admin\n")),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-js"}),'var admin = "admin";\n'))),(0,o.kt)("p",null,'In rare cases (mostly for JS interop reasons), it\'s also possible to define "invalid identifiers", such as hypens or numbers:'),(0,o.kt)(p,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-res"}),'type numbers = [#"1" | #"2"]\nlet one = #"1"\nlet oneA = #"1a"\n')),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-js"}),'var one = "1";\nvar oneA = "1a";\n'))),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Note:")," For ReScript versions < 9.0 you'll need to use the ",(0,o.kt)("inlineCode",{parentName:"p"},"\\")," character as an escape sequence to represent invalid identifiers (e.g. ",(0,o.kt)("inlineCode",{parentName:"p"},'#\\"1"'),")."),(0,o.kt)("h3",i({},{id:"constructor-arguments"}),"Constructor Arguments"),(0,o.kt)("p",null,"This is equivalent to what we've ",(0,o.kt)("a",i({parentName:"p"},{href:"variant#constructor-arguments"}),"already learned")," with common variants:"),(0,o.kt)(p,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-res"}),'type account = [\n  | #Anonymous\n  | #Instagram(string)\n  | #Facebook(string, int)\n]\n\nlet acc: account = #Instagram("test")\n')),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-js"}),'var acc = {\n  NAME: "Instagram",\n  VAL: "test"\n};\n'))),(0,o.kt)("h3",i({},{id:"compose-and-pattern-match-poly-variants"}),"Compose and Pattern Match Poly Variants"),(0,o.kt)("p",null,"You can use poly variant types within other poly variant types to create a sum of all constructors:"),(0,o.kt)(p,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-res"}),"type red = [#Ruby | #Redwood | #Rust]\ntype blue = [#Sapphire | #Neon | #Navy]\n\n// Contains all constructors of red and blue.\n// Also adds #Papayawhip\ntype color = [red | blue | #Papayawhip]\n\nlet c: color = #Ruby\n")),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-js"}),'var c = "Ruby";\n'))),(0,o.kt)("p",null,"There's also some special ",(0,o.kt)("a",i({parentName:"p"},{href:"./pattern-matching-destructuring"}),"pattern matching")," syntax to match on constructors defined in a specific poly variant type:"),(0,o.kt)(p,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-res"}),'// Continuing the previous example above...\n\nswitch #Papayawhip {\n| #...blue => Js.log("This is a blue color")\n| #...red => Js.log("This is a red color")\n| other => Js.log2("Other color than red and blue: ", other)\n}\n')),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-js"}),'// This code got heavily optimized due to the usage of\n// constant values in a switch expression\nconsole.log("Other color than red and blue: ", "Papayawhip");\n\nvar c = "Ruby";\n'))),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"switch")," expression above is a shorter and more convenient version of:"),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-res"}),'switch #Papayawhip {\n  | #Sapphire | #Neon | #Navy => Js.log("This is a blue color")\n  | #Ruby | #Redwood | #Rust => Js.log("This is a red color")\n  | other => Js.log2("Other color than red and blue: ", other)\n}\n')),(0,o.kt)("h3",i({},{id:"recursive-type-definitions"}),"Recursive Type Definitions"),(0,o.kt)("p",null,"Poly variant types are non-recursive by default. Use the ",(0,o.kt)("inlineCode",{parentName:"p"},"rec")," keyword to allow recursion:"),(0,o.kt)(p,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-res"}),'type rec markdown = [\n  | #Text(string)\n  | #Paragraph(markdown)\n  | #Ul(array<markdown>)\n]\n\nlet content: markdown = #Paragraph(#Text("hello world"))\n')),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-js"}),'var content = {\n  NAME: "Paragraph",\n  VAL: {\n    NAME: "Text",\n    VAL: "hello world"\n  }\n};\n'))),(0,o.kt)("h3",i({},{id:"annotations-with-closed--upper--lower-bound-constraints"}),"Annotations with Closed / Upper / Lower Bound Constraints"),(0,o.kt)("p",null,'There\'s also a way to define an "upper" and "lower" bound constraint for a poly variant type. Here is what it looks like in a type annotation:'),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-res"}),'// Only #Red allowed, no upper / lower bound (closed poly variant)\nlet basic: [#Red] = #Red\n\n// May contain #Red, or any other value (open poly variant)\n// here, foreground will actually be inferred as [> #Red | #Green]\nlet foreground: [> #Red] = #Green\n\n// The value must be "one of" #Red | #Blue\n// Only #Red and #Blue are valid values\nlet background: [< #Red | #Blue] = #Red\n')),(0,o.kt)("p",null,"Don't worry about the upper / lower bound feature just yet, since this is a very advanced topic that's often not really needed. For the sake of completeness, we mention a few details about it ",(0,o.kt)("a",i({parentName:"p"},{href:"#lower--upper-bound-constraints"}),"later on"),"."),(0,o.kt)("h2",i({},{id:"polymorphic-variants-are-structurally-typed"}),"Polymorphic Variants are Structurally Typed"),(0,o.kt)("p",null,"As we've already seen in the section above, poly variants don't need any explicit type definition to be used as a value."),(0,o.kt)("p",null,"The compiler treats every value as an independent type and doesn't couple it to any particular module (like with common variants). It therefore compares different poly variant types by their structure, not by a defined type name."),(0,o.kt)("p",null,"Here is what the type checker sees whenever you are using a poly variant:"),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-res"}),"// inferred as [> #Red]\nlet color = #Red\n")),(0,o.kt)("p",null,"The compiler will automatically infer the ",(0,o.kt)("inlineCode",{parentName:"p"},"color")," binding as a value of type ",(0,o.kt)("inlineCode",{parentName:"p"},"[> #Red]"),", which means ",(0,o.kt)("inlineCode",{parentName:"p"},"color")," will type check with any other poly variant type that defines ",(0,o.kt)("inlineCode",{parentName:"p"},"#Red")," in its constructors."),(0,o.kt)("p",null,"You can interchangably use variant values from different modules and types as long as a value is part of a constructor set. For example:"),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-res"}),"type rgb = [#Red | #Green | #Blue]\n\nlet colors: array<rgb> = [#Red]\n\n// `other` is inferred as a type of array<[> #Green]>\nlet other = [#Green]\n\n// Because `other` is of type `array<[> Green]>`,\n// this will type check even though we didn't define\n// `other`to be of type rgb\nlet all = Belt.Array.concat(colors, other)\n")),(0,o.kt)("p",null,"As you can see in the example above, the type checker doesn't really care about the fact that ",(0,o.kt)("inlineCode",{parentName:"p"},"other")," is not annotated as an ",(0,o.kt)("inlineCode",{parentName:"p"},"array<rgb>")," type. "),(0,o.kt)("p",null,"As soon as it hits the first constraint (",(0,o.kt)("inlineCode",{parentName:"p"},"Belt.Array.concat"),"), it will try to check if the structural types of ",(0,o.kt)("inlineCode",{parentName:"p"},"colors")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"other")," unify into one poly variant type. If there's a mismatch, you will get an error on the ",(0,o.kt)("inlineCode",{parentName:"p"},"Belt.Array.concat")," call."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Be aware that this behavior may cause confusing type errors in the wrong source code locations!")),(0,o.kt)("p",null,"For instance, if we'd make a typo like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-res"}),"// Note the typo in the #Green constructor\nlet other = [#GreeN]\n\nlet all = Belt.Array.concat(colors, other)\n")),(0,o.kt)("p",null,"We'd get an error on the ",(0,o.kt)("inlineCode",{parentName:"p"},"concat")," call, even thought the error was actually caused by the typo in the value assignment of ",(0,o.kt)("inlineCode",{parentName:"p"},"other"),"."),(0,o.kt)("h2",i({},{id:"javascript-output"}),"JavaScript Output"),(0,o.kt)("p",null,"Poly variants are a ",(0,o.kt)("a",i({parentName:"p"},{href:"./shared-data-types"}),"shared data structure"),", so they are very useful to bind to JavaScript. It is safe to rely on its compiled JS structure."),(0,o.kt)("p",null,"A value compiles to the following JavaScript output:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"If the variant value is a constructor without any payload, it compiles to a string of the same name"),(0,o.kt)("li",{parentName:"ul"},"Values with a payload get compiled to an object with a ",(0,o.kt)("inlineCode",{parentName:"li"},"NAME")," attribute stating the name of the constructor, and a ",(0,o.kt)("inlineCode",{parentName:"li"},"VAL")," attribute containing the JS representation of the payload.")),(0,o.kt)("p",null,"Check the output in these examples:"),(0,o.kt)(p,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'let capitalized = #Hello\nlet lowercased = #goodbye\n\nlet err = #error("oops!")\n\nlet num = #\\"1"\n')),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-js"}),'var capitalized = "Hello";\n\nvar lowercased = "goodbye";\n\nvar err = {\n  NAME: "error",\n  VAL: "oops!"\n};\n\nvar num = "1";\n'))),(0,o.kt)("h3",i({},{id:"bind-to-js-functions"}),"Bind to JS Functions"),(0,o.kt)("p",null,"Poly variants play an important role for binding to functions in JavaScript."),(0,o.kt)("p",null,"For example, let's assume we want to bind to ",(0,o.kt)("inlineCode",{parentName:"p"},"Intl.NumberFormat")," and want to make sure that our users only pass valid locales, we could define an external binding like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-res"}),'// IntlNumberFormat.res\ntype t\n\n@bs.val\nexternal make: ([#\\"de-DE" | #\\"en-GB" | #\\"en-US" ]) => t = "Intl.NumberFormat"\n')),(0,o.kt)("p",null,"We could later use our newly created bindings like this:"),(0,o.kt)(p,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-res"}),'// MyApp.res\n\nlet intl = IntlNumberFormat.make(#\\"de-DE")\n')),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-js"}),'var intl = Intl.NumberFormat("de-DE");\n'))),(0,o.kt)("p",null,"The JS Output is practically identical to handwritten JS, but we also get to enjoy all the benefits of a variant. "),(0,o.kt)("p",null,"More usage examples for poly variant interop can be found in ",(0,o.kt)("a",i({parentName:"p"},{href:"bind-to-js-function#constrain-arguments-better"}),"Bind to JS Function")," and ",(0,o.kt)("a",i({parentName:"p"},{href:"generate-converters-accessors#generate-converters-for-js-string-enums-and-polymorphic-variants"}),"Generate Converters and Helper"),"."),(0,o.kt)("h3",i({},{id:"bind-to-string-enums"}),"Bind to String Enums"),(0,o.kt)("p",null,"Let's assume we have a TypeScript module that expresses following (stringly typed) enum export:"),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-js"}),'// direction.js\nenum Direction {\n  Up = "UP",\n  Down = "DOWN",\n  Left = "LEFT",\n  Right = "RIGHT",\n}\n\nexport const myDirection = Direction.Up\n')),(0,o.kt)("p",null,"For this particular example, we can also inline poly variant type definitions to design the type for the imported ",(0,o.kt)("inlineCode",{parentName:"p"},"myDirection")," value:"),(0,o.kt)(p,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-res"}),'type direction = [ #UP | #DOWN | #LEFT | #RIGHT ]\n@bs.module("./direction.js") external myDirection: direction = "myDirection"\n')),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-js"}),'var DirectionJs = require("./direction.js");\n\nvar myDirection = DirectionJs.myDirection;\n'))),(0,o.kt)("p",null,"Again: since we were using poly variants, the JS Output is practically zero-cost and doesn't add any extra code!"),(0,o.kt)("h2",i({},{id:"lower--upper-bound-constraints"}),"Lower / Upper Bound Constraints"),(0,o.kt)("p",null,"There are a few different ways to define constraints on a poly variant type, such as ",(0,o.kt)("inlineCode",{parentName:"p"},"[>"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"[<")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"["),". Some of them were briefly mentioned before, so in this section we will quickly explain what this syntax is about."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Note:")," We added this info for educational purposes. In most cases you will not want to use any of this stuff, since it makes your APIs pretty unreadable / hard to use."),(0,o.kt)("h3",i({},{id:"closed-"}),"Closed (",(0,o.kt)("inlineCode",{parentName:"h3"},"["),")"),(0,o.kt)("p",null,"This is the simplest poly variant definition, and also the most practical one. Like a common variant type, this one defines an exact set of constructors."),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-res"}),"type rgb = [ #Red | #Green | #Blue ]\n\nlet color: rgb = #Green\n")),(0,o.kt)("p",null,"In the example above, ",(0,o.kt)("inlineCode",{parentName:"p"},"color")," will only allow one of the three constructors that are defined in the ",(0,o.kt)("inlineCode",{parentName:"p"},"rgb")," type. This is usually the way how poly variants should be defined."),(0,o.kt)("p",null,"In case you want to define a type that is extensible in polymorphic ways (or in other words, subtyping allowed sets of constructors), you'll need to use the lower / upper bound syntax. "),(0,o.kt)("h3",i({},{id:"lower-bound-"}),"Lower Bound (",(0,o.kt)("inlineCode",{parentName:"h3"},"[>"),")"),(0,o.kt)("p",null,'A lower bound defines the minimum set of constructors a poly variant type is aware of. It is also considered an "open poly variant type", because it doesn\'t restrict any additional values.'),(0,o.kt)("p",null,"Here is an example on how to make a minimum set of ",(0,o.kt)("inlineCode",{parentName:"p"},"basicBlueTones")," extensible for a new ",(0,o.kt)("inlineCode",{parentName:"p"},"color")," type:"),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-res"}),"type basicBlueTone<'a> = [> #Blue | #DeepBlue | #LightBlue ] as 'a\ntype color = basicBlueTone<[#Blue | #DeepBlue | #LightBlue | #Purple]>\n\nlet color:  color = #Purple\n\n// This will fail due to missing minimum constructors:\ntype notWorking = basicBlueTone<[#Purple]>\n")),(0,o.kt)("p",null,"Here, the compiler will enforce the user to define ",(0,o.kt)("inlineCode",{parentName:"p"},"#Blue | #DeepBlue | #LightBlue")," as the minimum set of constructors when trying to extend ",(0,o.kt)("inlineCode",{parentName:"p"},"basicBlueTone<'a>"),". "),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Note:")," Since we want to define an extensible poly variant, we need to provide a type placeholder ",(0,o.kt)("inlineCode",{parentName:"p"},"<'a>"),", and also add ",(0,o.kt)("inlineCode",{parentName:"p"},"as 'a"),' after the poly variant declaration, which essentially means: "Given type ',(0,o.kt)("inlineCode",{parentName:"p"},"'a")," is constraint to the minimum set of constructors (",(0,o.kt)("inlineCode",{parentName:"p"},"#Blue | #DeepBlue | #LightBlue"),") defined in ",(0,o.kt)("inlineCode",{parentName:"p"},"basicBlueTone"),'".'),(0,o.kt)("h3",i({},{id:"upper-bound-"}),"Upper Bound (",(0,o.kt)("inlineCode",{parentName:"h3"},"[<"),")"),(0,o.kt)("p",null,"The upper bound works in the opposite way than a lower bound: the extending type may only use constructors that are stated in the upper bound constraint."),(0,o.kt)("p",null,"Here another example, but with red colors:"),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-res"}),"type validRed<'a> = [< #Fire | #Crimson | #Ash] as 'a\ntype myReds = validRed<[#Ash]>\n\n// This will fail due to unlisted constructor not defined by the lower bound\ntype notWorking = validRed<[#Purple]>\n")),(0,o.kt)("h2",i({},{id:"variant-vs-polymorphic-variant"}),"Variant vs Polymorphic Variant"),(0,o.kt)("p",null,"One might think that polymorphic variants are fastly superior to common ",(0,o.kt)("a",i({parentName:"p"},{href:"./variant"}),"variants"),". As always, it depends on the use case:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Variants allow better encapsulation for your APIs, because they always come with a type definition that is coupled to a specific module."),(0,o.kt)("li",{parentName:"ul"},"Variants are conceptionally easier to understand, makes your code easy to refactor and provides better exhaustive pattern matching support"),(0,o.kt)("li",{parentName:"ul"},"Variants usually deliver better type error messages, especially in recursive type definitions"),(0,o.kt)("li",{parentName:"ul"},"Poly variants are useful for expressing strings in JS, and allow different type composition strategies. They can also be defined adhocly in your type definitions.")),(0,o.kt)("p",null,"In most scenarios, we'd recommend to use common variants over polymorphic variants, especially when you are writing plain ReScript code. In case you want to write zero-cost interop bindings or generate clean JS output, poly variants are oftentimes a better option."))}c.isMDXComponent=!0,c.frontmatter={title:"Polymorphic Variant",description:"The Polymorphic Variant data structure in ReScript",canonical:"/docs/manual/latest/polymorphic-variant",__ghEditHref:"https://github.com/reason-association/rescript-lang.org/blob/master/pages/docs/manual/v9.0.0/polymorphic-variant.mdx"}},77054:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/docs/manual/v9.0.0/polymorphic-variant",function(){return n(24908)}])}},function(e){e.O(0,[92888,49774,40179],(function(){return t=77054,e(e.s=t);var t}));var t=e.O();_N_E=t}]);