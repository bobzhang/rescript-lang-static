(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[19218],{17375:function(e,n,t){"use strict";function a(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},p=Object.keys(e);for(a=0;a<p.length;a++)t=p[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var p=Object.getOwnPropertySymbols(e);for(a=0;a<p.length;a++)t=p[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}t.d(n,{Z:function(){return a}})},38161:function(e,n,t){"use strict";t.r(n),t.d(n,{default:function(){return u}});var a=t(17375),o=t(96156),p=(t(67294),t(3905));function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){(0,o.Z)(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}var l,s=(l="Intro",function(e){return console.warn("Component "+l+" was not imported, exported, or provided by MDXProvider as global scope"),(0,p.kt)("div",i({},e))}),m={};function u(e){var n=e.components,t=(0,a.Z)(e,["components"]);return(0,p.kt)("wrapper",i(i(i({},m),t),{},{components:n,mdxType:"MDXLayout"}),(0,p.kt)("h1",i({},{id:"usage"}),"Usage"),(0,p.kt)(s,{mdxType:"Intro"},(0,p.kt)("p",null,(0,p.kt)("inlineCode",{parentName:"p"},"genType")," operates on two kinds of entities: ",(0,p.kt)("em",{parentName:"p"},"types")," and ",(0,p.kt)("em",{parentName:"p"},"values"),".\nEach can be ",(0,p.kt)("em",{parentName:"p"},"exported")," from ReScript to JS, or ",(0,p.kt)("em",{parentName:"p"},"imported")," into ReScript from JS.\nThe main annotation is ",(0,p.kt)("inlineCode",{parentName:"p"},"@genType"),", which by default means ",(0,p.kt)("em",{parentName:"p"},"export"),".")),(0,p.kt)("h2",i({},{id:"export-and-import-types"}),"Export and Import Types"),(0,p.kt)("p",null,"The following exports a function type ",(0,p.kt)("inlineCode",{parentName:"p"},"callback")," to JS:"),(0,p.kt)("pre",null,(0,p.kt)("code",i({parentName:"pre"},{className:"language-res"}),"@genType\ntype callback = ReactEvent.Mouse.t => unit\n")),(0,p.kt)("p",null,"To instead import a type called ",(0,p.kt)("inlineCode",{parentName:"p"},"complexNumber")," from JS module ",(0,p.kt)("inlineCode",{parentName:"p"},"MyMath.ts")," (or ",(0,p.kt)("inlineCode",{parentName:"p"},"MyMath.js"),"), use the ",(0,p.kt)("inlineCode",{parentName:"p"},"@genType.import")," annotation:"),(0,p.kt)("pre",null,(0,p.kt)("code",i({parentName:"pre"},{className:"language-res"}),'@genType.import("./MyMath")\ntype complexNumber\n')),(0,p.kt)("p",null,"This imported type will be treated as opaque by ReScript."),(0,p.kt)("h2",i({},{id:"export-and-import-values"}),"Export and Import Values"),(0,p.kt)("p",null,"To export a function ",(0,p.kt)("inlineCode",{parentName:"p"},"callback")," to JS:"),(0,p.kt)("pre",null,(0,p.kt)("code",i({parentName:"pre"},{className:"language-res"}),'@genType\nlet callback = _ => Js.log("Clicked");\n')),(0,p.kt)("p",null,"To rename the function and export it as ",(0,p.kt)("inlineCode",{parentName:"p"},"CB")," on the JS side, use"),(0,p.kt)("pre",null,(0,p.kt)("code",i({parentName:"pre"},{className:"language-res"}),'@genType\n@genType.as("CB")\nlet callback = _ => Js.log("Clicked");\n')),(0,p.kt)("p",null,"or the more compact"),(0,p.kt)("pre",null,(0,p.kt)("code",i({parentName:"pre"},{className:"language-res"}),'@genType("CB")\nlet callback = _ => Js.log("Clicked");\n')),(0,p.kt)("p",null,"To import a function ",(0,p.kt)("inlineCode",{parentName:"p"},"realValue")," from JS module ",(0,p.kt)("inlineCode",{parentName:"p"},"MyMath.ts")," (or ",(0,p.kt)("inlineCode",{parentName:"p"},"MyMath.js"),"):"),(0,p.kt)("pre",null,(0,p.kt)("code",i({parentName:"pre"},{className:"language-res"}),'@genType.import("./MyMath") /* JS module to import from. */\n/* Name and type of the JS value to import. */\nexternal realValue: complexNumber => float = "realValue";\n')),(0,p.kt)("blockquote",null,(0,p.kt)("p",{parentName:"blockquote"},(0,p.kt)("strong",{parentName:"p"},"Note:")," With genType < 2.17.0 or bucklescript < 5.0.0, one had to add a line with ",(0,p.kt)("inlineCode",{parentName:"p"},"@bs.module")," and the current file name. See the older ",(0,p.kt)("a",i({parentName:"p"},{href:"https://github.com/cristianoc/genType/blob/v2.16.0/README.md"}),"README"),".")),(0,p.kt)("p",null,"Because of the ",(0,p.kt)("inlineCode",{parentName:"p"},"external")," keyword, it's clear from context that this is an import, so you can also just use ",(0,p.kt)("inlineCode",{parentName:"p"},"@genType")," and omit ",(0,p.kt)("inlineCode",{parentName:"p"},".import"),"."),(0,p.kt)("p",null,"To import a default JS export, use a second argument to ",(0,p.kt)("inlineCode",{parentName:"p"},"@genType.import")," e.g. ",(0,p.kt)("inlineCode",{parentName:"p"},'@genType.import(("./MyMath", "default"))'),"."),(0,p.kt)("p",null,"Similarly, to import a value with a different JS name, use e.g. ",(0,p.kt)("inlineCode",{parentName:"p"},'@genType.import(("./MyMath", "ValueStartingWithUpperCaseLetter"))'),"."),(0,p.kt)("p",null,"To import nested values, e.g. ",(0,p.kt)("inlineCode",{parentName:"p"},"Some.Nested.value"),", use e.g. ",(0,p.kt)("inlineCode",{parentName:"p"},'@genType.import(("./MyMath", "Some.Nested.value"))'),"."),(0,p.kt)("h2",i({},{id:"interface-resi-and-implementation-res-files"}),"Interface (.resi) and Implementation (.res) files"),(0,p.kt)("p",null,"If both ",(0,p.kt)("inlineCode",{parentName:"p"},"Foo.resi")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"Foo.res")," exist, the annotations are taken from ",(0,p.kt)("inlineCode",{parentName:"p"},"Foo.resi"),". The same happens with local modules: if present, the module type gets precedence."),(0,p.kt)("p",null,"The behaviour can be overridden by adding annotation ",(0,p.kt)("inlineCode",{parentName:"p"},"@genType.ignoreInterface")," at the top of ",(0,p.kt)("inlineCode",{parentName:"p"},"Foo.resi"),". Use case: expose implementation details to JS but not to ReScript."),(0,p.kt)("h2",i({},{id:"type-expansion-and-gentypeopaque"}),"Type Expansion and @genType.opaque"),(0,p.kt)("p",null,"If an exported type ",(0,p.kt)("inlineCode",{parentName:"p"},"persons")," references other types in its definition, those types are also exported by default, as long as they are defined in the same file:"),(0,p.kt)("pre",null,(0,p.kt)("code",i({parentName:"pre"},{className:"language-res"}),"type name = string\ntype surname = string\ntype person = {name: name, surname: surname}\n\n@genType\ntype persons = array<person>;\n")),(0,p.kt)("p",null,"If however you wish to hide from JS the fact that ",(0,p.kt)("inlineCode",{parentName:"p"},"name")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"surname")," are strings, you can do it with the ",(0,p.kt)("inlineCode",{parentName:"p"},"@genType.opaque")," annotation:"),(0,p.kt)("pre",null,(0,p.kt)("code",i({parentName:"pre"},{className:"language-res"}),"@genType.opaque\ntype name = string\n\n@genType.opaque\ntype surname = string\n\ntype person = {\n  name,\n  surname,\n};\n\n@genType\ntype persons = array<person>;\n")),(0,p.kt)("h2",i({},{id:"renaming-gentypeas-and-object-mangling-convention"}),"Renaming, @genType.as, and object mangling convention."),(0,p.kt)("p",null,"By default, entities with a given name are exported/imported with the same name. However, you might wish to change the appearence of the name on the JS side."),(0,p.kt)("p",null,(0,p.kt)("strong",{parentName:"p"},"NOTE:")," Starting from ReScript 7.0.0, ",(0,p.kt)("inlineCode",{parentName:"p"},"@genType.as")," on record fields will be discouraged,\nas it incurs a runtime conversion cost. Instead ",(0,p.kt)("inlineCode",{parentName:"p"},"@bs.as")," will be supported and incur zero cost."),(0,p.kt)("p",null,"For example, in case of a record field whose name is a keyword, such as ",(0,p.kt)("inlineCode",{parentName:"p"},"type"),":"),(0,p.kt)("pre",null,(0,p.kt)("code",i({parentName:"pre"},{className:"language-res"}),'@genType\ntype shipment = {\n  date: float,\n  @genType.as("type")\n  type_: string,\n}\n')),(0,p.kt)("p",null,"Object field names follow ReScript's mangling convention:"),(0,p.kt)("pre",null,(0,p.kt)("code",i({parentName:"pre"},{}),'Remove trailing "__" if present.\nOtherwise remove leading "_" when followed by an uppercase letter, or keyword.\n')),(0,p.kt)("p",null,"This means that the analogous example with objects is:"),(0,p.kt)("pre",null,(0,p.kt)("code",i({parentName:"pre"},{className:"language-res"}),'@genType\ntype shipment = {\n  "date": float,\n  "_type": string,\n}\n')),(0,p.kt)("p",null,"or the equivalent ",(0,p.kt)("inlineCode",{parentName:"p"},' "type__": string'),"."),(0,p.kt)("p",null,"Functions and function components also follow the mangling convention for labeled arguments:"),(0,p.kt)("pre",null,(0,p.kt)("code",i({parentName:"pre"},{className:"language-res"}),'@genType\nlet exampleFunction = (~_type) => "type: " ++ _type\n\n@genType\n@react.component\nlet exampleComponent = (~_type) => React.string("type: " ++ _type)\n')),(0,p.kt)("p",null,"It is possible to use ",(0,p.kt)("inlineCode",{parentName:"p"},"@genType.as")," for functions, though this is only maintained for backwards compatibility, and cannot be used on function components:"),(0,p.kt)("pre",null,(0,p.kt)("code",i({parentName:"pre"},{className:"language-res"}),'@genType\nlet functionWithGenTypeAs =\n  (~date: float) => @genType.as("type") (~type_: string) => ...\n')),(0,p.kt)("p",null,(0,p.kt)("strong",{parentName:"p"},"NOTE:")," For technical reasons, it is not possible to use ",(0,p.kt)("inlineCode",{parentName:"p"},"@genType.as")," on the first argument of a function."),(0,p.kt)("h2",i({},{id:"dependent-projects--libraries"}),"Dependent Projects / Libraries"),(0,p.kt)("p",null,"ReScript dependencies are specified in ",(0,p.kt)("inlineCode",{parentName:"p"},"bs-dependencies"),".\nFor example, if the dependencies are ",(0,p.kt)("inlineCode",{parentName:"p"},'"bs-dependencies": ["somelibrary"]')," and ",(0,p.kt)("inlineCode",{parentName:"p"},"somelibrary")," contains ",(0,p.kt)("inlineCode",{parentName:"p"},"Common.res"),", this looks up the types of ",(0,p.kt)("inlineCode",{parentName:"p"},"foo")," in the library:"),(0,p.kt)("pre",null,(0,p.kt)("code",i({parentName:"pre"},{className:"language-res"}),"@genType\nlet z = Common.foo;\n")),(0,p.kt)("p",null,"Scoped packages of the form e.g. ",(0,p.kt)("inlineCode",{parentName:"p"},"@demo/somelibrary")," are also supported."),(0,p.kt)("p",null,(0,p.kt)("strong",{parentName:"p"},"NOTE:")," The library must have been published with the ",(0,p.kt)("inlineCode",{parentName:"p"},".gen.ts")," files created by genType."))}u.isMDXComponent=!0,u.frontmatter={__ghEditHref:"https://github.com/reason-association/rescript-lang.org/blob/master/pages/docs/gentype/latest/usage.mdx"}},30835:function(e,n,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/docs/gentype/latest/usage",function(){return t(38161)}])}},function(e){e.O(0,[92888,49774,40179],(function(){return n=30835,e(e.s=n);var n}));var n=e.O();_N_E=n}]);