(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[92894],{17375:function(e,t,n){"use strict";function a(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}n.d(t,{Z:function(){return a}})},57839:function(e,t,n){"use strict";n.r(t),n.d(t,{default:function(){return d}});var a=n(17375),r=n(96156),o=(n(67294),n(3905));function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){(0,r.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var s=function(e){return function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,o.kt)("div",i({},t))}},p=s("Intro"),c=s("CodeTab"),m={};function d(e){var t=e.components,n=(0,a.Z)(e,["components"]);return(0,o.kt)("wrapper",i(i(i({},m),n),{},{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",i({},{id:"elements--jsx"}),"Elements & JSX"),(0,o.kt)(p,{mdxType:"Intro"},(0,o.kt)("p",null,"Elements are the smallest building blocks of React apps. This page will explain how to handle ",(0,o.kt)("inlineCode",{parentName:"p"},"React.element"),"s in your React app with our dedicated JSX syntax.")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"Note:")," This page assumes your ",(0,o.kt)("inlineCode",{parentName:"p"},"bsconfig.json")," to be set to ",(0,o.kt)("inlineCode",{parentName:"p"},'"reason": { "react-jsx": 3 }'),", otherwise your JSX will not be transformed to its React specific form. ")),(0,o.kt)("h2",i({},{id:"element-basics"}),"Element Basics"),(0,o.kt)("p",null,"Let's start out by creating our first React element."),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-res"}),'let element = <h1> {React.string("Hello World")} </h1>\n')),(0,o.kt)("p",null,"The binding ",(0,o.kt)("inlineCode",{parentName:"p"},"element")," and the expression ",(0,o.kt)("inlineCode",{parentName:"p"},'{React.string("Hello World")}')," are both of type ",(0,o.kt)("inlineCode",{parentName:"p"},"React.element"),", the fundamental type for representing React elements within a React application. An element describes what you see on the screen whenever you render your application to the DOM."),(0,o.kt)("p",null,"Let's say you want to create a function that handles another React element, such as ",(0,o.kt)("inlineCode",{parentName:"p"},"children"),", you can annotate it as ",(0,o.kt)("inlineCode",{parentName:"p"},"React.element"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-res"}),'let wrapChildren = (children: React.element) => {\n  <div>\n    <h1> {React.string("Overview")} </h1>\n    children\n  </div>\n}\n\nwrapChildren(<div> {React.string("Let\'s use React with ReScript")} </div>)\n')),(0,o.kt)("p",null,"Understanding the definition of a ",(0,o.kt)("inlineCode",{parentName:"p"},"React.element")," is essential since it is heavily used within the React APIs, such as ",(0,o.kt)("inlineCode",{parentName:"p"},"ReactDOM.render(element, ...)"),", etc. Be aware that JSX doesn't do any automatic ",(0,o.kt)("inlineCode",{parentName:"p"},"string")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"React.element")," conversion for you (ReScript forces explicit type conversion). For example ",(0,o.kt)("inlineCode",{parentName:"p"},"<div> Hello World </div>")," will not type-check (which is actually a good thing because it's also a huge source for subtle bugs!), you need to convert your ",(0,o.kt)("inlineCode",{parentName:"p"},'"Hello World"')," with the ",(0,o.kt)("inlineCode",{parentName:"p"},"React.string")," function first."),(0,o.kt)("p",null,"Fortunately our React bindings bring all necessary functionality to represent all relevant data types as ",(0,o.kt)("inlineCode",{parentName:"p"},"React.element"),"s."),(0,o.kt)("h2",i({},{id:"using-elements-within-jsx"}),"Using Elements within JSX"),(0,o.kt)("p",null,"You can compose elements into more complex structures by using JSX:"),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-res"}),'let greeting = React.string("Hello ")\nlet name = React.string("Stranger");\n\n\n// element is also of type React.element\nlet element = <div className="myElement"> greeting name </div>\n')),(0,o.kt)("p",null,"JSX is the main way to express your React application as a tree of elements."),(0,o.kt)("p",null,"Sometimes, when doing a lot of interop with existing ReactJS codebases, you'll find yourself in a situation where you can't use JSX syntax due to syntactic restrictions. Check out the ",(0,o.kt)("a",i({parentName:"p"},{href:"#escape-hatches"}),"Escape Hatches")," chapter later on for workarounds."),(0,o.kt)("h2",i({},{id:"creating-elements"}),"Creating Elements"),(0,o.kt)("h3",i({},{id:"creating-elements-from-string-int-float-array"}),"Creating Elements from ",(0,o.kt)("inlineCode",{parentName:"h3"},"string"),", ",(0,o.kt)("inlineCode",{parentName:"h3"},"int"),", ",(0,o.kt)("inlineCode",{parentName:"h3"},"float"),", ",(0,o.kt)("inlineCode",{parentName:"h3"},"array")),(0,o.kt)("p",null,"Apart from using JSX to create our React elements or React components, the ",(0,o.kt)("inlineCode",{parentName:"p"},"React")," module offers various functions to create elements from primitive data types:"),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-res"}),'React.string("Hello") // new element representing "Hello"\n\nReact.int(1) // new element representing "1"\n\nReact.float(1.0) // new element representing "1.0"\n')),(0,o.kt)("p",null,"It also offers ",(0,o.kt)("inlineCode",{parentName:"p"},"React.array")," to represent multiple elements as one single element (useful for rendering a list of data, or passing children):"),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-res"}),'let element = React.array([\n  React.string("element 1"),\n  React.string("element 2"),\n  React.string("element 3")\n])\n')),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Note:")," We don't offer a ",(0,o.kt)("inlineCode",{parentName:"p"},"React.list")," function because a ",(0,o.kt)("inlineCode",{parentName:"p"},"list")," value would impose runtime overhead. ReScript cares about clean, idiomatic JS output. If you want to transform a ",(0,o.kt)("inlineCode",{parentName:"p"},"list")," of elements to a single React element, combine the output of ",(0,o.kt)("inlineCode",{parentName:"p"},"Belt.List.toArray")," with ",(0,o.kt)("inlineCode",{parentName:"p"},"React.array")," instead."),(0,o.kt)("h3",i({},{id:"creating-null-elements"}),"Creating Null Elements"),(0,o.kt)("p",null,"ReScript doesn't allow ",(0,o.kt)("inlineCode",{parentName:"p"},"element || null")," constraints due to it's strongly typed nature. Whenever you are expressing conditionals where a value might, or might not be rendered, you will need the ",(0,o.kt)("inlineCode",{parentName:"p"},"React.null")," constant to represent ",(0,o.kt)("em",{parentName:"p"},"Nothingness"),":"),(0,o.kt)(c,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-res"}),'let name = Some("Andrea")\n\nlet element = switch name {\n  | Some(name) => <div> {React.string("Hello " ++ name)} </div>\n  | None => React.null\n}\n\n<div> element </div>\n')),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-js"}),'var name = "Andrea";\n\nvar element = name !== undefined ? React.createElement("div", undefined, "Hello " + name) : null;\n\nReact.createElement("div", undefined, element);\n'))),(0,o.kt)("h2",i({},{id:"escape-hatches"}),"Escape Hatches"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Note:")," This chapter features low level APIs that are used by JSX itself, and should only be used whenever you hit certain JSX syntax limitations. More infos on the JSX internals can be found in our ",(0,o.kt)("a",i({parentName:"p"},{href:"./beyond-jsx"}),"Beyond JSX")," section."),(0,o.kt)("h3",i({},{id:"creating-elements-from-component-functions"}),"Creating Elements from Component Functions"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Note:")," Details on components and props will be described in the ",(0,o.kt)("a",i({parentName:"p"},{href:"./components-and-props"}),"next chapter"),"."),(0,o.kt)("p",null,"Sometimes it's necessary to pass around component functions to have more control over ",(0,o.kt)("inlineCode",{parentName:"p"},"React.element")," creation. Use the ",(0,o.kt)("inlineCode",{parentName:"p"},"React.createElement")," function to instantiate your elements:"),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-res"}),'type props = {"name": string};\n\nlet render = (myComp: props => React.element) => {\n  <div>\n    {React.createElement(myComp, {"name": "Franz"})}\n  </div>\n}\n')),(0,o.kt)("p",null,'This feature is often used when interacting with existing JS / ReactJS code. In pure ReScript React applications, you would rather pass a function that does the rendering for you (also called a "render prop"):'),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-res"}),'let render = (renderMyComp: (~name: string) => React.element) => {\n  <div> {renderMyComp(~name="Franz")} </div>\n}\n')),(0,o.kt)("h4",i({},{id:"pass-variadic-children"}),"Pass Variadic Children"),(0,o.kt)("p",null,"There is also a ",(0,o.kt)("inlineCode",{parentName:"p"},"React.createElementVariadic")," function, which takes an array of children as a third parameter:"),(0,o.kt)(c,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-res"}),'type props = {"title": string, "children": React.element};\n\nlet render = (article: props => React.element) => {\n  let children = [React.string("Introduction"), React.string("Body")];\n\n  let props = {"title": "Article #1", "children": React.null};\n\n  {React.createElementVariadic(article, props, children)}\n}\n')),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-js"}),'function render(article) {\n  var children = ["Introduction"];\n  var props = {\n    title: "Article #1",\n    children: null\n  };\n  return Caml_splice_call.spliceApply(React.createElement, [\n              article,\n              props,\n              children\n            ]);\n}\n'))),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Note:")," Here we are passing a prop ",(0,o.kt)("inlineCode",{parentName:"p"},'"children": React.null')," to satisfy the type checker. React will ignore the children prop in favor of the children array."),(0,o.kt)("p",null,"This function is mostly used by our JSX transformations, so usually you want to use ",(0,o.kt)("inlineCode",{parentName:"p"},"React.createElement")," and pass a children prop instead."),(0,o.kt)("h3",i({},{id:"creating-dom-elements"}),"Creating DOM Elements"),(0,o.kt)("p",null,"To create DOM elements (",(0,o.kt)("inlineCode",{parentName:"p"},"<div>"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"<span>"),", etc.), use ",(0,o.kt)("inlineCode",{parentName:"p"},"ReactDOMRe.createDOMElementVariadic"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-res"}),'ReactDOMRe.createDOMElementVariadic("div", ~props=ReactDOM.domProps(~className="card", ()), []);\n')),(0,o.kt)("p",null,"The function above requires the ",(0,o.kt)("inlineCode",{parentName:"p"},"ReactDOM.domProps")," constructor function, so ReScript can make sure that we are only passing valid dom props. You can find an exhaustive list of all available props in the ",(0,o.kt)("a",i({parentName:"p"},{href:"https://github.com/reasonml/reason-react/blob/master/src/ReactDOM.re#L61"}),"ReactDOM")," module."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Warning:")," The ",(0,o.kt)("inlineCode",{parentName:"p"},"ReactDOMRe")," module will be removed in the next major ",(0,o.kt)("inlineCode",{parentName:"p"},"rescript-react")," release, so use sparsely!"),(0,o.kt)("h3",i({},{id:"cloning-elements"}),"Cloning Elements"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Note:")," This is an escape hatch feature and will only be useful for interoping with existing JS code / libraries."),(0,o.kt)("p",null,"Sometimes it's required to clone an existing element to set, overwrite or add prop values to a new instance, or if you want to set invalid prop names such as ",(0,o.kt)("inlineCode",{parentName:"p"},"data-name"),". You can use ",(0,o.kt)("inlineCode",{parentName:"p"},"React.cloneElement")," for that: "),(0,o.kt)(c,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-res"}),'let original = <div className="hello"/>\n\n// Will return a new React.element with className set to "world"\nReact.cloneElement(original, {"className": "world", "data-name": "some name"});\n')),(0,o.kt)("pre",null,(0,o.kt)("code",i({parentName:"pre"},{className:"language-js"}),'var original = React.createElement("div", {\n      className: "hello"\n    });\n\nReact.cloneElement(original, {\n      className: "world",\n      "data-name": "some name"\n    });\n'))),(0,o.kt)("p",null,"The feature mentioned above could also replicate ",(0,o.kt)("inlineCode",{parentName:"p"},"props spreading"),", a practise commonly used in ReactJS codebases, but we strongly discourage the usage due to its unsafe nature and its incorrectness (e.g. adding undefined extra props to a component doesn't make sense, and causes hard to find bugs)."),(0,o.kt)("p",null,"In ReScript, we rather pass down required props explicitly to leaf components or use a renderProp instead. We introduced ",(0,o.kt)("a",i({parentName:"p"},{href:"/docs/manual/latest/jsx#punning"}),"JSX punning")," syntax to make the process of passing down props more convenient."))}d.isMDXComponent=!0,d.frontmatter={title:"Elements & JSX",description:"Basic concepts for React elements and how to use them in JSX",canonical:"/docs/react/latest/elements-and-jsx",__ghEditHref:"https://github.com/reason-association/rescript-lang.org/blob/master/pages/docs/react/latest/elements-and-jsx.mdx"}},37856:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/docs/react/latest/elements-and-jsx",function(){return n(57839)}])}},function(e){e.O(0,[92888,49774,40179],(function(){return t=37856,e(e.s=t);var t}));var t=e.O();_N_E=t}]);