<!DOCTYPE html><html><head><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css"/><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/43ae73b4aa2a5c61cefe.css" as="style"/><link rel="stylesheet" href="/_next/static/css/43ae73b4aa2a5c61cefe.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/webpack-4e582efe68f401073f15.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework-998f5b95ac98f74bab8f.js" as="script"/><link rel="preload" href="/_next/static/chunks/43481-280514135c7b3adb9781.js" as="script"/><link rel="preload" href="/_next/static/chunks/62168-646866730a0afa3b7493.js" as="script"/><link rel="preload" href="/_next/static/chunks/main-7e2e753fca1f45eed2e0.js" as="script"/><link rel="preload" href="/_next/static/chunks/53706-d09a138e6cd709547d22.js" as="script"/><link rel="preload" href="/_next/static/chunks/25396-7c202dfca7dd4a484721.js" as="script"/><link rel="preload" href="/_next/static/chunks/49909-39e42e72225fd86b3fa0.js" as="script"/><link rel="preload" href="/_next/static/chunks/8792-02da446de816dae9d9f0.js" as="script"/><link rel="preload" href="/_next/static/chunks/13692-5739462c0ba24bf7f2e2.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-85ce0337ab254104dc2d.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/docs/manual/v9.0.0/api/belt/mutable-map-11d023288569c446340b.js" as="script"/></head><body><div id="__next"><h1 id="mutablemap">MutableMap</h1><div><p>A mutable sorted map module which allows customize compare behavior.</p></div><p>Same as <code>Belt.Map</code>, but mutable.</p><h2 id="t">t</h2><pre><code class="language-res" metastring="prelude">type t&lt;&#x27;k, &#x27;v, &#x27;id&gt;
</code></pre><h2 id="id">id</h2><pre><code class="language-res" metastring="prelude">type id&lt;&#x27;key, &#x27;id&gt; = Belt_Id.comparable&lt;&#x27;key, &#x27;id&gt;
</code></pre><h2 id="make">make</h2><pre><code class="language-res" metastring="sig">let make: (~id: id&lt;&#x27;k, &#x27;id&gt;) =&gt; t&lt;&#x27;k, &#x27;a, &#x27;id&gt;
</code></pre><h2 id="clear">clear</h2><pre><code class="language-res" metastring="sig">let clear: t&lt;&#x27;a, &#x27;b, &#x27;c&gt; =&gt; unit
</code></pre><h2 id="isempty">isEmpty</h2><pre><code class="language-res" metastring="sig">let isEmpty: t&lt;&#x27;a, &#x27;b, &#x27;c&gt; =&gt; bool
</code></pre><h2 id="has">has</h2><pre><code class="language-res" metastring="sig">let has: (t&lt;&#x27;k, &#x27;a, &#x27;b&gt;, &#x27;k) =&gt; bool
</code></pre><h2 id="cmpu">cmpU</h2><pre><code class="language-res" metastring="sig">let cmpU: (t&lt;&#x27;k, &#x27;a, &#x27;id&gt;, t&lt;&#x27;k, &#x27;a, &#x27;id&gt;, (. &#x27;a, &#x27;a) =&gt; int) =&gt; int
</code></pre><h2 id="cmp">cmp</h2><pre><code class="language-res" metastring="sig">let cmp: (t&lt;&#x27;k, &#x27;a, &#x27;id&gt;, t&lt;&#x27;k, &#x27;a, &#x27;id&gt;, (&#x27;a, &#x27;a) =&gt; int) =&gt; int
</code></pre><p><code>cmp(m1, m2, cmp)</code> First compare by size, if size is the same, compare by key, value pair.</p><h2 id="equ">eqU</h2><pre><code class="language-res" metastring="sig">let eqU: (t&lt;&#x27;k, &#x27;a, &#x27;id&gt;, t&lt;&#x27;k, &#x27;a, &#x27;id&gt;, (. &#x27;a, &#x27;a) =&gt; bool) =&gt; bool
</code></pre><h2 id="eq">eq</h2><pre><code class="language-res" metastring="sig">let eq: (t&lt;&#x27;k, &#x27;a, &#x27;id&gt;, t&lt;&#x27;k, &#x27;a, &#x27;id&gt;, (&#x27;a, &#x27;a) =&gt; bool) =&gt; bool
</code></pre><p><code>eq(m1, m2, eqf)</code> tests whether the maps <code>m1</code> and <code>m2</code> are equal, that is, contain equal keys and associate them with equal data. <code>eqf</code> is the equality predicate used to compare the data associated with the keys.</p><h2 id="foreachu">forEachU</h2><pre><code class="language-res" metastring="sig">let forEachU: (t&lt;&#x27;k, &#x27;a, &#x27;id&gt;, (. &#x27;k, &#x27;a) =&gt; unit) =&gt; unit
</code></pre><h2 id="foreach">forEach</h2><pre><code class="language-res" metastring="sig">let forEach: (t&lt;&#x27;k, &#x27;a, &#x27;id&gt;, (&#x27;k, &#x27;a) =&gt; unit) =&gt; unit
</code></pre><p><code>forEach(m, f)</code> applies f to all bindings in map <code>m</code>. <code>f</code> receives the <code>&#x27;k</code> as first argument, and the associated value as second argument. The bindings are passed to <code>f</code> in increasing order with respect to the ordering over the type of the keys.</p><h2 id="reduceu">reduceU</h2><pre><code class="language-res" metastring="sig">let reduceU: (t&lt;&#x27;k, &#x27;a, &#x27;id&gt;, &#x27;b, (. &#x27;b, &#x27;k, &#x27;a) =&gt; &#x27;b) =&gt; &#x27;b
</code></pre><h2 id="reduce">reduce</h2><pre><code class="language-res" metastring="sig">let reduce: (t&lt;&#x27;k, &#x27;a, &#x27;id&gt;, &#x27;b, (&#x27;b, &#x27;k, &#x27;a) =&gt; &#x27;b) =&gt; &#x27;b
</code></pre><p><code>reduce(m, a, f), computes</code>(f(kN, dN) ... (f(k1, d1, a))...)<code>, where</code>k1 ... kN<code>are the keys of all bindings in</code>m<code>(in increasing order), and</code>d1 ... dN` are the associated data.</p><h2 id="everyu">everyU</h2><pre><code class="language-res" metastring="sig">let everyU: (t&lt;&#x27;k, &#x27;a, &#x27;id&gt;, (. &#x27;k, &#x27;a) =&gt; bool) =&gt; bool
</code></pre><h2 id="every">every</h2><pre><code class="language-res" metastring="sig">let every: (t&lt;&#x27;k, &#x27;a, &#x27;id&gt;, (&#x27;k, &#x27;a) =&gt; bool) =&gt; bool
</code></pre><p><code>every(m, p)</code> checks if all the bindings of the map satisfy the predicate <code>p</code>.</p><h2 id="someu">someU</h2><pre><code class="language-res" metastring="sig">let someU: (t&lt;&#x27;k, &#x27;a, &#x27;id&gt;, (. &#x27;k, &#x27;a) =&gt; bool) =&gt; bool
</code></pre><h2 id="some">some</h2><pre><code class="language-res" metastring="sig">let some: (t&lt;&#x27;k, &#x27;a, &#x27;id&gt;, (&#x27;k, &#x27;a) =&gt; bool) =&gt; bool
</code></pre><p><code>some(m, p)</code> checks if at least one binding of the map satisfy the predicate <code>p</code>.</p><h2 id="size">size</h2><pre><code class="language-res" metastring="sig">let size: t&lt;&#x27;k, &#x27;a, &#x27;id&gt; =&gt; int
</code></pre><h2 id="tolist">toList</h2><pre><code class="language-res" metastring="sig">let toList: t&lt;&#x27;k, &#x27;a, &#x27;id&gt; =&gt; list&lt;(&#x27;k, &#x27;a)&gt;
</code></pre><p>In increasing order.</p><h2 id="toarray">toArray</h2><pre><code class="language-res" metastring="sig">let toArray: t&lt;&#x27;k, &#x27;a, &#x27;id&gt; =&gt; array&lt;(&#x27;k, &#x27;a)&gt;
</code></pre><h2 id="fromarray">fromArray</h2><pre><code class="language-res" metastring="sig">let fromArray: (array&lt;(&#x27;k, &#x27;a)&gt;, ~id: id&lt;&#x27;k, &#x27;id&gt;) =&gt; t&lt;&#x27;k, &#x27;a, &#x27;id&gt;
</code></pre><h2 id="keystoarray">keysToArray</h2><pre><code class="language-res" metastring="sig">let keysToArray: t&lt;&#x27;k, &#x27;a, &#x27;b&gt; =&gt; array&lt;&#x27;k&gt;
</code></pre><h2 id="valuestoarray">valuesToArray</h2><pre><code class="language-res" metastring="sig">let valuesToArray: t&lt;&#x27;b, &#x27;a, &#x27;c&gt; =&gt; array&lt;&#x27;a&gt;
</code></pre><h2 id="minkey">minKey</h2><pre><code class="language-res" metastring="sig">let minKey: t&lt;&#x27;k, &#x27;a, &#x27;b&gt; =&gt; option&lt;&#x27;k&gt;
</code></pre><h2 id="minkeyundefined">minKeyUndefined</h2><pre><code class="language-res" metastring="sig">let minKeyUndefined: t&lt;&#x27;k, &#x27;a, &#x27;b&gt; =&gt; Js.undefined&lt;&#x27;k&gt;
</code></pre><h2 id="maxkey">maxKey</h2><pre><code class="language-res" metastring="sig">let maxKey: t&lt;&#x27;k, &#x27;a, &#x27;b&gt; =&gt; option&lt;&#x27;k&gt;
</code></pre><h2 id="maxkeyundefined">maxKeyUndefined</h2><pre><code class="language-res" metastring="sig">let maxKeyUndefined: t&lt;&#x27;k, &#x27;a, &#x27;b&gt; =&gt; Js.undefined&lt;&#x27;k&gt;
</code></pre><h2 id="minimum">minimum</h2><pre><code class="language-res" metastring="sig">let minimum: t&lt;&#x27;k, &#x27;a, &#x27;b&gt; =&gt; option&lt;(&#x27;k, &#x27;a)&gt;
</code></pre><h2 id="minundefined">minUndefined</h2><pre><code class="language-res" metastring="sig">let minUndefined: t&lt;&#x27;k, &#x27;a, &#x27;b&gt; =&gt; Js.undefined&lt;(&#x27;k, &#x27;a)&gt;
</code></pre><h2 id="maximum">maximum</h2><pre><code class="language-res" metastring="sig">let maximum: t&lt;&#x27;k, &#x27;a, &#x27;b&gt; =&gt; option&lt;(&#x27;k, &#x27;a)&gt;
</code></pre><h2 id="maxundefined">maxUndefined</h2><pre><code class="language-res" metastring="sig">let maxUndefined: t&lt;&#x27;k, &#x27;a, &#x27;b&gt; =&gt; Js.undefined&lt;(&#x27;k, &#x27;a)&gt;
</code></pre><h2 id="get">get</h2><pre><code class="language-res" metastring="sig">let get: (t&lt;&#x27;k, &#x27;a, &#x27;id&gt;, &#x27;k) =&gt; option&lt;&#x27;a&gt;
</code></pre><h2 id="getundefined">getUndefined</h2><pre><code class="language-res" metastring="sig">let getUndefined: (t&lt;&#x27;k, &#x27;a, &#x27;id&gt;, &#x27;k) =&gt; Js.undefined&lt;&#x27;a&gt;
</code></pre><h2 id="getwithdefault">getWithDefault</h2><pre><code class="language-res" metastring="sig">let getWithDefault: (t&lt;&#x27;k, &#x27;a, &#x27;id&gt;, &#x27;k, &#x27;a) =&gt; &#x27;a
</code></pre><h2 id="getexn">getExn</h2><pre><code class="language-res" metastring="sig">let getExn: (t&lt;&#x27;k, &#x27;a, &#x27;id&gt;, &#x27;k) =&gt; &#x27;a
</code></pre><h2 id="checkinvariantinternal">checkInvariantInternal</h2><pre><code class="language-res" metastring="sig">let checkInvariantInternal: t&lt;&#x27;a, &#x27;b, &#x27;c&gt; =&gt; unit
</code></pre><p>Raise when invariant is not held.</p><h2 id="remove">remove</h2><pre><code class="language-res" metastring="sig">let remove: (t&lt;&#x27;k, &#x27;a, &#x27;id&gt;, &#x27;k) =&gt; unit
</code></pre><p><code>remove(m, x)</code> do the in-place modification.</p><h2 id="removemany">removeMany</h2><pre><code class="language-res" metastring="sig">let removeMany: (t&lt;&#x27;k, &#x27;a, &#x27;id&gt;, array&lt;&#x27;k&gt;) =&gt; unit
</code></pre><h2 id="set">set</h2><pre><code class="language-res" metastring="sig">let set: (t&lt;&#x27;k, &#x27;a, &#x27;id&gt;, &#x27;k, &#x27;a) =&gt; unit
</code></pre><p><code>set(m, x, y)</code> do the in-place modification</p><h2 id="updateu">updateU</h2><pre><code class="language-res" metastring="sig">let updateU: (t&lt;&#x27;k, &#x27;a, &#x27;id&gt;, &#x27;k, (. option&lt;&#x27;a&gt;) =&gt; option&lt;&#x27;a&gt;) =&gt; unit
</code></pre><h2 id="update">update</h2><pre><code class="language-res" metastring="sig">let update: (t&lt;&#x27;k, &#x27;a, &#x27;id&gt;, &#x27;k, option&lt;&#x27;a&gt; =&gt; option&lt;&#x27;a&gt;) =&gt; unit
</code></pre><h2 id="mergemany">mergeMany</h2><pre><code class="language-res" metastring="sig">let mergeMany: (t&lt;&#x27;k, &#x27;a, &#x27;id&gt;, array&lt;(&#x27;k, &#x27;a)&gt;) =&gt; unit
</code></pre><h2 id="mapu">mapU</h2><pre><code class="language-res" metastring="sig">let mapU: (t&lt;&#x27;k, &#x27;a, &#x27;id&gt;, (. &#x27;a) =&gt; &#x27;b) =&gt; t&lt;&#x27;k, &#x27;b, &#x27;id&gt;
</code></pre><h2 id="map">map</h2><pre><code class="language-res" metastring="sig">let map: (t&lt;&#x27;k, &#x27;a, &#x27;id&gt;, &#x27;a =&gt; &#x27;b) =&gt; t&lt;&#x27;k, &#x27;b, &#x27;id&gt;
</code></pre><p><code>map(m, f)</code> returns a map with same domain as <code>m</code>, where the associated value a of all bindings of <code>m</code> has been replaced by the result of the application of <code>f</code> to <code>a</code>. The bindings are passed to <code>f</code> in increasing order with respect to the ordering over the type of the keys.</p><h2 id="mapwithkeyu">mapWithKeyU</h2><pre><code class="language-res" metastring="sig">let mapWithKeyU: (t&lt;&#x27;k, &#x27;a, &#x27;id&gt;, (. &#x27;k, &#x27;a) =&gt; &#x27;b) =&gt; t&lt;&#x27;k, &#x27;b, &#x27;id&gt;
</code></pre><h2 id="mapwithkey">mapWithKey</h2><pre><code class="language-res" metastring="sig">let mapWithKey: (t&lt;&#x27;k, &#x27;a, &#x27;id&gt;, (&#x27;k, &#x27;a) =&gt; &#x27;b) =&gt; t&lt;&#x27;k, &#x27;b, &#x27;id&gt;
</code></pre></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{}},"page":"/docs/manual/v9.0.0/api/belt/mutable-map","query":{},"buildId":"S5HYsHOQBCfuIMfZ4LslI","runtimeConfig":{},"nextExport":true,"autoExport":true,"isFallback":false}</script><script nomodule="" src="/_next/static/chunks/polyfills-14689e3e48c095b2d3e7.js"></script><script src="/_next/static/chunks/webpack-4e582efe68f401073f15.js" async=""></script><script src="/_next/static/chunks/framework-998f5b95ac98f74bab8f.js" async=""></script><script src="/_next/static/chunks/43481-280514135c7b3adb9781.js" async=""></script><script src="/_next/static/chunks/62168-646866730a0afa3b7493.js" async=""></script><script src="/_next/static/chunks/main-7e2e753fca1f45eed2e0.js" async=""></script><script src="/_next/static/chunks/53706-d09a138e6cd709547d22.js" async=""></script><script src="/_next/static/chunks/25396-7c202dfca7dd4a484721.js" async=""></script><script src="/_next/static/chunks/49909-39e42e72225fd86b3fa0.js" async=""></script><script src="/_next/static/chunks/8792-02da446de816dae9d9f0.js" async=""></script><script src="/_next/static/chunks/13692-5739462c0ba24bf7f2e2.js" async=""></script><script src="/_next/static/chunks/pages/_app-85ce0337ab254104dc2d.js" async=""></script><script src="/_next/static/chunks/pages/docs/manual/v9.0.0/api/belt/mutable-map-11d023288569c446340b.js" async=""></script><script src="/_next/static/S5HYsHOQBCfuIMfZ4LslI/_buildManifest.js" async=""></script><script src="/_next/static/S5HYsHOQBCfuIMfZ4LslI/_ssgManifest.js" async=""></script><script async="" defer="" src="https://scripts.simpleanalyticscdn.com/latest.js"></script><noscript><img src="https://queue.simpleanalyticscdn.com/noscript.gif" alt=""/></noscript></body></html>